{"meta":{"title":"Wilson'bolg","subtitle":"","description":"","author":"Wilson","url":"https://cooli-willson.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-01-20T16:36:03.439Z","updated":"2020-01-20T16:36:03.439Z","comments":false,"path":"/404.html","permalink":"https://cooli-willson.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-01-20T16:36:03.440Z","updated":"2020-01-20T16:36:03.440Z","comments":true,"path":"links/index.html","permalink":"https://cooli-willson.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-01-20T16:36:03.439Z","updated":"2020-01-20T16:36:03.439Z","comments":false,"path":"about/index.html","permalink":"https://cooli-willson.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2020-01-20T16:39:48.082Z","updated":"2020-01-20T16:39:48.082Z","comments":true,"path":"categories/index.html","permalink":"https://cooli-willson.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-01-20T17:07:20.316Z","updated":"2020-01-20T17:07:20.316Z","comments":true,"path":"repository/index.html","permalink":"https://cooli-willson.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-20T16:34:58.656Z","updated":"2020-01-20T16:34:58.656Z","comments":true,"path":"tags/index.html","permalink":"https://cooli-willson.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-01-20T16:36:03.439Z","updated":"2020-01-20T16:36:03.439Z","comments":false,"path":"books/index.html","permalink":"https://cooli-willson.github.io/books/index.html","excerpt":"","text":""}],"posts":[{"title":"12.ECMAScript 6","slug":"12.ECMAScript 6","date":"2020-01-27T15:56:42.163Z","updated":"2020-01-27T15:57:58.430Z","comments":true,"path":"2020/01/27/12.ECMAScript 6/","link":"","permalink":"https://cooli-willson.github.io/2020/01/27/12.ECMAScript%206/","excerpt":"","text":"严格模式 开启严格模式，当使用SE6模块化开发时，严格模式不需要写，自动启用 如果不使用var、let、const定义变量和常量就不能直接使用 开启严格模式的方式 “use strict”; 12345678910//不允许使用未声明变量x=3; y=4; console.log(x+y); // 不允许出现函数中参数名相同 function fn(a,a)&#123; &#125; fn(3,4); 不允许使用with 12345678910var div=document.createElement(\"div\"); // div.style.width=\"50px\"; // div.style.height=\"50px\"; // div.style.backgroundColor=\"red\"; with(div.style)&#123; width=\"50px\"; height=\"50px\"; backgroundColor=\"red\"; &#125; document.body.appendChild(div); 不能对只读属性赋值 12var str=\"aaaa\";str.length=10; 还有哪些只读属性？ 冻结的属性也是只读属性 123456var obj=&#123; a:1, b:2 &#125;; Object.freeze(obj); obj.a=10; 定义后的只读属性 123456var obj=&#123;&#125;; Object.defineProperty(obj,\"a\",&#123; writable:false, value:10 &#125;) obj.a=20; 对象中只有get方法，没有set方法，因此，也是只读属性 123456var obj=&#123; get a()&#123; return 5; &#125; &#125; obj.a=10; let &amp;&amp; const &amp;&amp; 箭头函数 let 定义一个有范围变量。不是window的属性 12let a=3; console.log(window.a);//undefined let定义的变量仅限于循环及花括号语句块内 1234for(let i=0;i&lt;10;i++)&#123; sum+=i; &#125; console.log(sum,i); let定义的变量仅作用于语句块内 123456789101112131415161718let a=3; function fn()&#123; let b=5; console.log(a);//3 if(b&lt;10)&#123; let a=20; // let定义的变量仅作用于语句块内 console.log(a);//20 &#125; console.log(a);//3 let a=20; function fn()&#123; let a=10; console.log(a); //10 &#125; console.log(a); //20 fn(); const 常量 不可以修改 不能修改引用地址，但是可以修改对象属性 12345const obj=&#123; a:1,b:2 &#125; obj.a=10; //将对象定义为常量不能被清除 箭头函数 函数的参数，如果只有一个参数，可以不写括号 函数的参数，如果没有参数或者参数在一个上，就需要加括号 123456789函数的参数，如果只有一个参数，可以不写括号var fn=a=&gt;a+3;函数的参数，如果没有参数或者参数在一个以上，就需要加括号var fn=()=&gt;3+4;var fn=(a,b)=&gt;a+b;var fn=function (a,b)&#123; return a+b;&#125; 箭头函数中，如果函数内容只有一句话，并且返回该一句话的内容，就可以不用加｛｝，并且不需要写return 1&#x2F;&#x2F; var fn&#x3D;(a,b)&#x3D;&gt;a+b; 如果箭头函数中有多句代码，或者不返回任何内容，就需要加｛｝ 1234var fn=(a,b)=&gt;&#123; var sum=a+b; console.log(sum); &#125; 箭头函数的用法有哪些 123456var arr=[1,2,3,4,345,4,1,7,54,32]; // var arr1=arr.map(item=&gt;item+10); //遍历整个数组并且将每个元素+10 arr.sort((a,b)=&gt;b-a); //排序，并规定排序方式为从达到小排序 // console.log(arr); var arr1=arr.filter(item=&gt;item&gt;2); //筛选所有数组中大于2的元素并将数组储存到arr1中 console.log(arr1); 匿名函数中使用函数箭头 123456789101112var obj=&#123; s:1, a:function()&#123; console.log(this.s); //这里的this是obj &#125;, b:()=&gt;&#123; console.log(this); //这里的this是window &#125; &#125; obj.b(); obj.a(); 箭头函数改变了this的指向 1234567891011121314151617181920212223242526var obj=&#123; a:1, b:function()&#123; setTimeout(function()&#123; // console.log(this.a); //undefined // console.log(this); //这里的this指向的是window &#125;,500) var arr=[1,2,3,4]; arr.forEach(function(item)&#123; // console.log(item+this.a); //打印4次NaN // console.log(this); //这里的this指向的是window &#125;) arr.forEach(item=&gt;&#123; // console.log(item+this.a); //arr的每个元素+a // console.log(this); //函数箭头改变列this指向，指向箭头函数外层的this--&gt;obj &#125;) this setTimeout(()=&gt;&#123; // console.log(this.a); // console.log(this); //函数箭头改变列this指向，指向箭头函数外层的this--&gt;obj &#125;,500) // 箭头函数改变了this指向，将指向箭头函数外层的this &#125; &#125; obj.b(); 1234567891011121314151617181920212223242526272829303132333435var Utils=&#123; ce:function()&#123; var div=document.createElement(\"div\"); Object.assign(div.style,&#123; width:\"50px\", height:\"50px\", backgroundColor:\"red\" &#125;); div.self=this; div.addEventListener(\"click\",this.clickHandler);//原始的 div.addEventListener(\"click\",e=&gt;this.clickHandler(e));//普通的箭头匿名函数 this.handler=e=&gt;&#123;this.clickHandler(e)&#125;;//定义的箭头函数，可以removeEventListener div.addEventListener(\"click\",this.handler); div.addEventListener(\"click\",function(e)&#123; // console.log(this);//div this.clickHandler(e); &#125;) this.c(10); document.body.appendChild(div); &#125;, clickHandler:function(e)&#123; console.log(this)//这里的this被指向div // this.self-&gt;Utils // 当使用箭头函数后，这里的this被指向为原有的Utils对象 console.log(this); &#125;, c:function(a)&#123; console.log(this); &#125; &#125; Utils.ce(); 解构赋值 他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值 解构网络参考资料 数组模型的解构 基本 1234let [a, b, c] = [1, 2, 3]; // a = 1;// b = 2;// c = 3; 可嵌套 1let [a, [[b], c]] = [1, [[2], 3]]; // a = 1 // b = 2 // c = 3 可忽略 1let [a, , b] = [1, 2, 3]; // a = 1 // b = 3 不完全解构 1let [a, , b] = [1, 2, 3]; // a = 1 // b = 3 剩余运算符 1let [a, ...b] = [1, 2, 3]; //a = 1 //b = [2, 3] 字符串等 1let [a, b, c, d, e] = 'hello'; // a = 'h' // b = 'e' // c = 'l' // d = 'l' // e = 'o' 对象模型的解构 基本 1let &#123; foo, bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; // foo = 'aaa' // bar = 'bbb' let &#123; baz : foo &#125; = &#123; baz : 'ddd' &#125;; // foo = 'ddd' 可嵌套可忽略 1let obj = &#123;p: ['hello', &#123;y: 'world'&#125;] &#125;; let &#123;p: [x, &#123; y &#125;] &#125; = obj; // x = 'hello' // y = 'world' let obj = &#123;p: ['hello', &#123;y: 'world'&#125;] &#125;; let &#123;p: [x, &#123; &#125;] &#125; = obj; // x = 'hello' 剩余运算符 1let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;; // a = 10 // b = 20 // rest = &#123;c: 30, d: 40&#125; 数组解构赋值是按照顺序赋值 12let [a,b,c]=[1,2,3]; console.log(a,b,c); 赋值解构可以用来计算函数任意个参数之和 12345678910function sum(...num)&#123; var sumNum = 0; for(let i=0;i&lt;num.length;i++)&#123; sumNum += parseInt(num[i]) &#125; console.log(sumNum) &#125;sum(1,2,3) //6sum(1,2,\"3\") //6sum(1,3,\"6和4\") //10 赋值解构可以用来计算函数参数之和 1234function Sum(...nums)&#123; let sum = nums.reduce((x,y)=&gt;&#123;return x+y&#125;) return sum&#125; 解构赋值可以用来做交换 123456789101112131415var arr=[2,4,6,8,10,1,3,5,7,9]; var len=arr.length-1; while(len&gt;0)&#123; for(let i=0;i&lt;len;i++)&#123; if(arr[i]&lt;arr[i+1])&#123; // var temp=arr[i]; // arr[i]=arr[i+1]; // arr[i+1]=temp; [arr[i],arr[i+1]]=[arr[i+1],arr[i]]; &#125; &#125; len--; &#125; console.log(arr); 传参时，解构赋值可以让参数传递顺序不同 1234function abc(&#123;a,b,c=10&#125;)&#123; console.log(a,c); &#125; abc(&#123;a:5,c:6,b:20&#125;); 字符串方法和Symbol 字符串扩展方法 字符的 Unicode表示法 1\"\\u4e00\" //16进制unicode编码 includes() 表示是否找找到了参数字符串 1console.log(\"abcdef\".includes(\"bc\")); startWidth() 表示参数字符串是否在原字符串的头部 12console.log(\"abcde\".startsWith(\"a\"));//字符串是否是0开始console.log(\"abcde\".startsWith(\"b\",1));//字符串在第几位是否从b开始 endsWidth() 表示参数字符串是否在原字符串的尾部 12console.log(\"abcde\".endsWith(\"e\"));//以e为结尾console.log(\"abcde\".endsWith(\"d\",4));//从第四位开始是否是最尾部 repeat() 表示将原字符串重复几次，返回新的字符串 1console.log((18).toString(16).padStart(2,\"0\")); padStart() 1console.log(Math.floor(Math.random()*10000000).toString().padStart(7,\"0\")) padEnd() 1console.log(Math.floor(Math.random()*10000000).toString().padEnd(7,\"0\")) 字符模板 12345678910111213var age=20; var str=\"小明今年\"+age+\"岁了\"; var str=`小明今年$&#123;age&#125;岁了`; console.log(str); var data=&#123;price:20&#125;; var str=`&lt;div&gt;$&#123;data.price&#125;&lt;div&gt;` var obj=&#123;a:1,b:2,c:&#123;d:1&#125;&#125;; // 浅复制,其次使用...进行复制时，地址也会发生改变，形成新对象 var obj2=obj1=&#123;e:1&#125;; obj1=&#123;...obj&#125;; //将obj的所有元素浅复制给obj1 obj.c.d=10; console.log(obj1===obj2); Symbol 表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 基本用法 12345var a=Symbol(\"a\");var b=Symbol(3);var c=Symbol(\"a\");console.log(a==c);console.log(b.toString()); 简单案例 123456789101112131415161718192021222324252627282930313233343536373839 const LEFT=Symbol(); const UP=Symbol(); const RIGHT=Symbol(); const DOWN=Symbol(); var state; // state=\"left\" state=LEFT; document.addEventListener(\"keyup\",keyHandler); setInterval(animation,16); function keyHandler(e)&#123; switch(e.keyCode)&#123; case 37: state=LEFT; break; case 38: state=UP; break; case 39: state=RIGHT; break; case 40: state=DOWN; break; &#125; &#125; function animation()&#123; if(!state) return switch(state)&#123; case LEFT: break; case RIGHT: break; case UP: break; case DOWN: break; &#125; &#125; set &amp;&amp; Map 数组和对象 数组的优点 1.有顺序 2.紧密性 3.有关联 数组的缺点 1.速度慢，查询，添加，删除 2.有重复 3.判断值时，必须遍历数组 对象的优点 1.有键值对，查询快，插入和删除也很快 2.键唯一 3.多重集合 对象的缺点 1.没有关联 2.按照添加顺序遍历（顺序无法改变） 3.如果需要查询属性时，需要遍历 set set是一个不能有重复元素的集合，重复添加无效 新建set 1let a=new Set() add(value); 12a.add(10);//添加a.add(3);//值是不重复，如果有相同值时，不添加 delete(); 1a.delete(4);//删除 has(value); 1a.has(3);//判断是否存在 clear(); 1a.clear();//清除 #####键值完全相同 1234a.forEach(function(index,value,a)&#123; // 遍历键和值完全相同 console.log(index,value,a); &#125;) for of 遍历 123456for(let value of a)&#123; console.log(value);&#125; for(let value of a.entries())&#123; console.log(value);&#125; 数组去重 123var arr=[1,3,2,4,5,2,1,2,3,5,3,2,3,5,2,1];arr=Array.from(new Set(arr));console.log(arr); WeakSet(); 弱引用列表类型 12345var a=new WeakSet(arr);arr[0]=null;arr.shift();console.log(a,arr); 弱引用列表是不可遍历的 123for(let value of a)&#123; console.log(value); &#125; 当将obj设为null 被维护WeakSet列表中会自动清除它 12345678910111213141516var obj=&#123;a:1&#125;;var arr=[];arr.push(obj);obj=null;arr[0]=null;arr.shift();//弱引用关系，当将obj设为null 被维护WeakSet列表中会自动清除它var obj=&#123;a:1&#125;;var b=new WeakSet();b.add(obj);obj=null;// delete window.obj;console.log(b); map 类型 需要有键值对，需要有长度，可以遍历属性列表，可以遍历数值列表，增删盖查速度快 12345678910111213141516171819202122232425262728293031323334353637let a=new Map(); a.set(\"name\",\"xietian\"); a.set(\"age\",30); a.set(\"sex\",\"man\");//添加键值对 // console.log(a.size); // console.log(a.get(\"age\")); // console.log(a.has(\"age\"));//只能用来查找键 // a.delete(\"age\");//删除键值对 // a.clear();//清空 a.forEach(function(value,key,a)&#123; console.log(value,key,a); &#125;) for(let arr of a)&#123; console.log(arr);//第0项是键，第1项是值 &#125; for(let key of a.keys())&#123; console.log(key); &#125; for(let value of a.values())&#123; console.log(value); &#125; // 普通的map不能使用对象作为属性存储值 var obj=&#123;a:1&#125;; a.set(obj,10);//键被变为强引用 console.log(a); // 弱引用类型，将key设为对象，当对象清除后，弱引用map会自动清除 var c=new WeakMap(); var obj=&#123;a:10&#125;; c.set(obj,10); obj=null; console.log(c); // 弱引用的类型不可以遍历","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://cooli-willson.github.io/tags/ECMAScript-6/"}]},{"title":"11.正则表达式基础","slug":"11.正则表达式基础","date":"2020-01-27T15:40:01.940Z","updated":"2020-01-27T15:58:35.411Z","comments":true,"path":"2020/01/27/11.正则表达式基础/","link":"","permalink":"https://cooli-willson.github.io/2020/01/27/11.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/","excerpt":"","text":"正则表达式基础 1234判断字符串是否符合规则var reg&#x3D;&#x2F;a&#x2F;g &#x2F;&#x2F;字面量创建var reg&#x3D;new RegExp(&quot;a&quot;,&quot;g&quot;);&#x2F;&#x2F;构造函数创建 正则中分为两个部分，一个是正则匹配内容，另一个是修饰符部分 修饰符 123i 不区分大小写g 全局 从头查到尾部m 匹配多行 reg.flag &amp;&amp; reg.source 123console.dir(reg);reg.flags 就是修饰符reg.source 就是正则匹配内容 reg.exex() 123reg.exex() &#x2F;&#x2F;查找字符串中满足正则匹配内容的结果，并且返回一个数组&#x2F;&#x2F;这个数组只有一个元素，包括几个属性，分别是群组，索引，字符串自身 reg.test() 12reg.test();&#x2F;&#x2F;判断字符串是否满足正则匹配内容 reg.exex() &amp;&amp; reg.test() 使用方法 12345678910111213var str&#x3D;&quot;abcd&quot;; if(str.indexOf(&quot;a&quot;)&gt;-1) &#123; console.log(&quot;aaa&quot;); &#125; if(&#x2F;a&#x2F;.test(str))&#123; &#x2F;&#x2F;字符串中是否有a console.log(&quot;bbb&quot;); &#125; var reg&#x3D;&#x2F;a&#x2F;g; console.log(reg.test(&quot;abc&quot;)); &#x2F;&#x2F;true console.log(reg.exec(&quot;abca&quot;)); &#x2F;&#x2F;满足结果，返回数组 字符串的方法 12345678str.search(); &#x2F;&#x2F;按照正则表达式查找字符串中的内容，返回有限查到的第一个元素的下标str.split();&#x2F;&#x2F;按照正则表达式匹配内容切割字符串str.replace();&#x2F;&#x2F;按照正则表达式匹配内容进行替换，可以替换成相同的也可以替换成不同的str.match()&#x2F;&#x2F;match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 str.search(); 1console.log(str.search(&#x2F;a&#x2F;)); &#x2F;&#x2F;返回找到的第一个字符串的下标 &#x2F;&#x2F;0 str.split() 12str.split(&quot;b&quot;) console.log(str.split(&#x2F;[cf]&#x2F;)); &#x2F;&#x2F;返回一个数组 返回值为将c || f作为分隔符，将原数组进行分割，得到的分割后的数组 str.replace(); 1234567891011121314151617181920212223242526272829303132333435363738var str&#x3D;&quot;abcdeafgh&quot;; str&#x3D;str.replace(&#x2F;a&#x2F;g,&quot;z&quot;); &#x2F;&#x2F;将字符串中的a替换为z console.log(str); str.replace(正则表达式,回调函数(item,index)&#123; return &#x2F;&#x2F;返回要替换的内容 &#125;) console.log(str&#x3D;str.replace(&#x2F;a&#x2F;g,function(item,index)&#123; return index&#x3D;&#x3D;&#x3D;0 ? &quot;x&quot; : &quot;y&quot;; &#x2F;&#x2F;替换时将下标为0的元素替换为x,将其他元素替换为y &#125;)); &#x2F;&#x2F; 查找所有匹配正则元素的下标 &#x2F;* var arr&#x3D;[]; str.replace(&#x2F;a&#x2F;g,function(item,index)&#123; arr.push(index); &#x2F;&#x2F;将符合条件的元素的下标添加到arr中 &#125;) console.log(arr); *&#x2F; &#x2F;&#x2F; 把任何满足正则内容的进行替换 &#x2F;&#x2F; str&#x3D;str.replace(&#x2F;[bdfh]&#x2F;g,&quot;0&quot;); &#x2F;&#x2F; console.log(str); &#x2F;&#x2F;查找元素并返回相应的值 var str&#x3D;&quot;abcabcadf&quot;; str&#x3D;str.replace(&#x2F;[abc]&#x2F;g,function(item)&#123; &#x2F;&#x2F;查找a 或者b 或者c switch(item)&#123; case &quot;a&quot;:return &quot;1&quot;; case &quot;b&quot;:return &quot;2&quot;; case &quot;c&quot;:return &quot;3&quot;; &#125; &#125;); console.log(str); &#x2F;&#x2F;1231231df str.match() 12345var str &#x3D; &quot;abcadef&quot;; console.log(str.match(&#x2F;a&#x2F;g)); &#x2F;&#x2F;如果不加全局,可以达到exec的目的 &#x2F;&#x2F; 如果加有全局匹配,就会只返回找到的所有元素数组 &#x2F;&#x2F; 如果加有群组,但是不加全局,则除返回找到的元素外,还返回群组的元素 元字符 网络参考资料 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123字符 描述\\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，&#39;n&#39; 匹配字符 &quot;n&quot;。&#39;\\n&#39; 匹配一个换行符。序列 &#39;\\\\&#39; 匹配 &quot;\\&quot; 而 &quot;\\(&quot; 则匹配 &quot;(&quot;。^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 &#39;\\n&#39; 或 &#39;\\r&#39; 之后的位置。$ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 &#39;\\n&#39; 或 &#39;\\r&#39; 之前的位置。* 匹配前面的子表达式零次或多次。例如，zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于&#123;0,&#125;。+ 匹配前面的子表达式一次或多次。例如，&#39;zo+&#39; 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 &#123;1,&#125;。? 匹配前面的子表达式零次或一次。例如，&quot;do(es)?&quot; 可以匹配 &quot;do&quot; 或 &quot;does&quot; 。? 等价于 &#123;0,1&#125;。&#123;n&#125; n 是一个非负整数。匹配确定的 n 次。例如，&#39;o&#123;2&#125;&#39; 不能匹配 &quot;Bob&quot; 中的 &#39;o&#39;，但是能匹配 &quot;food&quot; 中的两个 o。&#123;n,&#125; n 是一个非负整数。至少匹配n 次。例如，&#39;o&#123;2,&#125;&#39; 不能匹配 &quot;Bob&quot; 中的 &#39;o&#39;，但能匹配 &quot;foooood&quot; 中的所有 o。&#39;o&#123;1,&#125;&#39; 等价于 &#39;o+&#39;。&#39;o&#123;0,&#125;&#39; 则等价于 &#39;o*&#39;。&#123;n,m&#125; m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，&quot;o&#123;1,3&#125;&quot; 将匹配 &quot;fooooood&quot; 中的前三个 o。&#39;o&#123;0,1&#125;&#39; 等价于 &#39;o?&#39;。请注意在逗号和两个数之间不能有空格。? 当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 &quot;oooo&quot;，&#39;o+?&#39; 将匹配单个 &quot;o&quot;，而 &#39;o+&#39; 将匹配所有 &#39;o&#39;。. 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 &#39;\\n&#39; 在内的任何字符，请使用像&quot;(.|\\n)&quot;的模式。(pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 &#39;\\(&#39; 或 &#39;\\)&#39;。(?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 &quot;或&quot; 字符 (|) 来组合一个模式的各个部分是很有用。例如， &#39;industr(?:y|ies) 就是一个比 &#39;industry|industries&#39; 更简略的表达式。(?&#x3D;pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，&quot;Windows(?&#x3D;95|98|NT|2000)&quot;能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&quot;Windows(?!95|98|NT|2000)&quot;能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?&lt;&#x3D;pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，&quot;(?&lt;&#x3D;95|98|NT|2000)Windows&quot;能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;。(?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如&quot;(?&lt;!95|98|NT|2000)Windows&quot;能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;。x|y 匹配 x 或 y。例如，&#39;z|food&#39; 能匹配 &quot;z&quot; 或 &quot;food&quot;。&#39;(z|f)ood&#39; 则匹配 &quot;zood&quot; 或 &quot;food&quot;。[xyz] 字符集合。匹配所包含的任意一个字符。例如， &#39;[abc]&#39; 可以匹配 &quot;plain&quot; 中的 &#39;a&#39;。[^xyz] 负值字符集合。匹配未包含的任意字符。例如， &#39;[^abc]&#39; 可以匹配 &quot;plain&quot; 中的&#39;p&#39;、&#39;l&#39;、&#39;i&#39;、&#39;n&#39;。[a-z] 字符范围。匹配指定范围内的任意字符。例如，&#39;[a-z]&#39; 可以匹配 &#39;a&#39; 到 &#39;z&#39; 范围内的任意小写字母字符。[^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，&#39;[^a-z]&#39; 可以匹配任何不在 &#39;a&#39; 到 &#39;z&#39; 范围内的任意字符。\\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， &#39;er\\b&#39; 可以匹配&quot;never&quot; 中的 &#39;er&#39;，但不能匹配 &quot;verb&quot; 中的 &#39;er&#39;。\\B 匹配非单词边界。&#39;er\\B&#39; 能匹配 &quot;verb&quot; 中的 &#39;er&#39;，但不能匹配 &quot;never&quot; 中的 &#39;er&#39;。\\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &#39;c&#39; 字符。\\d 匹配一个数字字符。等价于 [0-9]。\\D 匹配一个非数字字符。等价于 [^0-9]。\\f 匹配一个换页符。等价于 \\x0c 和 \\cL。\\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。\\r 匹配一个回车符。等价于 \\x0d 和 \\cM。\\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\\t 匹配一个制表符。等价于 \\x09 和 \\cI。\\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\\w 匹配字母、数字、下划线。等价于&#39;[A-Za-z0-9_]&#39;。\\W 匹配非字母、数字、下划线。等价于 &#39;[^A-Za-z0-9_]&#39;。\\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，&#39;\\x41&#39; 匹配 &quot;A&quot;。&#39;\\x041&#39; 则等价于 &#39;\\x04&#39; &amp; &quot;1&quot;。正则表达式中可以使用 ASCII 编码。\\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，&#39;(.)\\1&#39; 匹配两个连续的相同字符。\\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。\\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 元字符 . 123456&#x2F;&#x2F;可以匹配任意一个字符console.log(&quot;cetcotcat&quot;.match(&#x2F;c.t&#x2F;g));console.log(&quot;cetc.tcat&quot;.match(&#x2F;c\\.t&#x2F;g));&#x2F;&#x2F; \\.转义为字符串. console.log(&quot;caaaaatcbbbbt&quot;.match(&#x2F;c....t&#x2F;g)); 元字符[ ] 12345678910111213console.log(&quot;cetcotcat&quot;.match(&#x2F;c[ae]t&#x2F;g));&#x2F;&#x2F;[]里面内容可以任意匹配一个字符&#x2F;&#x2F; &#x2F;[1-31]&#x2F; 1,2,3&#x2F;&#x2F; &#x2F;[0-9]&#x2F; 0,1,2,3,4,5,6,7,8,9&#x2F;&#x2F; &#x2F;[a-z]&#x2F; a,b,c,d,e,...z&#x2F;&#x2F; &#x2F;[A-Z]&#x2F; A,B,C,D.....Zconsole.log(&#x2F;[a-z]&#x2F;.test(&quot;abc&quot;));&#x2F;&#x2F;[a-z]可以匹配小写字母任意字符串console.log(&#x2F;[A-z]&#x2F;.test(&quot;ABC&quot;));&#x2F;&#x2F;[A-Z]可以匹配大写字母任意字符串console.log(&#x2F;[a-zA-Z]&#x2F;.test(&quot;ABC&quot;));&#x2F;&#x2F;[a-zA-Z]可以匹配任意大小写字母字符串console.log(&#x2F;a[b.c]b&#x2F;);&#x2F;&#x2F;[]中的.是任意字符.console.log(&#x2F;a[\\[\\]]b&#x2F;.test(&quot;a[b a]b&quot;))&#x2F;&#x2F;a[b a]b 写在[]里面[]字符必须转义 console.log(&#x2F;[aaaa]&#x2F;);&#x2F;&#x2F;[]中重复是无意义的 反义字符 ^ 1234反义字符类 在[]中第一位使用^,表示除了^后面的字符外都满足console.log(&quot;abcafcadcaec&quot;.match(&#x2F;a[^f]c&#x2F;g))&#x2F;&#x2F;中间不要fconsole.log(&quot;abcafcadcaec&quot;.match(&#x2F;a[f^a]c&#x2F;g))&#x2F;&#x2F;^如果在[]不是第一位,就表示字符^ 转义特殊字符 123456789101112&#x2F;&#x2F; 转义特殊字符&#x2F;&#x2F; [a-zA-Z0-9_] \\w&#x2F;&#x2F; [^a-zA-Z0-9_] \\W&#x2F;&#x2F; [0-9] \\d&#x2F;&#x2F; [^0-9] \\D&#x2F;&#x2F; \\s 空白字符&#x2F;&#x2F; \\S 非空白字符var str&#x3D;&quot; ac bg ed&quot;; &#x2F;&#x2F; str&#x3D;str.replace(&#x2F;\\s&#x2F;g,&quot;&quot;); &#x2F;&#x2F;将非空白字符替换成空字符串 &#x2F;&#x2F; str&#x3D;str.replace(&#x2F;\\S&#x2F;g,&quot;z&quot;); &#x2F;&#x2F;将空白字符替换成z console.log(str); 重复 123456789&#x2F;&#x2F; &#x2F;\\d\\d\\d\\d-\\d\\d-\\d\\d&#x2F;&#x2F;&#x2F; &#x2F;\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;&#x2F; &#x2F;&#x2F;日期重复表达式&#x2F;&#x2F; console.log(&quot;abcabc&quot;.match(&#x2F;(abc)&#123;2&#125;&#x2F;)); &#x2F;&#x2F;abc重复两次&#x2F;&#x2F; console.log(&quot;abcabc&quot;.match(&#x2F;abc&#123;2&#125;&#x2F;)); &#x2F;&#x2F;c重复两次&#x2F;&#x2F; &#x2F;a&#123;0&#125;&#x2F;; &#x2F;&#x2F;没有字符a,意味着匹配一个空字符 &#x2F;&#x2F; &#x2F;b&#123;0&#125;&#x2F;; 匹配一个空字符console.log(&quot;aaaaaa&quot;.match(&#x2F;a&#123;0&#125;&#x2F;g)); &#x2F;&#x2F;匹配7个空字符 贪婪匹配 1234console.log(&quot;aaaaaa&quot;.match(&#x2F;a&#123;3,4&#125;&#x2F;g));&#x2F;&#x2F;最大允许4，最小允许3次 &#x2F;&#x2F;贪婪匹配console.log(&quot;caaaaatcbbbbt&quot;.match(&#x2F;c.&#123;4,5&#125;t&#x2F;g)); &#x2F;&#x2F; 贪婪匹配 先匹配最大的 匹配应用 12345678console.log(&quot;aaaaaaaa&quot;.match(&#x2F;a&#123;2,4&#125;&#x2F;g)); &#x2F;&#x2F;匹配两次console.log(&quot;aaaaaabbb&quot;.match(&#x2F;a&#123;0,4&#125;&#x2F;g)); &#x2F;&#x2F;先匹配a再匹配空字符串var arr&#x3D;&quot;item and items and itemes&quot;.match(&#x2F;items&#123;0,1&#125;\\s&#x2F;g).map(function(item)&#123; &#x2F;&#x2F;s匹配0次或1次 return item.replace(&#x2F;\\s&#x2F;g,&quot;&quot;); &#x2F;&#x2F;？？？ &#125;) console.log(arr); 重复次数元字符 12345678910&#x2F;&#x2F; console.log(&quot;bbbabbbaaabbbbaabbb&quot;.match(&#x2F;a&#123;1,&#125;&#x2F;g)) &#x2F;&#x2F;重复一次或任意多次 &#x2F;&#x2F; console.log(&quot;bbbabbbaaabbbbaabbb&quot;.match(&#x2F;a&#123;0,&#125;&#x2F;g)) &#x2F;&#x2F;重复0次或任意多次 &#x2F;&#x2F; ? &#123;0,1&#125; &#x2F;&#x2F;0次或者1次 &#x2F;&#x2F; + &#123;1,&#125; &#x2F;&#x2F;1次或者多次 &#x2F;&#x2F; * &#123;0,&#125; &#x2F;&#x2F;o次或者任意次var arr&#x3D;&quot;item and items and itemes&quot;.match(&#x2F;items?\\s&#x2F;g).map(function(item)&#123; return item.replace(&#x2F;\\s&#x2F;g,&quot;&quot;); &#125;) console.log(arr); 非贪婪匹配 1234567891011121314&#x2F;&#x2F; &#x2F;.*?&#x2F; &#x2F;&#x2F;非贪婪匹配console.log(&quot;aaaaaaaa&quot;.match(&#x2F;a&#123;2,5&#125;?&#x2F;g)); &#x2F;&#x2F;匹配最少次数console.log(&quot;aaaaaaaa&quot;.match(&#x2F;a&#123;2&#125;&#x2F;g));console.log(&quot;caaaaatcbbbbt&quot;.match(&#x2F;c.*?t&#x2F;g)); &#x2F;&#x2F;匹配最少次数多少都可以var obj&#x3D;&#123; a:1, b:2, cd:10, efg:11 &#125; console.log(JSON.stringify(obj)); var str&#x3D;JSON.stringify(obj); console.log(str.match(&#x2F;&quot;.+?&quot;&#x2F;g)); &#x2F;&#x2F;匹配所有字符串最少次数 ？？？ 替换标签 12345var str&#x3D;&quot;&lt;div&gt;def&lt;span&gt;ghi&lt;span&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;a href&#x3D;&#39;#&#39;&gt;abc&lt;&#x2F;div&gt;&quot; str&#x3D;str.replace(&#x2F;&lt;\\&#x2F;?.+?&gt;&#x2F;g,function(item)&#123; &#x2F;&#x2F;查找所有带有&#x2F;和不带&#x2F;的所有标签 return &#x2F;\\&#x2F;&#x2F;.test(item)? &quot;&lt;&#x2F;p&gt;&quot; : &quot;&lt;p&gt;&quot;; &#x2F;&#x2F;将有&#x2F;的标签字符串替换成&lt;&#x2F;p&gt; 将没有&#x2F;的标签字符串替换成&lt;p&gt; &#125;); console.log(str); 或者 ，起始结束，群组 或者 123456789console.log(&quot;catdogcetdag&quot;.match(&#x2F;[catdog]&#x2F;)) &#x2F;&#x2F;只要有任意一个字符相同就可匹配console.log(&quot;catdogcetdag&quot;.match(&#x2F;cat|dog&#x2F;));&#x2F;&#x2F;或者,可以用来匹配多个字符或者另外得字符console.log(&quot;abcd&quot;.match(&#x2F;c|b&#x2F;)); &#x2F;&#x2F;先匹配符合条件的那一个console.log(&quot;abcd&quot;.match(&#x2F;[cb]&#x2F;));&#x2F;&#x2F;先匹配符合条件的那一个&#x2F;&#x2F; console.log(&quot;abcdef&quot;.match(&#x2F;|a|b&#x2F;g));&#x2F;&#x2F;如果|得一端没有内容,则认为匹配空字符&#x2F;&#x2F; console.log(&quot;abcdef&quot;.match(&#x2F;a||b&#x2F;g));&#x2F;&#x2F;如果|得一端没有内容,则认为匹配空字符&#x2F;&#x2F; console.log(&quot;abcdef&quot;.match(&#x2F;a|d|&#x2F;g));&#x2F;&#x2F;如果|得一端没有内容,则认为匹配空字符 起始结束 12345678910111213141516171819202122232425262728&#x2F;&#x2F; ^起始 $结束 ^在[]中表示反义 var input,span; init(); function init()&#123; input&#x3D;document.querySelector(&quot;input&quot;); span&#x3D;document.querySelector(&quot;span&quot;); input.addEventListener(&quot;input&quot;,inputHandler); &#x2F;&#x2F;给input添加监听事件 &#125; function inputHandler(e)&#123; if(this.ids) return; this.ids&#x3D;setTimeout(function(input)&#123; clearTimeout(input.ids); &#x2F;&#x2F;清除事件 input.ids&#x3D;false; &#x2F;&#x2F;将ids设为false testInputValue(input.value); &#x2F;&#x2F;将输入的值作为参数进行函数操作 &#125;,500,this); &#x2F;&#x2F;定时器的重复时间为500毫秒 &#x2F;&#x2F;防抖 &#125; function testInputValue(txt)&#123; console.log(txt.match(&#x2F;^[1-9]$|^[1-9][0-9]$|^[1-9][1-4][0-9]$|^[1-9][1-5]0$&#x2F;)) &#x2F;&#x2F;匹配1-150 if(&#x2F;^[1-9]$|^[1-9][0-9]$|^[1-9][1-4][0-9]$|^[1-9][1-5]0$&#x2F;.test(txt))&#123; span.textContent&#x3D;&quot;输入正确&quot;; span.style.color&#x3D;&quot;green&quot;; &#125;else&#123; span.textContent&#x3D;&quot;输入错误&quot;; span.style.color&#x3D;&quot;red&quot;; &#125; &#125; 群组 12345678910&#x2F;&#x2F; 群组 &#x2F;&#x2F; &quot;18617891076&quot;.replace(&#x2F;&#x2F;) &#x2F;&#x2F; console.log(&quot;18617891076&quot;.match(&#x2F;(\\d&#123;3&#125;)(\\d&#123;4&#125;)(\\d&#123;4&#125;)&#x2F;)) &#x2F;&#x2F;将匹配到的条件进行分组 var str&#x3D;&quot;18617891076&quot;.match(&#x2F;(\\d&#123;3&#125;)(\\d&#123;4&#125;)(\\d&#123;4&#125;)&#x2F;).slice(1).reduce(function(value,item,index)&#123; &#x2F;&#x2F;从下标 return index&#x3D;&#x3D;&#x3D;1 ? value+&quot;****&quot; : value+item; &#125;) console.log(str); &#x2F;&#x2F; $1就是第一个群组,$2就是第二个群组,$3就是第三个群组 var str&#x3D;&quot;18617891076&quot;.replace(&#x2F;(\\d&#123;3&#125;)(\\d&#123;4&#125;)(\\d&#123;4&#125;)&#x2F;,&quot;$1****$3&quot;); console.log(str); 正则表达式的先行断言及后行断言 123456一共分为四种- (?&#x3D;a) 零宽正向先行断言- (?!a)零宽负向先行断言- (?&lt;&#x3D;a)零宽正向后行断言- (?&lt;!a)零宽负向后行断言 (?=a) 零宽正向先行断言 12345678910111213该正则匹配某字符前面的位置。let reg &#x3D; &#x2F;(?&#x3D;o)&#x2F;glet str &#x3D; &#39;hello world&#39;let s &#x3D; str.replace(reg,&#39;A&#39;)console.log(s) &#x2F;&#x2F;输出hellAo wAorld&#x2F;&#x2F;经过上面的代码可以看到，A匹配到了o前面的位置let reg &#x3D; &#x2F;l(?&#x3D;o)&#x2F;glet str &#x3D; &#39;hello world&#39;let s &#x3D; str.replace(reg,&#39;A&#39;)console.log(s) &#x2F;&#x2F;输出helAo world&#x2F;&#x2F;该正则匹配后面紧跟o的l字符，只有第二个l满足该条件，所以被替换 (?!a)零宽负向先行断言 1234567891011121314与上面的(?!a)相反，这个表达式匹配后面没有a字符的位置let reg &#x3D; &#x2F;(?!l)&#x2F;glet str &#x3D; &#39;hello&#39;let s &#x3D; str.replace(reg,&#39;A&#39;)console.log(s) &#x2F;&#x2F;输出AhAellAoA该正则匹配后面没有字符l的位置，因此除了两个l字母前，均插入了A字符let reg &#x3D; &#x2F;l(?!o)&#x2F;glet str &#x3D; &#39;hello&#39;let s &#x3D; str.replace(reg,&#39;A&#39;)console.log(s) &#x2F;&#x2F;输出heAlo该正则表示匹配后面无o字符的l字符，因为只有第一个l后面没有o，因此被替换 断言的不同使用方法注释理解 12345678910111213141516console.log(&quot;abcdadef&quot;.match(&#x2F;a(?&#x3D;d)&#x2F;g)) console.log(&quot;a0bcd adef a&amp;cd&quot;.replace(&#x2F;a(?&#x3D;d)&#x2F;g,&quot;0&quot;)); &#x2F;&#x2F;匹配所有a前面的位置是否是a如果是a则将其替换成0 console.log(&quot;a0bcd adef a&amp;cd&quot;.replace(&#x2F;a(?&#x3D;[a-z])|a(?&#x3D;[0-9])&#x2F;g,&quot;1&quot;));&#x2F;&#x2F;匹配所有小写字母和数字之前的位置是否为a,有的话将其换成1; console.log(&quot;a0bc adef a&amp;bc&quot;.replace(&#x2F;a(?![a-z])&#x2F;g,&quot;1&quot;));&#x2F;&#x2F;相当于不等于 匹配所有非小写字母且前面有a的将a替换成1 console.log(&quot;a0bc adef a&amp;bc&quot;.match(&#x2F;(?&lt;&#x3D;[0-9])b&#x2F;g)) console.log(&quot;a0bc adef a&amp;bc&quot;.replace(&#x2F;(?&lt;&#x3D;[0-9])b&#x2F;g,&quot;1&quot;));&#x2F;&#x2F;前置条件 &#x2F;&#x2F;匹配所有数字后面有b的，符合条件则将b替换成1 console.log(&quot;a0bc adef a&amp;bc&quot;.replace(&#x2F;(?&lt;![0-9])b&#x2F;g,&quot;1&quot;));&#x2F;&#x2F;前置条件不等于 &#x2F;&#x2F;匹配所有非数字后面有b的，符合条件则将b替换成1 console.log(&quot;abacd234&quot;.match(&#x2F;^(?&#x3D;.*[a-z])(?&#x3D;.*[0-9])\\w+$&#x2F;)); console.log(&quot;你好&quot;.match(&#x2F;[\\u4e00-\\u9fd5]+&#x2F;g));&#x2F;&#x2F;中文 console.log(&quot;xietian@163.com&quot;.match(&#x2F;^\\w+@\\w&#123;2,&#125;\\.(com|net)$&#x2F;)); &#x2F;&#x2F;判断邮箱符合条件 @前有任意字符后至少有2到任意多个字符 .后面为com或者net &#x2F;&#x2F; &#x2F;^1[3-9]\\d&#123;9&#125;$&#x2F; 添加类名操作注释理解 12345678910111213&lt;div class&#x3D;&quot; div1 div3 div2 &quot;&gt;&lt;&#x2F;div&gt;var div &#x3D;document.querySelector(&quot;div&quot;); function addClass(elem,className)&#123; var arr&#x3D;(elem.className+&quot; &quot;+className).match(&#x2F;\\S+&#x2F;g); &#x2F;&#x2F;将匹配为任意次数的非空字符的类名作为match的返回值储存到arr中 console.log(arr); arr&#x3D;arr.filter(function(item,index,arr)&#123; &#x2F;&#x2F;这里的arr参数是当前元素属于的数组对象 return arr.indexOf(item,index+1)&lt;0; &#x2F;&#x2F;检索数组下的当前元素与当前元素之后的元素相对比若没有相同就返回 &#125;); elem.className&#x3D;arr.join(&quot; &quot;); &#x2F;&#x2F;用空字符将每个类名相连接 &#125; addClass(div,&quot;div4&quot;); console.log(div); 删除类名操作注释理解 123456789101112131415&lt;div class&#x3D;&quot; div1 div3 div2 &quot;&gt;&lt;&#x2F;div&gt; function removeClass(elem,className)&#123; var arr&#x3D;elem.className.match(&#x2F;\\S+&#x2F;g); &#x2F;&#x2F;将原本类名的值做一个非空判断并将match返回的值储存到数组中 var arr1&#x3D;className.match(&#x2F;\\S+&#x2F;g); &#x2F;&#x2F;传入类名存储到数组中 arr1.forEach(function(item)&#123; arr&#x3D;arr.filter(function(t)&#123; return t!&#x3D;&#x3D;item; &#x2F;&#x2F;传入第二个参数与之前的每一个类名相匹配 不相同的就返回到原数组，相同就不返回原数组 达到查重删除的效果是吧 &#125;); &#125;); elem.className&#x3D;arr.join(&quot; &quot;); &#x2F;&#x2F;将每个类名通过空字符进行连接 &#125; var div&#x3D;document.querySelector(&quot;div&quot;); removeClass(div,&quot; div2&quot;); trim(); 1去除字符串的头尾空格 重写tirm（） 123456 var str&#x3D;&quot; sad asads &quot;; function trim(str)&#123; &#x2F;&#x2F;去除字符串的头尾空格 return str.match(&#x2F;^\\s*(.*?)\\s*$&#x2F;)[1]; &#x2F;&#x2F;去租没加全局变量 返回的数组下标为0的是群组内容 下标为1的是匹配内容 &#125; console.log(trim(str));","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"正则表达式基础","slug":"正则表达式基础","permalink":"https://cooli-willson.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/"}]},{"title":"10.Event事件","slug":"10.Event事件","date":"2020-01-27T09:44:31.705Z","updated":"2020-01-27T09:47:30.248Z","comments":true,"path":"2020/01/27/10.Event事件/","link":"","permalink":"https://cooli-willson.github.io/2020/01/27/10.Event%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"Event事件 Event事件类型 change 修改事件 error 错误事件 load 加载事件 reset 重设事件 resize 重新修改大小事件 select 选择文字事件 submit 提交事件 unload 卸载事件 scroll 滚动条事件 鼠标事件 MouseEvent–&gt;UIEvent–&gt;Event Event称为事件基类 123456document.addEventListener(\"click\",clickHandler); //dom的click 监听事件 function clickHandler(e)&#123; //事件函数 console.log(e); //这里的e相当于document &#125; var evt=new InputEvent(\"click\"); document.dispatchEvent(evt); //发布后的e为evt change change是修改事件，主要用于表单元素，当表单元素被修改时，失去焦点收到事件 123456789101112131415var user=document.getElementById(\"user\"); var man=document.getElementById(\"man\"); var city=document.getElementById(\"city\"); city.addEventListener(\"change\",changeHandler); //给city添加change事件 function changeHandler(e)&#123; console.log(e.currentTarget===this); console.log(e.target);//目标元素 可视元素 console.log(this.selectedOptions); //打印当前下下拉选项 city.selectedIndex //下拉菜单被选的索引 city.selectedOptions //下拉菜单中被选的option标签列表 var selectStr=Array.from(this.selectedOptions).reduce(function(value,item)&#123; //将所选取的元素转换为数组进行归并存放到selectStr中 return value+(value.length===0 ? \"\" :\",\")+item.textContent; //长度为0时加空字符串，不为0时加，将元素通过字符串的形式打印 &#125;,\"\"); console.log(selectStr); &#125; submit &amp;&amp; reset submit &amp;&amp; reset 是表单事件，只能作用于表单的事件类型 12345678910111213141516var form=document.querySelector(\"form\"); var city=document.getElementById(\"city\"); var citySelect=document.getElementById(\"citySelect\"); // 提交表单和重置表单 form.addEventListener(\"submit\",submitHandler); form.addEventListener(\"reset\",submitHandler); function submitHandler(e)&#123; var selectStr=Array.from(city.selectedOptions).reduce(function(value,item)&#123; return value+(value.length===0 ? \"\" :\",\")+item.textContent; &#125;,\"\"); // 隐藏的文本在这里设置value,提交submit时,没有name的表单不会被提交 citySelect.value=selectStr; console.log(selectStr); // e.preventDefault(); // console.log(e.type); &#125; resize resize 重设大小主要针对window的事件 窗口被改变大小值，事件被触发 12345window.addEventListener(\"resize\",resizeHandler); function resizeHandler(e)&#123; var scale=document.documentElement.clientWidth/screen.width; document.documentElement.style.fontSize=100*scale+\"px\"; &#125; select select 文本选择事件 主要针对于input或者textArea中文本选择 与下拉菜单没有关系，主要是选择文本框中的文本内容时被触发 123456789var user=document.getElementById(\"user\"); user.addEventListener(\"select\",selectHandler); function selectHandler(e)&#123; // user.selectionStart // user.selectionEnd // user.selectionDirection // console.log(user.selectionStart,user.selectionEnd, user.selectionDirection) user.value=user.value.slice(0,user.selectionStart)+user.value.slice(user.selectionStart,user.selectionEnd).toUpperCase()+user.value.slice(user.selectionEnd) &#125; Event事件之加载和滚动条 scroll scroll 滚动事件 是所有具备滚动条的容器都可以侦听的 滚轮滚动不是滚动条事件触发方式，间接触发滚动条事件 滚动条位置的改变才会触发滚动条事件 123456div.addEventListener(\"scroll\",scrollHandler); function scrollHandler(e)&#123; e.stopPropagation();//如果要设置flash中的滚动条不改变外部的滚动条 // 需要在flash的标签上设置停止冒泡 &#125; unload unload 卸载 原有的页面在刷新，原有的页面会被卸载掉，这个时候触发事件 unload 事件本身也不靠谱 关闭浏览器标签时被触发，关闭浏览器窗口时不被触发 123456789101112document.addEventListener(\"click\",clickHandler); function clickHandler(e)&#123; location.href=\"http://www.163.com\"; // location.assign(\"http://www.163.com\"); // location.replace(\"http://www.163.com\"); &#125; window.addEventListener(\"unload\",unloadHandler); function unloadHandler(e)&#123; e.preventDefault(); // console.log(e); open(\"http://www.qq.com\"); &#125; load error load 加载事件 error 错误，比如地址错误造成的加载失败会触发 为什么加载图片 图片是以个异步加载的过程 给window增加load事件，页面中所有的元素被加载完成后触发该事件 所有的元素都加载完成，包括图片 1234window.onload=function()&#123; var img=document.querySelector(\"img\"); console.log(img.width); &#125; 1234567891011121314151617181920212223init(); function init() &#123; var arr = []; for (var i = 2; i &lt; 80; i++) &#123; //从第2张开始到第79张 var img = new Image(); //声明一个图片对象 img.src = \"./img/\" + i + \"-.jpg\"; //设置图片的地址 img.onload = function () &#123; //当图片都加载完时执行此函数 arr.push(this); //将当前遍历到的图片存放到arr数组中 if (arr.length &gt;= 78) &#123; //当所有图片都加载完时 执行load函数 loadFinish(arr); &#125; document.body.appendChild(img); //将图片添加到body中 &#125; &#125; console.log(\"bbb\"); //先执行此条语句，因为img.onload没有加载完成 &#125; function loadFinish(arr) &#123; arr.forEach(function(item)&#123; console.log(item.src); //打印当前图片的地址 &#125;) &#125; 图片加载1 12345678910111213141516171819202122232425262728var num=2,arr=[]; init(); function init()&#123; var img=new Image(); img.src=\"./img/\"+num+\"-.jpg\"; img.addEventListener(\"load\",loadHanlder); &#125; function loadHanlder(e)&#123; arr.push(this); //将当前元素储存到arr中 num++; if(num&gt;79)&#123; //循环79次 loadFinish(arr); //执行加载完成函数 return; &#125; var img=new Image(); //新建一个图片对象 img.src=\"./img/\"+num+\"-.jpg\"; //路径地址 img.addEventListener(\"load\",loadHanlder) //给img创建一个加载监听事件 img.addEventListener(\"error\",errorHanlder); document.body.appendChild(img); //将img添加到body中 &#125; function errorHanlder(e)&#123; console.log(e); &#125; function loadFinish(arr)&#123; arr.forEach(function(item)&#123; //循环所有数组中的元素 console.log(item.src); //打印所有元素地址 &#125;) &#125; 图片加载2 1234567891011121314151617181920212223242526var num=2,arr=[] init(); function init()&#123; var img=new Image(); //创建一个img对象 img.addEventListener(\"load\",loadHandler); //给img添加一个加载监听事件 //每次加载完一个图片都会再次调用此事件 img.src=\"./img/\"+num+\"-.jpg\"; //设置图片地址 function loadHandler(e)&#123; // 把当时加载图片复制一份放在数组中,这个复制的图片就是当时这个地址的图片 arr.push(this.cloneNode(false)); //复制当前img节点push到arr数组中 num++; if(num&gt;79)&#123; this.removeEventListener(\"load\",loadHandler); //当循环次数大于79时移除此事件 loadFinish(arr); //并加载此函数 return; &#125; this.src=\"./img/\"+num+\"-.jpg\"; &#125; &#125; function loadFinish(arr)&#123; arr.forEach(function(item)&#123; console.log(item.src); &#125;) &#125; 图片的预加载封装 工具类部分 1234567891011121314151617181920212223242526272829303132333435363738 loadImage:function(arr,callback,basePath)&#123; //第一个参数为图片名数组 第二个参数为执行函数 第三个参数为路径地址 if(typeof basePath===\"string\")&#123; arr=arr.map(function(item)&#123; return basePath+item; //遍历当前数组并给每个元素添加路径名 成为一个完整的图片路径 &#125;) &#125; var img=new Image(); //声明一个图片对象 img.addEventListener(\"load\",this.loadHandler); //给图片添加加载事件 img.addEventListener(\"error\",this.loadHandler); //给图片添加错误事件 img.resultArr=[]; img.num=0; img.arr=arr; img.self=this; img.callback=callback; img.src=arr[0]; &#125;, loadHandler:function(e)&#123; if(e.type!==\"error\")this.resultArr.push(this.cloneNode(false)); //若不出现错误 将此节点元素浅复制给数组 this.num++; if(this.num&gt;this.arr.length-1)&#123; //循环数组的长度 this.removeEventListener(\"load\",this.self.loadHandler); //移除监听函数 if(this.callback)&#123; this.callback(this.resultArr.slice()); &#125;else&#123; var evt=new Event(\"Load_image_Finish\"); evt.resultArr=this.resultArr; document.dispatchEvent(evt); &#125; this.resultArr=null; this.self=null; this.callback=null; this.arr=null; return; &#125; this.src=this.arr[this.num]; &#125; &#125;&#125;)(); html的js部分 12345678910111213141516 var arr=[]; for(var i=2;i&lt;80;i++)&#123; arr.push(i+\"-.jpg\"); &#125; // 函数的参数 // 必须填写的写在前面,不是必须填写的写在后面 // document.addEventListener(\"Load_image_Finish\",finishHandler) Utils.loadImage(arr,finishImage,\"./img/\");/* function finishHandler(e)&#123; console.log(e.resultArr); &#125; */ function finishImage(arr)&#123; console.log(arr); &#125; 聚焦与input事件 FocusEvent事件 FocusEvent事件 获得焦距和失去焦距 主要针对所有表单元素和超链接 focusin focusout 12345678910var user=document.getElementById(\"user\"); var user1=document.getElementById(\"user1\"); // 获得焦距 user.addEventListener(\"focusin\",focusHandler); // 失去焦距 user.addEventListener(\"focusout\",focusHandler); function focusHandler(e)&#123; // e.relatedTarget 上一个失焦对象 console.log(e); &#125; InputEvent 输入事件 123456789101112131415var user=document.getElementById(\"user\"); user.addEventListener(\"input\",inputHandler); function inputHandler(e)&#123; console.log(e); //每输入新的内容控制台都会打印 // e.data: \"s\" 本次输入的内容 // e.isComposing: false 输入法是否启动 // e.inputType 输入的类型 // insertCompositionText 输入插入 // historyUndo 历史返回 // insertText 插入文本 // deleteContentBackward 退格删除（删除前一个） // deleteContentForward delete删除（删除后一个） // deleteByCut 剪切删除 // insertFromPaste 粘贴插入 &#125; 节流 123456789101112131415161718192021init();function init()&#123; var user=document.getElementById(\"user\"); //获取user元素（input） user.addEventListener(\"input\",inputHandler); //给user添加input事件 &#125;function inputHandler(e)&#123; // this 节流 if(this.ids) return; this.ids=setTimeout(function(elem)&#123; clearTimeout(elem.ids); elem.ids=null; showValue(elem.value); &#125;,500,this);&#125;function showValue(txt)&#123; console.log(txt);&#125; 按键事件(防抖） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* document.addEventListener(\"keydown\",keyHandler); document.addEventListener(\"keyup\",keyHandler); var type=\"\"; function keyHandler(e)&#123; if(type===e.type)return; type=e.type; // code: \"KeyS\" 按下的键 // key: \"a\" 按下的键 // keyCode: 16 键码 // 左37 上38 右39 下40 // which: 65 等同于keyCode console.log(e); &#125; */ var hero, type = 100; var x = 0, y = 0, num = 0, time = 0,speed=1; init(); function init() &#123; hero = document.querySelector(\"div\"); //获取div元素命名为hero document.addEventListener(\"keydown\", keyHandler); //添加按键按下监听事件 document.addEventListener(\"keyup\", keyHandler); //添加按键抬起监听事件 setInterval(animation, 16); //设置定时器 &#125; function keyHandler(e) &#123; if (e.type === \"keydown\")&#123; //当按键按下时 type = e.keyCode; //将当前按键的keycode储存在type中 &#125; else if (e.type === \"keyup\")&#123; //当按键抬起时 type = 100; //不做任何操作 hero.style.backgroundPositionX=\"0px\"; //背景图x轴定位为0 num=0; return; &#125; switch (e.keyCode) &#123; //将keycode码设为开关 case 37: hero.style.backgroundPositionY = \"-33px\"; //通过keycode判断背景图y轴的位置 break; case 38: hero.style.backgroundPositionY = \"-99px\"; break; case 39: hero.style.backgroundPositionY = \"-66px\"; break; case 40: hero.style.backgroundPositionY = \"0px\"; break; &#125; &#125; function animation() &#123; //执行操作函数 if (type &lt; 37 || type &gt; 40) return; //判断keycode的数值 heroMove(); //调用移动方法 changeSkin(); //皮肤切换函数 &#125; // 防抖 function changeSkin() &#123; time--; if (time &gt; 0) return; //每次15次返回一次 time = 15; if (++num &gt; 3) num = 0; hero.style.backgroundPositionX = -32 * num + \"px\"; //切换行走时的皮肤 &#125; function heroMove() &#123; switch (type) &#123; case 37: x -= speed; break; case 38: y -= speed; break; case 39: x += speed; break; case 40: y += speed; break; &#125; hero.style.left = x + \"px\"; //左右移动时每次移动的像素 hero.style.top = y + \"px\"; //上下移动时每次移动的像素 &#125; 滚轮事件 12345678910111213141516171819 document.addEventListener(\"DOMMouseScroll\",mouseHandler); document.addEventListener(\"mousewheel\",mouseHandler); var div=document.querySelector(\"div\"); function mouseHandler(e)&#123; var detail; if(e.detail!==0)detail=e.detail; else detail=e.deltaY&lt;0 ? -3 : 3; // console.log(detail); div.style.top=div.offsetTop+detail+\"px\"; // e.detail: -3 向上 火狐/* deltaX: -0 deltaY: -125 deltaZ: 0 detail: 0 wheelDelta: 150 wheelDeltaX: 0 wheelDeltaY: 150 */ &#125;","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"Event事件","slug":"Event事件","permalink":"https://cooli-willson.github.io/tags/Event%E4%BA%8B%E4%BB%B6/"}]},{"title":"拖拽div","slug":"拖拽功能","date":"2020-01-27T08:10:52.536Z","updated":"2020-01-27T08:13:56.527Z","comments":true,"path":"2020/01/27/拖拽功能/","link":"","permalink":"https://cooli-willson.github.io/2020/01/27/%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD/","excerpt":"","text":"123456789101112131415161718192021222324.div1 &#123; width: 50px; height: 50px; background-color: red; position: absolute; &#125; .div0 &#123; width: 600px; height: 600px; border: 1px solid #000000; position: relative; left: 100px; top: 100px; &#125; .divs &#123; width: 800px; height: 800px; border: 1px solid #FF0000; position: relative; left: 100px; top: 100px; &#125; 12345678910&lt;div class=\"divs\"&gt; &lt;div class=\"div0\"&gt; &lt;div class=\"div1\"&gt;&lt;/div&gt; &lt;div class=\"div1\"&gt;&lt;/div&gt; &lt;div class=\"div1\"&gt;&lt;/div&gt; &lt;div class=\"div1\"&gt;&lt;/div&gt; &lt;div class=\"div1\"&gt;&lt;/div&gt; &lt;div class=\"div1\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 12345678910111213141516171819202122232425262728293031var divs = document.querySelectorAll(\".div1\");for (var i = 0; i &lt; divs.length; i++) &#123; divs[i].addEventListener(\"mousedown\", mouseHandler); &#125; function mouseHandler(e) &#123; switch (e.type) &#123; case \"mousedown\": e.preventDefault(); document.elem = this; document.x = e.offsetX; document.y = e.offsetY; document.addEventListener(\"mousemove\", mouseHandler); document.addEventListener(\"mouseup\", mouseHandler); break; case \"mousemove\": var rect = this.elem.parentElement.getBoundingClientRect(); this.elem.style.left = e.clientX - rect.x - this.x + \"px\"; this.elem.style.top = e.clientY - rect.y - this.y + \"px\"; if(this.elem.offsetLeft&lt;0) this.elem.style.left=\"0px\"; if(this.elem.offsetTop&lt;0) this.elem.style.top=\"0px\"; if(this.elem.offsetLeft&gt;rect.width-this.elem.offsetWidth)this.elem.style.left=rect.width-this.elem.offsetWidth+\"px\"; if(this.elem.offsetTop&gt;rect.height-this.elem.offsetHeight)this.elem.style.top=rect.height-this.elem.offsetHeight+\"px\"; break; case \"mouseup\": this.removeEventListener(\"mousemove\", mouseHandler); this.removeEventListener(\"mouseup\", mouseHandler); break; &#125; &#125;","categories":[{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/categories/%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/tags/%E5%8A%9F%E8%83%BD/"},{"name":"拖拽","slug":"拖拽","permalink":"https://cooli-willson.github.io/tags/%E6%8B%96%E6%8B%BD/"}]},{"title":"div的多选功能的实现","slug":"实现div的多选功能","date":"2020-01-27T07:57:30.333Z","updated":"2020-01-27T07:59:58.819Z","comments":true,"path":"2020/01/27/实现div的多选功能/","link":"","permalink":"https://cooli-willson.github.io/2020/01/27/%E5%AE%9E%E7%8E%B0div%E7%9A%84%E5%A4%9A%E9%80%89%E5%8A%9F%E8%83%BD/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* var pre; init(); function init()&#123; var con=document.createDocumentFragment(); for(var i=0;i&lt;10;i++)&#123; var div=document.createElement(\"div\"); Object.assign(div.style,&#123; width:\"50px\", height:\"50px\", backgroundColor:(function()&#123; var col=\"#\"; for(var j=0;j&lt;6;j++)&#123; col+=Math.floor(Math.random()*16).toString(16); &#125; return col; &#125;)(), position:\"absolute\", left:Math.floor(Math.random()*1400)+\"px\", top:Math.floor(Math.random()*550)+\"px\" &#125;); con.appendChild(div); div.addEventListener(\"click\",clickHandler); &#125; document.body.appendChild(con); &#125; function clickHandler(e)&#123; if(this===pre) preChange(); else preChange(this); &#125; function preChange(elem)&#123; if(pre)pre.style.border=\"none\"; pre=null; if(!elem) return; pre=elem; pre.style.border=\"2px solid #000000\" &#125; */ var preList=[]; init(); function init()&#123; var con=document.createDocumentFragment(); for(var i=0;i&lt;10;i++)&#123; var div=document.createElement(\"div\"); Object.assign(div.style,&#123; width:\"50px\", height:\"50px\", backgroundColor:(function()&#123; var col=\"#\"; for(var j=0;j&lt;6;j++)&#123; col+=Math.floor(Math.random()*16).toString(16); &#125; return col; &#125;)(), position:\"absolute\", left:Math.floor(Math.random()*1400)+\"px\", top:Math.floor(Math.random()*550)+\"px\" &#125;); con.appendChild(div); div.addEventListener(\"click\",clickHandler); &#125; document.body.appendChild(con); &#125; function clickHandler(e)&#123; preChange(this,e.ctrlKey); &#125; function preChange(elem,bool)&#123; if(preList.length&gt;0 &amp;&amp; !bool)&#123; preList.forEach(function(item)&#123; item.style.border=\"none\"; &#125;) preList.length=0; &#125; preList.push(elem); elem.style.border=\"2px solid #000000\" &#125;","categories":[{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/categories/%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/tags/%E5%8A%9F%E8%83%BD/"},{"name":"事件","slug":"事件","permalink":"https://cooli-willson.github.io/tags/%E4%BA%8B%E4%BB%B6/"}]},{"title":"9.事件","slug":"9.事件","date":"2020-01-27T07:42:18.319Z","updated":"2020-01-27T07:45:54.620Z","comments":true,"path":"2020/01/27/9.事件/","link":"","permalink":"https://cooli-willson.github.io/2020/01/27/9.%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"派发和侦听事件 addEventListener(); //事件侦听方法，仅用于EventTarget对象 dispatchEvent(); //派发发事件方法，派发事件，仅用于EventTarget对象 1、侦听和派发的对象是同一个，2、侦听和派发的事件类型完全相同 EventTarget 叫 事件目标对象，Event实例的对象叫 事件对象 123456789var target&#x3D;new EventTarget();&#x2F;&#x2F;侦听和派发的对象可以是DOM元素，也可以是EventTarget，或者继承EventTarget的类 target.addEventListener(&quot;chilema&quot;,clickHandler); &#x2F;&#x2F;创建chileme侦听事件 var evt&#x3D;new Event(&quot;chilema&quot;);&#x2F;&#x2F;创建chileme事件对象 evt.num&#x3D;10; target.dispatchEvent(evt);&#x2F;&#x2F;派发事件 &#x2F;&#x2F; 事件侦听回调函数，不能传参,因此事件回调函数中有且仅有一个参数,这个参数即为事件对象 function clickHandler(e)&#123; console.log(e.type);&#x2F;&#x2F;派发的事件类型 &#125; 侦听与派发 123456789101112131415161718192021222324252627282930313233343536373839var obj&#x3D;&#123; _a:1, a:function()&#123; &#x2F;&#x2F; obj1.a(this._a); &#125;, b:function()&#123; var evt&#x3D;new Event(&quot;abc&quot;); &#x2F;&#x2F;evt类型为abc evt.a&#x3D;this._a; &#x2F;&#x2F;将obj的_a属性赋值给evt对象 document.dispatchEvent(evt); &#x2F;&#x2F;派发evt事件对象 console.log(evt); &#125; &#125; obj.b(); var obj1&#x3D;&#123; _a:2, a:function(arg)&#123; &#x2F;&#x2F; console.log(arg); &#125;, b:function()&#123; document.addEventListener(&quot;abc&quot;,this.c); &#x2F;&#x2F;侦听abc事件 调用c方法 &#125;, c:function(e)&#123; console.log(e.a); &#x2F;&#x2F;打印evt.a &#x3D;&#x3D;&#x3D;1 &#125; &#125; var obj2&#x3D;&#123; a:function()&#123; document.addEventListener(&quot;abc&quot;,this.b); &#x2F;&#x2F;侦听abc事件 调用b方法 &#125;, b:function(e)&#123; console.log(e.a); &#x2F;&#x2F;打印evt.a &#x3D;&#x3D;&#x3D;1 &#125; &#125; obj1.b(); obj2.a(); obj.b(); 高内聚低耦合 12345678910111213141516171819202122232425var obj&#x3D;&#123; a:function()&#123; document.addEventListener(&quot;b&quot;,this.b); &#x2F;&#x2F;侦听b事件 调用b方法 &#125;, b:function(e)&#123; var num&#x3D;e.num+10; &#x2F;&#x2F; num&#x3D;evt.num+10; var evt&#x3D;new Event(&quot;a&quot;); &#x2F;&#x2F;创建事件对象 对象类型为 a evt.num&#x3D;num; &#x2F;&#x2F;将b.num赋值给evt.num document.dispatchEvent(evt); &#x2F;&#x2F;派发evt事件对象 &#125; &#125; var obj1&#x3D;&#123; a:function()&#123; document.addEventListener(&quot;a&quot;,this.b); &#x2F;&#x2F;侦听a事件 调用obj1的方法 var evt&#x3D;new Event(&quot;b&quot;); &#x2F;&#x2F;创建事件对象 对象类型为b evt.num&#x3D;2; &#x2F;&#x2F;b.num&#x3D;2; document.dispatchEvent(evt); &#x2F;&#x2F;派发b事件 &#125;, b:function(e)&#123; console.log(e.num); &#x2F;&#x2F;12 &#125; &#125; obj.a(); obj1.a(); 事件原理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt; &lt;style&gt; #div1 &#123; width: 200px; height: 200px; position: relative; background-color: aquamarine; &#125; #div2 &#123; width: 100px; height: 100px; background-color: blueviolet; position: absolute; &#125; #div3 &#123; width: 50px; height: 50px; background-color: yellowgreen; position: absolute; &#125; div &#123; left: 0; right: 0; top: 0; bottom: 0; margin: auto; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;div1&quot;&gt; &lt;div id&#x3D;&quot;div2&quot;&gt; &lt;div id&#x3D;&quot;div3&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script&gt; &#x2F;* var obj&#x3D;&#123; a:1, b:2 &#125; document.addEventListener(&quot;click&quot;,clickHandler); &#x2F;&#x2F;监听点击事件 调用clickHandler方法 function clickHandler(e)&#123; &#x2F;&#x2F;每次点击时调用此方法 console.log(&quot;aaaa&quot;); console.log(obj.a); e.a&#x3D;obj.a; console.log(e.a); &#125; var evt&#x3D;new Event(&quot;click&quot;); &#x2F;&#x2F;创建click事件对象 obj.a&#x3D;10; document.dispatchEvent(evt); &#x2F;&#x2F;派发click事件对象 *&#x2F; var div1 &#x3D; document.getElementById(&quot;div1&quot;); var div2 &#x3D; document.getElementById(&quot;div2&quot;); var div3 &#x3D; document.getElementById(&quot;div3&quot;); &#x2F;&#x2F; addEventListener(事件类型，事件回调函数，是否捕获阶段执行（默认false）||对象&#123;once:true&#125;)&#x2F;&#x2F;是否只执行一次 &#x2F;&#x2F; div1.addEventListener(&quot;click&quot;, clickHandler1,&#123;once:true&#125;); div1.addEventListener(&quot;click&quot;, clickHandler1); div2.addEventListener(&quot;click&quot;, clickHandler2); div3.addEventListener(&quot;click&quot;, clickHandler3); &#x2F;&#x2F; 阻止事件冒泡 function clickHandler1(e) &#123; &#x2F;&#x2F; e.stopPropagation();&#x2F;&#x2F;阻止事件冒泡 &#x2F;&#x2F; console.log(e); &#x2F;&#x2F; e.cancelBubble&#x3D;true;&#x2F;&#x2F;阻止事件冒泡 IE8一下浏览器 console.log(&quot;div1&quot;) &#125; function clickHandler2(e) &#123; console.log(&quot;div2&quot;) &#125; function clickHandler3(e) &#123; console.log(&quot;div3&quot;) &#125; &#x2F;&#x2F; 事件原理三阶段 &#x2F;&#x2F; 捕获 目标 冒泡 &#x2F;&#x2F; 外 到达目标 内 &#x2F;&#x2F; | | &#x2F;&#x2F; 内 外 &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 事件委托和事件区别 e.target &amp;&amp; e.currentTarget 12345e.currentTarget 是事件侦听事件对象（什么对象执行addEventListener函数就是谁）e.target 事件的目标对象 事件实际触发的目标阶段最后对象，e.srcElement兼容IE事件函数中this默认等同于e.currentTarget 举例说明 123456789101112131415var ul&#x3D;document.querySelector(&quot;ul&quot;); ul.addEventListener(&quot;click&quot;,clickHandler); &#x2F;&#x2F; 如果侦听函数调用（addEventListener被使用），就会在内存中添加存储 &#x2F;&#x2F; 尽量减少事件的侦听，因此就会将事件委托给父容器做侦听，以达到减少事件侦听的存储 function clickHandler(e)&#123; &#x2F;&#x2F; if(e.target.nodeName!&#x3D;&#x3D;&quot;LI&quot;) return; if(e.target.constructor!&#x3D;&#x3D;HTMLLIElement) return; &#x2F;&#x2F; console.log(e); &#x2F;&#x2F; e.currentTarget 是事件侦听事件对象（什么对象执行addEventListener函数就是谁） &#x2F;&#x2F; e.target 事件的目标对象 事件实际触发的目标阶段最后对象，e.srcElement兼容IE &#x2F;&#x2F; 事件函数中this默认等同于e.currentTarget console.log(e.currentTarget,e.target,e.srcElement); &#x2F;&#x2F;ul li li &#x2F;&#x2F; console.log(e.target.textContent); &#125; 二级菜单开启关闭 12345678910111213141516171819202122232425262728293031323334353637&lt;ul id&#x3D;&quot;menu&quot;&gt; &lt;li&gt;北京 &lt;ul&gt; &lt;li&gt;海淀&lt;&#x2F;li&gt; &lt;li&gt;昌平 &lt;ul&gt; &lt;li&gt;沙河&lt;&#x2F;li&gt; &lt;li&gt;回龙观&lt;&#x2F;li&gt; &lt;li&gt;天通苑&lt;&#x2F;li&gt; &lt;li&gt;西二旗&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;朝阳&lt;&#x2F;li&gt; &lt;li&gt;东城&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;河北&lt;&#x2F;li&gt; &lt;li&gt;天津&lt;&#x2F;li&gt; &lt;li&gt;河南&lt;&#x2F;li&gt; &lt;li&gt;山西&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; var lis&#x3D;document.getElementsByTagName(&quot;li&quot;); &#x2F;&#x2F;获取所有li标签 for(var i&#x3D;0;i&lt;lis.length;i++)&#123; &#x2F;&#x2F;遍历li的长度 lis[i].addEventListener(&quot;click&quot;,clickHandler); &#x2F;&#x2F;当点击每个li时添加click事件 &#125; function clickHandler(e)&#123; &#x2F;&#x2F;调用click方法 if(!this.firstElementChild) return; &#x2F;&#x2F;如果没有子元素 返回 e.stopPropagation(); &#x2F;&#x2F;不再派发事件 if(!this.bool) this.firstElementChild.style.display&#x3D;&quot;none&quot;; &#x2F;&#x2F;开关 将当前点击的元素的子元素进行隐藏 else this.firstElementChild.style.display&#x3D;&quot;block&quot;; &#x2F;&#x2F;显示 this.bool&#x3D;!this.bool; &#x2F;&#x2F;设置开关 &#125; 事件委托 1234567891011var menu&#x3D;document.querySelector(&quot;#menu&quot;); &#x2F;&#x2F;获取最外层ul menu.addEventListener(&quot;click&quot;,clickHandler); &#x2F;&#x2F;给menu添加点击事件 function clickHandler(e)&#123; if(e.target.constructor!&#x3D;&#x3D;HTMLLIElement)return; &#x2F;&#x2F;如果当前点击类型不为li return if(!e.target.firstElementChild) return; &#x2F;&#x2F;??? e.stopPropagation(); &#x2F;&#x2F;不再派发事件 if(!e.target.bool) e.target.firstElementChild.style.display&#x3D;&quot;none&quot;; &#x2F;&#x2F;开关 当前元素的第一个子元素隐藏 else e.target.firstElementChild.style.display&#x3D;&quot;block&quot;; e.target.bool&#x3D;!e.target.bool; &#x2F;&#x2F;设置开关 &#125; 移除侦听事件的方法 12345678910111213141516 &#x2F;&#x2F; 事件侦听添加（注册事件）占有内存的， 第一种： document.addEventListener(&quot;click&quot;,clickHandler,&#123;once:true&#125;); &#x2F;&#x2F;事件只执行一次第二种： document.addEventListener(&quot;click&quot;,clickHandler); &#x2F;&#x2F; 删除对象时，一定要将对象上的侦听事件移除 var num&#x3D;0; function clickHandler(e)&#123; num++; console.log(&quot;aaa&quot;); &#x2F;&#x2F; 事件移除 if(num&gt;&#x3D;3) this.removeEventListener(&quot;click&quot;,clickHandler); &#x2F;&#x2F;移除click监听事件 &#125; 不能同时执行两个事件函数 可以执行两个不同的函数 12345678910111213141516171819document.onclick&#x3D;function()&#123; &#x2F;&#x2F; document.onclick&#x3D;null;&#x2F;&#x2F;移除事件侦听 console.log(&quot;a&quot;) &#125; document.onclick&#x3D;function()&#123; console.log(&quot;b&quot;); &#125; &#x2F;&#x2F; 可以执行两个不同的函数 document.addEventListener(&quot;click&quot;,clickHandler1); document.addEventListener(&quot;click&quot;,clickHandler2); function clickHandler1(e)&#123; document.removeEventListener(&quot;click&quot;,clickHandler1); console.log(&quot;a&quot;); &#125; function clickHandler2(e)&#123; console.log(&quot;b&quot;) &#125; 事件匿名函数的不断迭代就会造成回调地狱 12345678document.onclick&#x3D;function()&#123; var bn&#x3D;document.querySelector(&quot;button&quot;); bn.onclick&#x3D;function()&#123; console.log(&quot;aaa&quot;); &#125; &#125; &#x2F;&#x2F; 而使用事件注册时用的是命名函数就会减少造成回调地狱 鼠标事件 MouseEvent 12345678910mousedown 鼠标按下mouseup 鼠标释放click 左键单击dblclick 左键双击mousemove 鼠标移动mouseover 鼠标经过mouseout 鼠标滑出mouseenter 鼠标进入mouseleave 鼠标离开contextmenu 右键菜单 1234567891011121314151617document.addEventListener(&quot;click&quot;,clickHandler); function clickHandler(e)&#123; console.log(e); &#125; var div&#x3D;document.querySelector(&quot;.div2&quot;); &#x2F;&#x2F; div.addEventListener(&quot;click&quot;,clickHandler); &#x2F;&#x2F; div.addEventListener(&quot;dblclick&quot;,clickHandler); &#x2F;&#x2F; div.addEventListener(&quot;mousedown&quot;,clickHandler); &#x2F;&#x2F; div.addEventListener(&quot;mouseup&quot;,clickHandler); &#x2F;&#x2F; div.addEventListener(&quot;mousemove&quot;,clickHandler); &#x2F;&#x2F; mouseover和mouseout子元素也会触发，可以冒泡触发 &#x2F;&#x2F; mouseenter和mouseleave是针对侦听的对象触发，阻止了冒泡 &#x2F;&#x2F; div.addEventListener(&quot;mouseover&quot;,clickHandler); &#x2F;&#x2F; div.addEventListener(&quot;mouseout&quot;,clickHandler); &#x2F;&#x2F; div.addEventListener(&quot;mouseenter&quot;,clickHandler); &#x2F;&#x2F; div.addEventListener(&quot;mouseleave&quot;,clickHandler); 去除单机右键菜单 123456div.addEventListener(&quot;contextmenu&quot;,clickHandler); &#x2F;&#x2F;给div添加一个单机右键菜单的监听事件 function clickHandler(e)&#123; e.preventDefault();&#x2F;&#x2F;阻止事件默认行为 console.log(e.type); &#125; 阻止图像默认拖拽 12345var img&#x3D;document.querySelector(&quot;img&quot;); img.addEventListener(&quot;mousedown&quot;,mouseHandler); function mouseHandler(e)&#123; e.preventDefault(); &#125; 文字的拖拽和选择 1234div.addEventListener(&quot;mousedown&quot;,mouseHandler); function mouseHandler(e)&#123; e.preventDefault(); &#125; 阻止表单提交及重设 123456var bn&#x3D;document.querySelector(&quot;[type&#x3D;submit]&quot;); bn.addEventListener(&quot;click&quot;,clickHandler); function clickHandler(e)&#123; e.preventDefault(); &#125; 阻止表单提交 123456var form&#x3D;document.querySelector(&quot;form&quot;); form.addEventListener(&quot;submit&quot;,submitHandler); function submitHandler(e)&#123; e.preventDefault(); e.returnValue&#x3D;false;&#x2F;&#x2F;IE8 及以下兼容写法 &#125; 拖拽 1234567891011121314&lt;div class&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt;var div &#x3D; document.querySelector(&quot;.div1&quot;);var div &#x3D; document.querySelector(&quot;.div1&quot;); &#x2F;&#x2F;获取div1元素 div.onmousedown&#x3D;function(e1)&#123; &#x2F;&#x2F;设置鼠标拖拽的函数 document.onmousemove&#x3D;function(e2)&#123; &#x2F;&#x2F;相对与document鼠标拖拽的函数 div.style.left&#x3D;e2.clientX-e1.offsetX+&quot;px&quot;; &#x2F;&#x2F;点击位置距离当前body可视区域的x坐标-相对于带有定位的父盒子的x坐标 div.style.top&#x3D;e2.clientY-e1.offsetY+&quot;px&quot;; &#125; document.onmouseup&#x3D;function(e3)&#123; document.onmousemove&#x3D;null; &#125;&#125; 拖拽2 123456789101112131415161718192021222324252627282930&lt;div class&#x3D;&quot;divs&quot;&gt; &lt;div class&#x3D;&quot;div0&quot;&gt; &lt;div class&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt; &lt;!-- &lt;div class&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;div1&quot;&gt;&lt;&#x2F;div&gt; --&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; div.addEventListener(&quot;mousedown&quot;, mouseDownHandler); var x, y; function mouseDownHandler(e) &#123; x &#x3D; e.offsetX; y &#x3D; e.offsetY; document.addEventListener(&quot;mousemove&quot;, mouseMoveHandler); document.addEventListener(&quot;mouseup&quot;, mouseUpHandler); &#125; function mouseMoveHandler(e) &#123; div.style.left &#x3D; e.clientX - x + &quot;px&quot;; div.style.top &#x3D; e.clientY - y + &quot;px&quot;; &#125; function mouseUpHandler(e) &#123; document.removeEventListener(&quot;mousemove&quot;, mouseMoveHandler); document.removeEventListener(&quot;mouseup&quot;, mouseUpHandler); &#125;","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"事件","slug":"事件","permalink":"https://cooli-willson.github.io/tags/%E4%BA%8B%E4%BB%B6/"}]},{"title":"8.DOM的属性","slug":"8.DOM的属性","date":"2020-01-25T07:34:14.215Z","updated":"2020-01-25T07:41:36.445Z","comments":true,"path":"2020/01/25/8.DOM的属性/","link":"","permalink":"https://cooli-willson.github.io/2020/01/25/8.DOM%E7%9A%84%E5%B1%9E%E6%80%A7/","excerpt":"","text":"DOM的属性 DOM常用属性 document.body 1// console.log(document.body);//body标签 document.title 1// console.log(document.title);//title标签 document.URL 1// console.log(document.URL);//当前地址 document.styleSheets 1//console.log(document.styleSheets);//css样式对象 document.domainjs 1console.log(document.domain);//当前域 标签属性 自定义标签属性 1234567&lt;div s=\"20\" id=\"abc\" title=\"abc\" name=\"ef\" toggle-data=\"\"&gt;&lt;/div&gt;var div=document.querySelector(\"div\"); div.sum=10;//标签属性中 class--&gt;对象属性的classNameconsole.log(div.className);div.classname=\"abcd\"; 标签默认的系统属性 123456789&lt;input type=\"checkbox\" checked=\"checked\" name=\"ef\"&gt;var div=document.querySelector(\"div\");console.log(input.checked);input.checked=false;console.log(input.name);console.log(div.name); 自定义标签属性 12341、命名单词之间使用-连2、标签属性值必须是字符串div.setAttribute(\"sums\",\"30\"); 删除标签属性 12// 删除标签属性div.removeAttribute(\"toggle-data\"); 获取标签属性 属性值都是字符串 1// console.log(div.getAttribute(\"name\")); 导航栏标题滚动 12345678var str=\"欢迎来到千锋学习H5课程，希望大家能学有所成!\"; var n=-1; setInterval(animation,100); function animation()&#123; n++; if(n&gt;str.length-1) n=0; document.title=str.slice(n);&#125; DOM的样式 获取DOM元素计算后样式，CSS样式和行内样式合并计算后的样式 12console.log(div.currentStyle.width)//仅适用于IE浏览器console.log(getComputer(div).width)//IE8以下不支持，谷歌火狐支持 获取DOM计算后样式的几种方式 1234567891011121314151617181920212223var width; if(getComputedStyle(div))&#123; width=getComputedStyle(div).width; &#125;else&#123; width=div.currentStyle.width; &#125; console.log(width); var style=getComputedStyle(div) || div.currentStyle; var width=style.width; console.log(width); try&#123; width=getComputedStyle(div).width; &#125;catch(e)&#123; // 执行try时出错后执行catch，并且不报错 // e error对象 console.log(e); width=div.currentStyle.width; &#125; console.log(width); 设置CSS样式不可用 1document.styleSheets[0].disabled=true; 通过函数插入CSS样式 1234567891011121314151617181920212223242526272829303132var obj=&#123; //将CSS样式储存为对象类型 width:\"50px\", height:\"50px\", backgroundColor:\"red\", border:\"1px solid #000000\" &#125; insertCss(\"div\",obj); //通过insert函数进行创建 第一个参数为标签名 第二个参数为CSS样式 insertCss(\"div:hover\",&#123; //当hover时的样式 width:\"100px\", height:\"100px\", borderTop:\"1px solid #000000\", borderBottom:\"1px solid #000000\", fontSize:\"25px\"&#125;); function insertCss(select,styles)&#123; if(document.styleSheets.length===0)&#123; //当没有样式表时在头部创建&lt;style&gt;标签 var style=document.createElement(\"style\"); document.head.appendChild(style); &#125; var styleSheet=document.styleSheets[document.styleSheets.length-1]; //将styleSheets的最后一个元素赋值给styleSheet; var str=select+\" &#123;\"; //给标签进行样式写入 for(var prop in styles)&#123; //在对象型样式中进行for in 遍历 str+=prop.replace(/([A-Z])/g,function(item)&#123; //将大写css样式属性转换为小写，可以同样进行使用 return \"-\"+item.toLowerCase(); &#125;)+\":\"+styles[prop]+\";\" &#125; str+=\"&#125;\"; styleSheet.insertRule(str,styleSheet.cssRules.length); //??? &#125;","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"DOM的属性","slug":"DOM的属性","permalink":"https://cooli-willson.github.io/tags/DOM%E7%9A%84%E5%B1%9E%E6%80%A7/"}]},{"title":"7.BOM","slug":"7.BOM","date":"2020-01-25T07:09:14.521Z","updated":"2020-01-25T07:11:02.110Z","comments":true,"path":"2020/01/25/7.BOM/","link":"","permalink":"https://cooli-willson.github.io/2020/01/25/7.BOM/","excerpt":"","text":"BOM 12345Document Object Model（文档对象模型）DOM是针对HTML和XML文档的一个API（Application Programming Interface应用程序编程接口）。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。HTML DOM 定义了访问和操作HTML文档的标准方法。要改变页面的某个东西，JavaScript 就需要获得对 HTML 文档中所有元素进行访问的入口。这个入口，连同对 HTML 元素进行添加、移动、改变或移除的方法和属性，都是通过文档对象模型来获得的（DOM）。我们可以通过JavaScript操作DOM，可以对节点实现增删改查操作，可以动态添加标签，属性等。 BOM和DOM的区别 12345678910BOM1. BOM是Browser Object Model的缩写，即浏览器对象模型。2. BOM没有相关标准。不同浏览器定义有差别,实现方式不同。3. BOM的最根本对象是window。DOM1.DOM是Document Object Model的缩写，即文档对象模型。2.DOM是W3C的标准。3.DOM最根本对象是document（实际上是window.document）。DOM的最根本的对象是BOM的window对象的子对象。BOM是浏览器对象模型，DOM是文档对象模型，前者是对浏览器本身进行操作，而后者是对浏览器（可看成容器）内的内容进行操作 window对象 open() 用法： 1window.open(\"要打开的网页\"，\"网页名字\"，\"height=100,width=100\"); colse() 用法： 1close();//关闭网页 innerHeight &amp;&amp; innerWidth 用法： 12console.log(innerWidth,innerHeight);//浏览器的宽度和高度，包含滚动条宽度,高度是文档高度 console.log(outerWidth,outerHeight);//如果是全屏和上面相同，如果不是全屏包含阴影宽度，浏览器高度 screenLeft &amp;&amp; screenRight || screenX &amp;&amp;screenY 用法： 123console.log(screenLeft,screenTop)console.log(screenX,screenY)完全相同 都是浏览器窗口距离屏幕左上顶点的距离，只读数据 例子： 1234setInterval(animation,16); //定时器每16毫秒执行一次本方法function animation()&#123; console.log(screenLeft,screenTop) &#125; loaction对象 reload() 用法： 123setTimeout(function()&#123; location.reload(); &#125;,3000) // 重载刷新当前页面 herf 用法: 1location.href = \"https://www.baidu.com/\"; assign 用法： 1location.assign(“https://www.baidu.com/“) replace 用法： 1location.replace(\"https://www.baidu.com/\"); href &amp;&amp; assign &amp;&amp;replace 的区别 123location.href=\"http://www.163.com\";//href获取当前页面地址，也可以设置当前页面地址，达到跳转页面location.assign(\"http://www.163.com\");//只能跳转页面location.replace(\"http://www.163.com\");//替换当前页面，跳转页面 跳转 12345document.onclick=function()&#123; // location.href=\"http://www.163.com\"; // location.assign(\"http://www.163.com\"); location.replace(\"http://www.163.com\");//不能产生历史记录 &#125; hash 用法： 1console.log(location.hash);//获取锚点名 #和后面内容 search 用法： 1console.log(location.search);//?和后面的内容 hostname 用法： 1console.log(location.hostname); //域名 port 用法： 1console.log(location.port); //端口号 pathname 用法: 1console.log(location.) //当前地址除了域名和端口号以外的路径 protocol 1console.log(location.protocol); //协议 http history对象 forword &amp;&amp; back 用法： 12history().forword; //向前进一页history().back; //向后退一页 前进后退页面案例： 12345678910111213 &lt;button id=\"back\"&gt;向后&lt;/button&gt; &lt;button id=\"forword\"&gt;向前&lt;/button&gt;var forword=document.getElementById(\"forword\"); var back=document.getElementById(\"back\"); document.onclick=function()&#123; location.href=\"http://www.163.com\"; &#125; forword.onclick=function()&#123; history.forward(); &#125; back.onclick=function()&#123; history.back(); &#125; go() 用法: 123history.go(0);//刷新页面history.go(1);//向前一个history.go(-1);//向后一个 length 1console.log( history.length); //属性返回历史列表中的网址数 screen对象 availHeight &amp;&amp; availWidth 用法： 12console.log(screen.availWidth,screen.availHeight);//去除了任务栏的宽高console.log(screen.width,screen.height);//全屏幕宽高 height &amp;&amp;width 1234height 屏幕的高度像素width 屏幕的宽度像素 navigator对象 userAgent 用法： 1onsole.log(navigator.userAgent);//获取浏览器信息 userName 1console.log(navigator.appName);//返回浏览器的名称 appversion 1console.log(navigator.appVersion);//返回浏览器的平台和版本信息 platform 1console.log(navigator.platform);//返回运行浏览器的操作系统平台 BOM节点 nodeName(节点名称) 12345元素节点的nodeName是标签名称文本节点的nodeName永远是#text注释节点的nodeName永远是#commentconsole.log(document.nodeName,document.nodeType,document.nodeValue);标签元素的nodeName就是该标签的大写字母 div的nodeName就是DIV 判断节点名称 12345if(div.nodeName===\"DIV\")&#123; console.log(\"div是DIV标签\")&#125;else if(div.nodeName===\"SPAN\")&#123; console.log(\"div是SPAN标签\")&#125; nodeValue(节点值) 12345文本节点，nodeValue属性包含文本元素节点nodeValue不可用注释节点nodeValue包括注释内容console.log(div.nodeName,div.nodeType,div.nodeValue);nodeValue针对标签元素永远都是null，但是针对文字节点或者注释就是这个节点的内容 nodetype 123456console.log(div.previousSibling.nodeName,div.previousSibling.nodeType,div.previousSibling.nodeValue);//前一个同胞节点的节点名，节点类型，节点值//#text 3 aconsole.log(div.nextSibling.nodeName,div.nextSibling.nodeType,div.nextSibling.nodeValue);//下一个同胞节点的节点名，节点类型，节点值// #comment 8 &lt;a herf=\"&gt;&lt;/a&gt;\" 获取同胞节点 12console.log(div.previousSibling); //前一个同胞节点console.log(div.nextSibling); //这个元素之后紧跟的节点 获取元素 通过id获取元素 1document.getElementById(\"\");//根据id获取元素，只能获取唯一一个，只能使用document获取 通过标签获取元素 12var divs=document.getElementsByTagName(\"div\");//根据标签名获取元素列表，是一个列表// 这个列表类型是HTMLCollection HTML标签列表 根据父元容器获取元素列表 123456console.log(divs.item(0));//divs[0]// 获取元素列表是根据父容器可以获取的 console.log(divs);// 以获取到的div1为父元素，获取其里面子元素是div的元素标签var divs=document.getElementById(\"div1\").getElementsByTagName(\"div\");console.log(divs); 根据标签获取元素 12345var divs=document.getElementsByClassName(\"divs\"); // 这个列表类型是HTMLCollection HTML标签列表 // 也可以根据父容器获取子容器的所有class是什么的元素 var divs=document.getElementById(\"div1\").getElementsByClassName(\"divs\"); console.log(divs) 根据name获取元素 123456789101112// 只能使用document获取 var ck=document.getElementsByName(\"sex\"); // 获取的是NodeList列表 节点列表 console.log(ck); console.log(ck.entries());//entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。 ck.forEach(function(item,index)&#123; console.log(item,index); &#125;) console.log(ck.keys())//keys() 方法用于从数组创建一个包含数组键的可迭代对象。 如果对象是数组返回 true，否则返回 false。 根据选择器获取元素 12345678910// 根据选择器获取元素，并且只返回元素中的第一个 document.querySelector(\"div\"); document.querySelector(\".divs\");//根据class document.querySelector(\"#div\");//根据id var span=document.querySelector(\"#div1&gt;.divs\"); // var span=document.querySelector(\"span.divs\"); var input=document.querySelector(\"input[type=submit]\"); console.log(span); console.log(input); 继承树 12345Object--&gt;EventTarget--&gt;Node--&gt;Element--&gt;HTMLElement--&gt;HTMLDivElement Object--&gt;EventTarget--&gt;Node--&gt;Element--&gt;HTMLElement--&gt;HTMLAnchorElement Object--&gt;EventTarget--&gt;Node--&gt;Element--&gt;HTMLElement--&gt;HTMLSpanElement Object--&gt;EventTarget--&gt;Node--&gt;Element--&gt;HTMLElement--&gt;HTMLUListElement Object--&gt;EventTarget--&gt;Node--&gt;Element--&gt;HTMLElement--&gt;HTMLLIElement 判断元素类型 123456789101112// var div=document.querySelector(\"div\"); // console.log(div.nodeName===\"DIV\"); // console.log(div.constructor===HTMLDivElement);//判断元素是什么类别 // console.log(div); // 所有的标签都是DOM元素 是Object类型 /* div.abc=10; console.log(div); console.dir(div); var arr=[1,2]; console.log(arr); */ 通过节点获取元素 12345678910111213141516// document.body body元素 // document.body.children //所有的子元素 console.log(document.body.children);//子元素 console.log(div1); console.log(document.body.childNodes);//子节点 console.log(div1.parentElement);//父元素 console.log(div1.parentNode);//父节点 var div1=document.getElementById(\"div1\"); console.log(div1.firstElementChild);//第一个子元素 console.log(div1.firstChild);//第一个子节点 console.log(div1.lastElementChild);//最后一个子元素 console.log(div1.lastChild);//最后一个子节点 console.log(div1.nextElementSibling);//下一个兄弟元素 console.log(div1.nextSibling);//下一个兄弟节点 console.log(div1.previousElementSibling);//上一个兄弟元素 console.log(div1.previousSibling);//上一个兄弟节点 DOM元素的增删改查 创建DOM元素 12345678910111213141516// 创建DOM元素 var div=document.createElement(\"span\"); div.style.width=\"100px\"; div.style.height=\"100px\"; div.style.backgroundColor=\"red\"; div.style.display=\"block\"; document.body.appendChild(div); document.querySelector(\"button\").addEventListener(\"click\",clickHandler1); div.addEventListener(\"click\",clickHandler); function clickHandler(e)&#123; div.remove(); &#125; function clickHandler1(e)&#123; document.body.appendChild(div); &#125; 给通过DOM添加的元素插入文本内容 123456var a=document.createElement(\"a\"); a.href=\"#\"; // textContent 就是文本内容a.textContent=\"超链接\";document.body.appendChild(a); 图片可以实例化 不可以实例化 123var img=document.createElement(\"img\"); var img=new Image(); //实例化image对象 var div=new HTMLDivElement();//错误的 随机添加红色方块 1234567891011121314151617document.querySelector(\"button\").addEventListener(\"click\",clickHandler); //给找到的第一个按钮添加点击监听事件 function clickHandler(e)&#123; // e.clientX,e.clientY 鼠标点击的坐标 // document.body.innerHTML+=\"&lt;div&gt;&lt;/div&gt;\" var x=Math.random()*1300; var y=Math.random()*500; // document.write(\"&lt;div style='width:50px;height:50px;background-color:red;position:absolute;left:\"+x+\"px;top:\"+y+\"px'&gt;&lt;/div&gt;\"); // document.body.innerHTML+=\"&lt;div style='width:50px;height:50px;background-color:red;position:absolute;left:\"+x+\"px;top:\"+y+\"px'&gt;&lt;/div&gt;\" var div=document.createElement(\"div\"); div.style.width=\"50px\"; div.style.height=\"50px\"; div.style.backgroundColor=\"red\"; div.style.position=\"absolute\"; div.style.left=x+\"px\"; div.style.top=y+\"px\"; document.body.appendChild(div); &#125; 将数组添加到li中 12345678910var arr=[\"北京\",\"上海\",\"武汉\",\"天津\",\"西安\"]; var ul=document.createElement(\"ul\"); arr.forEach(function(item)&#123; var li=document.createElement(\"li\"); li.textContent=item; ul.appendChild(li); &#125;) document.body.appendChild(ul); // 最后再将父容器放入在body中 碎片容器 1234567// 已有的父容器中放入多个元素，主要用于直接给body放入多个 var con=document.createDocumentFragment();//碎片容器 for(var i=0;i&lt;10;i++)&#123; var div=document.createElement(\"div\"); con.appendChild(div); &#125; document.body.appendChild(con); 给标签添加文本内容 123456789var a=document.createElement(\"a\"); a.href=\"#\"; // a.textContent=\"超链接\"; var span=document.createElement(\"span\"); a.appendChild(span); // a.textContent=\"超链接\";//这种写法会将a标签内的所有内容清除掉，并且写入文本 var txt=document.createTextNode(\"超链接\");//创建文本节点 a.appendChild(txt); document.body.appendChild(a); DOM的插入 1234567891011var div=Utils.ce(\"div\",&#123; width:\"50px\", height:\"50px\", backgroundColor:\"red\" &#125;); // div.textContent=\"你好\"; /* var a=Utils.ce(\"a\"); a.href=\"#\"; a.textContent=\"超链接\"; */ document.body.appendChild(div); DOM插入的工具类使用说明 123456var span=Utils.ce(\"span\"); div.appendChild(span); //父容器.insertBefore(要插入的元素，要插入到那个元素的前面) div.insertBefore(span,div.firstChild); Utils.insertBefore(span,div); Utils.before(span,div); 元素克隆 12345678var div0 = document.getElementById(\"div0\"); var div1=div0.cloneNode(false); div0.appendChild(div1); console.log(div1); //div0 console.log(div0); //div0&gt;div0 // true 是深复制 // 浅复制仅复制当前元素的标签及属性值 // 深复制可以将当前标签中的文 元素删除 123 // div.remove();//删除document.body.removeChild(div);父容器删除子元素 // 删除是从DOM树中删除，如果没有将改元素设为null，将会驻留内存 替换元素 12// 父容器.repaceChild(新的元素，要替换的元素)document.body.replaceChild(a,div); 对象浅复制 12345678var div=document.createElement(\"div\"); // Object.assign(目标对象，源对象)对象浅复制 Object.assign(div.style,&#123; width:'50px', height:\"50px\", backgroundColor:\"green\" &#125;);document.body.appendChild(div); 列表切换案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 #menu &#123; list-style: none; margin: 0; padding: 0; position: relative; height: 200px; list-style: none; &#125; #menu&gt;li &#123; float: left; margin-left: 20px; padding: 10px 30px; border: 1px solid #000000; text-decoration: none; &#125; ul:not(#menu) &#123; position: absolute; display: none; &#125; &lt;ul id=\"menu\"&gt; &lt;li&gt;水果&lt;/li&gt; &lt;li&gt;蔬菜&lt;/li&gt; &lt;li&gt;零食&lt;/li&gt; &lt;li&gt;饮料&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"list1\"&gt; &lt;li&gt;猕猴桃&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;梨&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"list2\"&gt; &lt;li&gt;白菜&lt;/li&gt; &lt;li&gt;土豆&lt;/li&gt; &lt;li&gt;地瓜&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"list3\"&gt; &lt;li&gt;辣条&lt;/li&gt; &lt;li&gt;牛肉干&lt;/li&gt; &lt;li&gt;薯片&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"list4\"&gt; &lt;li&gt;可乐&lt;/li&gt; &lt;li&gt;雪碧&lt;/li&gt; &lt;li&gt;果汁&lt;/li&gt; &lt;/ul&gt; var menu = document.getElementById(\"menu\"); //获取menu列表 var lis = Array.from(menu.getElementsByTagName(\"li\")); //获取所有的li元素 var uls = Array.from(document.getElementsByTagName(\"ul\")).slice(1); //获取除menu列表以外的其他ul元素 window.onpopstate = function () &#123; //历史事件侦听 // console.log(history.state); changeList(); &#125; for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = clickHandler //当前li被点击时 &#125; function clickHandler() &#123; var index = lis.indexOf(this); //当前点击得到的下标存储为index history.pushState(&#123; state: \"list\" + (index + 1) &#125;, \"\", \"#list\" + (index + 1)); //改变地址不刷新页面 changeList(); &#125; function changeList() &#123; for (var i = 0; i &lt; uls.length; i++) &#123; if (uls[i].id === history.state.state) &#123; uls[i].style.display = \"block\"; &#125; else &#123; uls[i].style.display = \"none\"; &#125; &#125; &#125;","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"BOM","slug":"BOM","permalink":"https://cooli-willson.github.io/tags/BOM/"}]},{"title":"倒计时功能","slug":"倒计时功能","date":"2020-01-22T16:39:05.532Z","updated":"2020-01-25T07:13:48.274Z","comments":true,"path":"2020/01/23/倒计时功能/","link":"","permalink":"https://cooli-willson.github.io/2020/01/23/%E5%80%92%E8%AE%A1%E6%97%B6%E5%8A%9F%E8%83%BD/","excerpt":"","text":"倒计时功能 12345input &#123; text-align: right; &#125; 12345 &lt;input type=\"text\" id=\"hour\"&gt;小时 &lt;input type=\"text\" id=\"minute\"&gt;分钟 &lt;input type=\"text\" id=\"second\"&gt;秒 &lt;button id=\"bn\"&gt;开始&lt;/button&gt; &lt;div id=\"div0\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142 var preset,inputs; init(); function init()&#123; inputs=document.getElementsByTagName(\"input\"); var bn=document.getElementById(\"bn\"); var div=document.getElementById(\"div0\"); for(var i=0;i&lt;inputs.length;i++)&#123; inputs[i].oninput=inputHandler; &#125; setInterval(animation,500,div); bn.onclick=clickHandler; &#125; function inputHandler()&#123; this.value=this.value.replace(/\\D/g,\"\"); &#125; function clickHandler()&#123; preset=new Date(); preset.setHours(preset.getHours()+Number(inputs[0].value)); preset.setMinutes(preset.getMinutes()+Number(inputs[1].value)); preset.setSeconds(preset.getSeconds()+Number(inputs[2].value)); setDisabled(true); &#125; function animation(elem)&#123; if(!preset) return; var date=new Date(); var time=preset-date; if(time&lt;0)&#123; preset=null; setDisabled(false); return; &#125; time=time/1000; var h=time&gt;=3600 ? parseInt(time/3600) : 0; var m=time&gt;=60 ? parseInt((time-h*3600)/60) : 0; var s=parseInt(time-h*3600-m*60); elem.innerHTML=h+\"小时\"+m+\"分\"+s+\"秒\"; &#125; function setDisabled(bool)&#123; for(var i=0;i&lt;inputs.length;i++)&#123; inputs[i].disabled=bool; &#125; &#125;","categories":[{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/categories/%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"字符串","slug":"字符串","permalink":"https://cooli-willson.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/tags/%E5%8A%9F%E8%83%BD/"}]},{"title":"获取中文时间","slug":"获取中文时间","date":"2020-01-22T16:38:42.439Z","updated":"2020-01-23T07:50:30.033Z","comments":true,"path":"2020/01/23/获取中文时间/","link":"","permalink":"https://cooli-willson.github.io/2020/01/23/%E8%8E%B7%E5%8F%96%E4%B8%AD%E6%96%87%E6%97%B6%E9%97%B4/","excerpt":"","text":"获取中文时间 1&lt;div id=\"div0\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839 var arr=[\"零\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\",\"七\",\"八\",\"九\"]; init(); function init()&#123; var div=document.getElementById(\"div0\"); setInterval(animation,500,div); &#125; function animation(elem)&#123; var date=new Date(); var time=\"\"; time+=getYearCN(date.getFullYear()); time+=getCNNumber(date.getMonth()+1)+\"月\"; time+=getCNNumber(date.getDate())+\"日&amp;emsp;\"; time+=\"星期\"+(date.getDay()===0 ? \"日\" : getCNNumber(date.getDay()))+\"&amp;emsp;\"; time+=getCNNumber(date.getHours())+\"点\"; time+=getCNNumber(date.getMinutes(),true)+\"分\"; time+=date.getSeconds()===0 ? \"\" : getCNNumber(date.getSeconds(),true)+\"秒\"; elem.innerHTML=time; &#125; function getYearCN(year)&#123; var y=\"\"; year=String(year); for(var i=0;i&lt;year.length;i++)&#123; y+=arr[year[i]]; &#125; return \"公元\"+y+\"年\"; &#125; function getCNNumber(n,bool)&#123; if(n&lt;0 || n&gt;1000) return \"错误的消息\"; if(n&lt;10) return bool ? \"零\"+arr[n] : arr[n]; if(n===10) return \"十\"; if(n&lt;20) return \"十\"+arr[String(n)[1]]; if(n&gt;=100 &amp;&amp; n%100===0) return arr[String(n)[0]]+\"百\"; if(n&gt;100 &amp;&amp; n%10===0) return arr[String(n)[0]]+\"百\"+arr[String(n)[1]]+\"十\"; if(n%10===0) return arr[String(n)[0]]+\"十\"; if(n&lt;100) return arr[String(n)[0]]+\"十\"+arr[String(n)[1]]; if(n%100&lt;10) return arr[String(n)[0]]+\"百零\"+arr[String(n)[2]]; return arr[String(n)[0]]+\"百\"+arr[String(n)[1]]+\"十\"+arr[String(n)[2]]; &#125;","categories":[{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/categories/%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/tags/%E5%8A%9F%E8%83%BD/"},{"name":"中文时间","slug":"中文时间","permalink":"https://cooli-willson.github.io/tags/%E4%B8%AD%E6%96%87%E6%97%B6%E9%97%B4/"}]},{"title":"6.特殊数组和字符串","slug":"6.特殊数组和字符串","date":"2020-01-22T16:36:58.776Z","updated":"2020-01-25T07:12:41.301Z","comments":true,"path":"2020/01/23/6.特殊数组和字符串/","link":"","permalink":"https://cooli-willson.github.io/2020/01/23/6.%E7%89%B9%E6%AE%8A%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"特殊数组和字符串 复杂型数组 二维数组 123456789 var arr=[]; for(var i=0;i&lt;10;i++)&#123; arr[i]=[]; for(var j=0;j&lt;10;j++)&#123; arr[i][j]=i*10+j; &#125; &#125; // 行列唯一对应值 console.log(arr); 对象型数组 1234567891011121314 var data=[ &#123;id:1001,icon:\"img/1.png\",name:\"餐饮0\",num:1,price:10&#125;, &#123;id:1002,icon:\"img/2.png\",name:\"餐饮1\",num:1,price:20&#125;, &#123;id:1003,icon:\"img/3.png\",name:\"餐饮2\",num:1,price:30&#125;, &#123;id:1004,icon:\"img/4.png\",name:\"餐饮3\",num:1,price:40&#125;, &#123;id:1005,icon:\"img/5.png\",name:\"餐饮4\",num:1,price:50&#125;, &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;, &#123;id:1007,icon:\"img/7.png\",name:\"餐饮6\",num:1,price:70&#125;, &#123;id:1008,icon:\"img/8.png\",name:\"餐饮7\",num:1,price:80&#125;, &#123;id:1009,icon:\"img/9.png\",name:\"餐饮8\",num:1,price:90&#125;, &#123;id:1010,icon:\"img/10.png\",name:\"餐饮9\",num:1,price:100&#125;]; var obj= &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;; console.log(data.indexOf(obj)); flatMap 以及重构 1234567891011121314151617181920212223242526272829303132333435363738394041424344 var arr = [ [1, 2, 3], [4, 5, 6], 7, 8, 9 ]; // var arr1=arr.flatMap(function(item,index,a)&#123; // return item; // &#125;) // console.log(arr1); function flatMap(arr, item) &#123; //第一个参数为遍历数组，第二个元素为新数组 for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i].constructor===Array)&#123; // if(Array.isArray(arr[i]))&#123; //第二种当前元素是否为数组的方式 if(arr[i]) flatMap(arr[i], item); //当前元素为数组时使用递归的方式继续遍历内数组 &#125; else &#123; item.push(arr[i]); //将每个元素push到item中去 &#125; &#125; return item; &#125; console.log(flatMap(arr, []));function flapMap(arr,fn)&#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]===undefined) continue; var item=fn(arr[i],i,arr); a=a.concat(item); &#125; return a; &#125; var arr=[[1,2,3],[4,5,6],[5,6,7],8,9,10]; var a=flapMap(arr,function(item,index,arr)&#123; if(Array.isArray(item))&#123; return item.map(function(t)&#123; return t+10; &#125;) &#125;else&#123; return item+10; &#125; &#125;); console.log(a); 使用方法的方式 1234567891011121314 var arr=new Array(1,2,3); // 实例化方法 arr.forEach(function()&#123; &#125;); // 静态方法 Array.isArray(); // 把构造函数看成对象，增加的方法 Array.from(); // static //数学方法 Math // Math全部都是静态属性和方法 Math是一种静态类 // 该类别不能实例化 var math=new Math();//错误 console.log(math); math方法的使用 123456789101112131415161718192021222324252627282930 console.log(Math.PI); console.log(Math.SQRT2); console.log(Math.abs(-5));//绝对值 if(a&lt;0) a=-a; console.log(0.1+0.2===0.3); Math.round(3.2);//四舍五入 console.log(Math.round(-3.6)); console.log(Math.round(-4+0.5)); console.log(Math.floor(3.6));//向下取整 3 console.log(Math.ceil(3.2));//向上取整 4 console.log(Math.max(3,5,7,8));//8 求最大值 console.log(Math.min(3,5,7,8));//3 求最小值 var arr=[1,2,3,4,5,6,10]; console.log(Math.max.apply(null,arr));//求数组中的最大值 console.log(Math.min.apply(null,arr));//求数组中的最小值 console.log(Math.sqrt(9))//平方根 console.log(Math.pow(2,2)); console.log(Math.pow(2,32)); console.log(Math.pow(4,0.5));//平方根 console.log(Math.pow(4,1/3));//立方根 console.log(1&lt;&lt;32); // Math.random() 随机值 0-1 console.log(Math.random()); console.log(Math.floor(Math.random()*50)); console.log(Math.ceil(Math.random()*50)); function random(min,max)&#123; return Math.floor(Math.random()*(max-min))+min; &#125; console.log(random(50,150)); String基础 不同声明或者使用方式储存的位置也是不同的 123456789101112131415161718 var str = \"abcdefghijk\"; var str='abc'; var str=`abc`; var str=String(\"abc\");//存在栈中 var str1=new String(\"abc\");//字符型对象，存在堆中的 var str2=new String(\"abc\");//字符型对象，存在堆中的 console.log(str2===str1);//不相等 console.log(str[0]);//获取字符串的下标是0的字符 str[0]=10; // str[0] 是只读，不能设置值 // str.length 长度，只读，只能获取字符串的字符个数 var len=str.length-1; var str1=\"\"; while(len&gt;=0)&#123; str1+=str[len]; len--; &#125; console.log(str1); 字符串连接 1234567 // str=str.concat(\"abc\");连接字符串 str+=\"abc\"; var str1=str+\"abc\"; var age=15; var str=\"今年小明\"+age+\"岁了\"; var str=\"今年小明\".concat(age,\"岁了\"); console.log(str); 字符串和数组通用的方法 1234 console.log(str.charAt(1));//str[1]; console.log(str.indexOf(\"b\",1)); console.log(str.lastIndexOf(\"b\")); console.log(str.slice(0,1));//截取赋值0，1 随机颜色 123456789 function randomColor()&#123; var color=\"rgb(\"; for(var i=0;i&lt;3;i++)&#123; color+=Math.floor(Math.random()*256)+\",\"; &#125; color=color.slice(0,-1)+\")\"; return color; &#125; console.log(randomColor()); 随机4位大小写验证码 12345678910111213141516171819202122 function getStr() &#123; var arr = []; for (var i = 48; i &lt; 123; i++) &#123; if (i &gt; 57 &amp;&amp; i &lt; 65) continue; if (i &gt; 90 &amp;&amp; i &lt; 97) continue; arr.push(String.fromCharCode(i)); &#125; /* arr.sort(function()&#123; return Math.random()-0.5; &#125;); arr.length=4; return arr.join(\"\"); */ var str = \"\"; while (str.length &lt; 4) &#123; var s = Math.floor(Math.random() * arr.length); if (str.indexOf(arr[s]) &gt; -1) continue; str += arr[s]; &#125; return str; &#125; console.log(getStr()); 随机字母和数字验证码 123456789101112131415 var arr = []; for (var i = 48; i &lt; 123; i++) &#123; if (i &gt; 57 &amp;&amp; i &lt; 65) continue; if (i &gt; 90 &amp;&amp; i &lt; 97) continue; arr.push(String.fromCharCode(i)); &#125; var arr1=[]; var i=0; while(arr.length&gt;0)&#123; if(i&gt;3) break; var n=Math.floor(Math.random()*arr.length); arr1.push(arr.splice(n,1)[0]); i++; &#125; console.log(arr1); 字符串方法 123456789101112131415161718192021222324 // 正则中使用的方法 console.log(str.search(\"a\"));//查找 console.log(str.match(\"a\"));//查找 console.log(str.replace(要查找的内容,要替换的值或者回调函数)) console.log(str.replace(\"a\",\"z\"));//替换字符串中指定的内容，返回被替换后的字符串，原字符串不改变 // 现在仅能替换第一个被查找到的元素 // substring不允许使用负数（负数就是0） // 反向截取 console.log(str.substring(4,0)); // substr // 截取固定长度的字符串 // str.substr(从什么位置开始，截取字符串的长度); // 开始位置可以使用负数,如果没有给长度，就会截取到尾部 console.log(str.substr(-6)); var str=\"xietian@163.com\"; console.log(str.substring(str.indexOf(\"@\")+1)); var str=\"a,b,c,d,e\"; console.log(str.split(\",\"));//将字符串以什么符号切割成数组 console.log(str.split(\"\").reverse().join(\"\")); var str=\"xietian@163.com\"; console.log(str.split(\"@\")[1]); console.log(str.toUpperCase());//转换成大写 console.log(str[0].toUpperCase()+str.slice(1)); console.log(str.toLowerCase());//转换为小写字母 Date 12345678var date=new Date(); console.log(date); console.log(date.toUTCString());//获取格林尼治日期时间 console.log(date.toLocaleString());//获取本地日期时间 console.log(date.toLocaleDateString());//获取本地日期 console.log(date.toLocaleTimeString());//获取本地时间 console.log(date.getTime());//获取时间戳 1970.1.1，0点到现在的毫秒数 // 时间戳永远都不相同 循环10000次的时间 123456var time=new Date().getTime(); for(var i=0;i&lt;10000;i++)&#123; var a=Math.pow(2,20); var a=1&lt;&lt;20; &#125; console.log(new Date().getTime()-time); 计算循环的时间 12345678910111213141516171819202122232425262728293031323334353637383940 var dateManager=&#123; date:&#123;&#125;, num:0, start:function()&#123; // 对象的方法中，如果调用了该对象的属性，就需要使用this this.num++; // dateManager.num++; this.date[\"date_\"+this.num]=new Date().getTime(); return \"date_\"+this.num &#125;, end:function(id)&#123; var time=this.date[id]; delete this.date[id]; return new Date().getTime()-time; &#125; &#125; /* var dm=dateManager; dateManager=&#123;&#125;; dm.start(); var id=date.start(); // ..... // .... var ids=date.start(); // ... console.log(date.end(id)); //... console.log(date.end(ids)); */ var id1=dateManager.start(); for(var i=0;i&lt;1000000;i++)&#123; &#125; var id2=dateManager.start(); var ids=setTimeout(function()&#123; console.log(dateManager.end(id1)); clearTimeout(ids); ids=setTimeout(function()&#123; clearTimeout(ids); console.log(dateManager.end(id2)); &#125;,1000) &#125;,1000) 获取日期 1234567891011121314151617var date=new Date(); console.log(date.getYear()); console.log(date.getFullYear());//年 console.log(date.getMonth());0-11//月 console.log(date.getDate());//日期 console.log(date.getDay());//星期 星期日0，1-6星期一-星期六 console.log(date.getHours());//小时 console.log(date.getMinutes());//分 console.log(date.getSeconds());//秒 console.log(date.getMilliseconds());//毫秒 console.log(date.getUTCDate());//格林尼治日期 date.setFullYear(2021); // 设置日期时间时，如果超出范围，就会自动进位 date.setMonth(12); console.log(date); date.setMinutes(date.getMinutes()+5); console.log(date);","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"字符串","slug":"字符串","permalink":"https://cooli-willson.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"5.js基础 递归和数组","slug":"5.js基础 递归和数组","date":"2020-01-22T15:12:26.387Z","updated":"2020-01-22T15:15:20.512Z","comments":true,"path":"2020/01/22/5.js基础 递归和数组/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/5.js%E5%9F%BA%E7%A1%80%20%E9%80%92%E5%BD%92%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"5.js基础 递归和数组 递归 递归与回调函数的使用 123456789101112131415161718 function fn1()&#123; i++; // console.log(i); if(i&lt;4) fn2(); console.log(i); &#125; function fn2()&#123; i++; // console.log(i); if(i&lt;4) fn3(); console.log(i); &#125; function fn3()&#123; i++; // console.log(i); // if(i&lt;4) fn(); console.log(i); &#125; 浅复制与深层复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var obj = &#123; a: 1, b: 2, c: &#123; a: 3, b: 4, c: &#123; a: 5, b: 6, c: &#123; a: 7, b: 8 &#125; &#125; &#125; &#125;; var obj1=&#123;&#125;; for(var prop in obj)&#123; obj1[prop]=obj[prop]; &#125; obj.c.a=10; console.log(obj1); function cloneObj(target,source)&#123; for(var prop in source)&#123; if(typeof source[prop]===\"object\" &amp;&amp; source[prop]!==null)&#123; target[prop]=&#123;&#125;; cloneObj(target[prop],source[prop]) &#125;else&#123; target[prop]=source[prop]; &#125; &#125; return target; &#125;// 同样的属性 使用引用关系的方式深度遍历 var o = source.c; target.c = &#123;&#125;; var o1 = target.c; while (o) &#123; for (var prop in o) &#123; if (typeof o[prop] !== \"object\" || o[prop] === null) &#123; o1[prop] = o[prop]; &#125; &#125; o = o.c; if (o) &#123; o1.c = &#123;&#125;; o1 = o1.c; &#125; &#125; return target &#125; var obj1 = &#123;&#125;; obj1 = cloneObj(obj1, obj); // obj.c.c.a = 10; console.log(obj1); 数组的创建 什么是数组 12345678var arr=[]; var arr=new Array(); var arr=new Object([]); // 数组是一个引用列表 // 列表：顺序，只有值，紧密，速度慢 var arr=[3,1,6,5,4,8,9]; console.log(arr); 字面量创建数组 1234567 var arr=[1,2,3,4,5]; // arr是数组 1是索引值（下标） arr[1]元素（下标变量） console.log(arr[1]); arr[1]=10;//可以修改下标变量的结果 console.log(arr[1]); arr[5]=10; arr[7]=10;//数组的紧密型，如果中间空余，就会自动补充空元素 数组的使用与特性 123456789101112131415161718192021222324252627282930313233// 遍历内容较多，当添加删除元素时，因为数组紧密型，速度变慢，尤其前面插入和删除 arr[-1]=10; console.log(arr); // length 数组得长度 console.log(arr.length);//表示当前数组得索引下标的最大值+1，因为从0开始 // 当添加不是索引数据（0开始），-1，不会累计在长度中，而作为对象的key，value增加内容 arr[\"6\"]=10; arr[arr.length]=10;//在数组的尾部添加一个新元素 // 每次添加元素后，长度会发生改变，length会变化的，因此下面这句不会修改最后一个元素，而是添加一个新元素 arr[arr.length]=11;//在数组的尾部添加一个新元素 arr.length=10;//如果直接设置数组的长度，长度大于原来的数组的长度时，添加空元素，让数量达到这个设置的值 arr.length=arr.length-1;//如果长度比原来少一个，就会删除最尾部元素 arr.length--; arr.length=0;//表示清空数组 arr=[];//引用地址变化了 arr.length=-2;//数组的长度不能为负值 arr.length=\"a\";//如果给的不是数值，会隐式转换为数值，如果值是NaN，就会报错 console.log(arr,arr.length); // 构造函数创建 // 构造函数实例化对象 var arr=new Array(1,2,3,4,5); console.log(arr); // 字符串转数组类型 var arr=Array(1,2,3,4,5); console.log(arr); // 数组通过构造函数创建时，如果只有一个参数，并且参数是正整数， // 这个数就是数组的长度，而不作为数组的新元素 // 如果是数字，但不是正整数，都会报错 // 如果不是数字，则作为数组的第一个元素添加 var arr=new Array(1); var arr=new Array(\"3\"); var arr=Array(5); console.log(arr);","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"数组","slug":"数组","permalink":"https://cooli-willson.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"递归","slug":"递归","permalink":"https://cooli-willson.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"在表格中插入文字和图片","slug":"在表格中插入文字和图片","date":"2020-01-22T14:58:53.660Z","updated":"2020-01-22T19:02:35.000Z","comments":true,"path":"2020/01/22/在表格中插入文字和图片/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/%E5%9C%A8%E8%A1%A8%E6%A0%BC%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%87%E5%AD%97%E5%92%8C%E5%9B%BE%E7%89%87/","excerpt":"","text":"在表格中插入文字和图片 CSS部分 123456789101112 table &#123; border-collapse: collapse; width: 800px; &#125; td &#123; border: 1px solid #000000; text-align: center; &#125; img &#123; width: 50px; height: 50px; &#125; js部分 1234567891011121314151617181920212223242526272829303132 // fn(); var data1 = [ &#123; id: 1001, icon: \"img/icon01.png\", name: \"餐饮0\", num: 1, price: 10 &#125;, &#123; id: 1002, icon: \"img/icon02.png\", name: \"餐饮1\", num: 1, price: 20 &#125;, &#123; id: 1003, icon: \"img/icon03.png\", name: \"餐饮2\", num: 1, price: 30 &#125;, &#123; id: 1004, icon: \"img/icon04.png\", name: \"餐饮3\", num: 1, price: 40 &#125;, &#123; id: 1005, icon: \"img/icon05.png\", name: \"餐饮4\", num: 1, price: 50 &#125;, &#123; id: 1006, icon: \"img/icon06.png\", name: \"餐饮5\", num: 1, price: 60 &#125;, &#123; id: 1007, icon: \"img/icon07.png\", name: \"餐饮6\", num: 1, price: 70 &#125;, &#123; id: 1008, icon: \"img/icon08.png\", name: \"餐饮7\", num: 1, price: 80 &#125;, &#123; id: 1009, icon: \"img/icon09.png\", name: \"餐饮8\", num: 1, price: 90 &#125;, &#123; id: 1010, icon: \"img/icon10.png\", name: \"餐饮9\", num: 1, price: 100 &#125; ]; function createTable(data) &#123; var table = \"&lt;table&gt;\"; for (var prop in data) &#123; table += \"&lt;tr&gt;\"; var obj = data[prop]; for (var attr in obj) &#123; if (attr === \"icon\") &#123; table += \"&lt;td&gt;&lt;img src='\" + obj[attr] + \"'&gt;&lt;/td&gt;\"; &#125; else &#123; table += \"&lt;td&gt;\" + obj[attr] + \"&lt;/td&gt;\"; &#125; &#125; table += \"&lt;/tr&gt;\"; &#125; table += \"&lt;/table&gt;\"; document.write(table); &#125; createTable(data1);","categories":[{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/categories/%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/tags/%E5%8A%9F%E8%83%BD/"},{"name":"循环","slug":"循环","permalink":"https://cooli-willson.github.io/tags/%E5%BE%AA%E7%8E%AF/"}]},{"title":"实现简单的计算器功能","slug":"实现简单的计算器功能","date":"2020-01-22T14:49:54.302Z","updated":"2020-01-22T19:02:23.897Z","comments":true,"path":"2020/01/22/实现简单的计算器功能/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%E5%8A%9F%E8%83%BD/","excerpt":"","text":"实现简易计算器功能 css部分 12345678910111213141516171819202122232425262728293031323334353637383940414243.div0 &#123; height: 340px; width: 275px; border: 1px solid #000; margin: 0 auto; background-color:#aa0055; &#125; .div0&gt;div &#123; padding-left: 20px; padding-top: 10px; &#125; .div0&gt;div&gt;div &#123; height: 50px; width: 50px; font-size: 20px; line-height: 50px; text-align: center; float: left; border: 1px solid #000; margin-right: 10px; margin-top: 10px; box-shadow: 3px 3px 2px #4f0027; user-select: none; /* 将输入模式改为光标 */ background-color: #ff7dbe; color: #fff; font-weight: bolder; border-radius: 80%; &#125; .div0&gt;div&gt;div:hover &#123; box-shadow: -2px -2px 2px #4f0027; &#125; .div0&gt;input &#123; display: block; height: 50px; width: 250px; margin: 0 auto; text-align: right; padding-right: 20px; background-color: #6f0037; font-size: 30px; color: #fff; font-weight: bolder; &#125; html部分 123456789101112131415161718192021 &lt;div class=\"div0\"&gt; &lt;input type=\"text\" value=\"0\" id=\"input0\" disabled&gt; &lt;!-- 禁止输入 --&gt; &lt;div&gt; &lt;div id=\"div1\"&gt;1&lt;/div&gt; &lt;div id=\"div2\"&gt;2&lt;/div&gt; &lt;div id=\"div3\"&gt;3&lt;/div&gt; &lt;div id=\"div4\"&gt;4&lt;/div&gt; &lt;div id=\"div5\"&gt;5&lt;/div&gt; &lt;div id=\"div6\"&gt;6&lt;/div&gt; &lt;div id=\"div7\"&gt;7&lt;/div&gt; &lt;div id=\"div8\"&gt;8&lt;/div&gt; &lt;div id=\"div9\"&gt;9&lt;/div&gt; &lt;div id=\"div10\"&gt;0&lt;/div&gt; &lt;div id=\"div11\"&gt;+&lt;/div&gt; &lt;div id=\"div12\"&gt;-&lt;/div&gt; &lt;div id=\"div13\"&gt;*&lt;/div&gt; &lt;div id=\"div14\"&gt;/&lt;/div&gt; &lt;div id=\"div15\"&gt;=&lt;/div&gt; &lt;div id=\"div16\"&gt;C&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; js部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 var value, type, input; var value = \"0\"; getValue(); function getValue() &#123; input = document.getElementById(\"input0\");//将input标签储存在input中 for (var i = 1; i &lt; 17; i++) &#123;//遍历每个标签 var div = document.getElementById(\"div\" + i); //将得到div标签存放到div变量中 div.onclick = clickFunction; //当前div点击时调用clickFunction函数 &#125; &#125; function clickFunction() &#123; switch (this.innerHTML) &#123; //通过当前点击获取的值来判断该执行怎样的操作 case \"+\": case \"-\": case \"*\": case \"/\": type = this.innerHTML; //将运算符储存在type变量中 value = input.value; //将当前拼接的字符串储存在value中 input.value = \"0\"; //在点击运算运算符后显示屏幕显示为0 break; case \"=\": getResult(); //调用计算函数 break; case \"C\": //清空操作 当前所有值都设为初始值 value = \"0\"; input.value = \"0\"; type = \"\"; break; default: input.value=Number(input.value+this.innerHTML);//通过Number将拼接成字符串的结果转换为数值型赋值给input.value &#125; &#125; function getResult()&#123; switch(type)&#123; //通过运算符来判断该执行那种运算操作 case \"+\": input.value=Number(value)+Number(input.value); return; //return可以直接返回 break还要继续判断 case \"-\": input.value=Number(value)-Number(input.value); return; case \"*\": input.value=Number(value)*Number(input.value); return; case \"/\": input.value=Number(value)/input.value!==0? Number(input.value):\"输入错误\"; //正则表达式,若被除数为0，则提示“输入错误”; return; &#125; &#125;","categories":[{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/categories/%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/tags/%E5%8A%9F%E8%83%BD/"},{"name":"计算器","slug":"计算器","permalink":"https://cooli-willson.github.io/tags/%E8%AE%A1%E7%AE%97%E5%99%A8/"}]},{"title":"4.javascript 基础-函数","slug":"4.js基础-函数","date":"2020-01-22T14:20:23.154Z","updated":"2020-01-22T14:34:39.677Z","comments":true,"path":"2020/01/22/4.js基础-函数/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/4.js%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数 函数的创建 命名函数创建 当前函数最在script标签创建时，优先将该函数储存在堆中，并且函数名储存在栈中 当前这个代码所在的script标签的上面的script的标签中任意函数和全局变量都是可以被调用的 但是当前代码所在的script标签下面的script的标签中函数和全局变量是不可以调用的 函数名：驼峰式命名法，首字母一般都是小写，如果该函数是构造函数，函数名首字母需要大写 函数后面的（）是执行当前函数需要传入参数内容 {}里面是函数的语句块，当执行函数时，该语句的内容就会被执行 1234function fn(a,b)&#123; console.log(a+b); &#125; fn(3,4) 匿名函数 代码运行到定义匿名函数后才可以调用该匿名函数 12345var fn=function()&#123; &#125; (function()&#123; // 自执行函数 &#125;)(); 函数的作用域 函数内与函数外的变量 12345678910111213141516171819202122232425262728293031// 函数外的变量，在函数中可以调用到 var a=10; function fn()&#123; console.log(a); &#125; fn(); // 函数内定义的变量不能被函数外调用 function fn()&#123; var a=10; // 在函数内使用var定义的变量就是局部变量 // 在函数外用var定义的变量就是全局变量。 // 不使用var直接给一个变量赋值就是相当于给window增加一个属性，那么这个属性也是全局变量 &#125; fn(); console.log(a); // var是定义变量，如果在函数中没有用var定义变量，直接使用变量，该变量是全局变量 function fn()&#123; a=10; &#125; fn(); console.log(a); // this===window // var b=10; function fn()&#123; // window被省略了,如果没有使用var定义变量，就意味着直接在window对象下增加这个属性 a=10; &#125; fn(); console.log(a); 局部变量与全局变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var a=10; function fn()&#123; var a=5; console.log(a);//5 // 有局部变量时，先调用局部变量，没有局部变量才带哦用全局变量 &#125; fn(); console.log(a);//10 var a=10; function fn()&#123; // 在函数中任意位置使用var定义的变量，在该函数的任意位置都认为该变量是局部变量 console.log(a);//undefined var a=5; &#125; fn(); console.log(a);//10 var a=10; function fn()&#123; var a=20; // console.log(a+window.a); console.log(a+this.a); &#125; fn(); // function fn(a)&#123; // // console.log(a); // // 参数就是局部变量 // &#125; // fn(5); var a=10; function fn(a)&#123; console.log(a);//5 var a=20; // 这里相当于重新定义了一个局部变量a &#125; fn(5); var a=5; function fn()&#123; var a=10; function fn1()&#123; var b=20; var a=100; console.log(a); &#125; fn1(); console.log(b); &#125; fn(); a(a);//a都是全局变量，下面a=10还没有运行，所以在这里全局变量就是函数a,我们把函数a当前参数填入 var a=10;//覆盖了函数a，函数a在这里也是全局变量 function a(a)&#123; console.log(a); var a=10; &#125; // a(a); var a; a(a); a=5; function a(a)&#123; console.log(a); var a=10; &#125; 函数的参数 参数可以时任意内容，如没有对应填入，该参数就是undefined、 执行函数时，填入的参数就相当于给参数赋值 js是一个弱类型语言，因此，参数不能强制约定类型 ES5中不能和设置参数的默认值 执行函数时填入值与函数参数顺序时一一对应关系 12345678910111213141516function fn(obj)&#123; // 相当于给obj赋值一个o，obj和o的引用地址相同 // 当修改obj的属性时，全局的o属性也会被修改 obj.a=10; &#125; var o=&#123;a:1&#125;; fn(o); function fn(obj)&#123; // 重新设置了obj的新的引用地址 obj=&#123; a:3 &#125; &#125; var o=&#123;a:1&#125;; fn(o); 回调函数 123456789101112131415function fn(f)&#123; var a=10; f(a); &#125; function fn1(a)&#123; console.log(a+10); &#125; function fn2(a)&#123; console.log(a+100); &#125; function fn3(a)&#123; console.log(a+1000); &#125; fn(fn2); 如果参数的数量不确定，就不设置参数 12345678910111213141516function getMaxValue()&#123; // console.log(arguments);//ES5以上版本时尽量少用,arguments参数集 if(arguments.length===0) return; var max=arguments[0]; for(var i=1;i&lt;arguments.length;i++)&#123; max=max&gt;arguments[i] ? max : arguments[i]; &#125; console.log(max); &#125; getMaxValue(1,4,7,2,3,10); function getMaxValue()&#123; // console.log(arguments.callee);//该函数自己 // console.log(arguments.callee.caller); &#125; getMaxValue(1,3,5,7); 递归 12345678910111213141516 var i=0 function fn()&#123; i++; if(i&lt;10) fn(); &#125; fn(); console.log(i); // 用于匿名函数中调用自身函数 var i=0; (function()&#123; i++; if(i&lt;10) arguments.callee(); &#125;)(); console.log(i); 函数之间的调用 1234567891011121314151617181920 var i=0; function fn1(f)&#123; console.log(\"a\"); f(); &#125; function fn3(f)&#123; console.log(\"c\"); f(); &#125; function fn2()&#123; // 调用当前函数的环境函数 // console.log(arguments.callee.caller); console.log(\"b\"); i++; if(i&lt;10) arguments.callee.caller(arguments.callee); &#125; // 耦合 fn3(fn2); 随机生成颜色大小不同的50个方块 12345678910111213141516171819202122232425262728 var w, c; init(); function init() &#123; for (var i = 0; i &lt; 50; i++) &#123; w = Math.random() * 50 + 50; c = randomColor(); createDiv(w, w, c); &#125; &#125; function createDiv(_width, _height, _color) &#123; var str = \"\"; str += \"&lt;div style='\"; str += \"width:\" + _width + \"px;\"; str += \"height:\" + _height + \"px;\"; str += \"background-color:\" + _color + \";\"; str += \"position:absolute;\"; str += \"left:\" + Math.random() * 1000 + \"px;\"; str += \"top:\" + Math.random() * 600 + \"px;\"; str += \"'&gt;&lt;/div&gt;\"; document.write(str); &#125; function randomColor() &#123; var color = \"#\"; for (var i = 0; i &lt; 6; i++) &#123; color += parseInt(Math.random() * 16).toString(16); &#125; return color; &#125; return 点击切换div的颜色 123456789101112131415161718192021 function fn(n)&#123; console.log(\"aa\"); if(n&lt;5) return; &#125; fn(3); // 把id是div0的元素获取成为DOM变量 var div=document.getElementById(\"div0\"); // 设置行内样式 div.style.width=\"100px\"; div.style.height=\"100px\"; div.style.backgroundColor=\"red\"; var bool=false; div.onclick=function()&#123; bool=!bool; div.style.backgroundColor=bool ? \"blue\" :\"red\"; &#125; div.onclick=clickHandler; function clickHandler()&#123; bool=!bool; div.style.backgroundColor=bool ? \"blue\" :\"red\"; &#125; 定时器 setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 setTimeout() ：在指定的毫秒数后调用函数或计算表达式。 setInterval() 语法 setInterval(code,millisec) 参数 描述 code 必须。要调用的函数或要执行的代码串。 millisec 必须。周期性执行或调用code之间的时间间隔，以毫秒计 1234567891011121314 setInterval(function()&#123; // 间隔多长时间执行该函数，时间是毫秒数 console.log(\"aa\"); return; &#125;,1000); var time=0; // setInterval(执行的函数，间隔的时间);返回一个数值，可以根据这个数值清楚执行函数 var ids=setInterval(animation,1000); function animation()&#123; time++; if(time&gt;5) clearInterval(ids);//clearInterval(创建时间间隔id) 清楚时间间隔执行 console.log(\"aa\"); &#125; setTimeout() 语法 setTimeout(code,millisec) 参数 描述 code 必需。要调用的函数后要执行的javascript代码串 millisec 在执行代码浅需要等待的毫秒数 12345678910 // 多少时间后执行该函数 // setTimeout(执行的函数，间隔的时间);//多长时间后执行 var ids=setTimeout(function()&#123; console.log(\"aa\"); clearTimeout(ids);//清除时间间隔，每次用完必须清除 &#125;,5000); // setInterval和setTimeout第三个参数都是可以给执行函数传入参数的 var ids=setInterval(animation,1000,5); function animation(n)&#123; &#125; return 阻断 12345678910111213141516171819var disc=0,bool=false; init(); function init() &#123; var div = document.getElementById(\"div0\"); div.style.width = \"50px\"; div.style.height = \"50px\"; div.style.backgroundColor = \"red\"; div.style.position = \"absolute\"; div.style.left=\"0px\"; div.onclick=function()&#123; bool=!bool; &#125; setInterval(anmiation,16,div); &#125; function anmiation(div)&#123; if(!bool) return; disc++; div.style.left=disc+\"px\"; &#125; return break continue的区别 12345678910111213141516 function fn()&#123; for(var i=0;i&lt;10;i++)&#123; if(i===5) return; &#125; console.log(\"a\"); &#125; fn(); // return 有时候可以替代break // return 返回值 // 可以允许函数返回一个值，仅一个。。 function fn()&#123; return \"a\"; &#125; // 函数在执行时，将会返回一个结果，如果函数中没有return，就会返回undefined var s=fn(); console.log(s); 随机颜色 123456789101112131415function randomColor(alpha)&#123; // 如果没有参数，随机 alpha=alpha==undefined ? Math.random().toFixed(2) : alpha; // 传入的参数转换为数值 alpha=Number(alpha); // 如果传入的参数是非数值，就让透明度为1 if(isNaN(alpha))alpha=1; var color=\"rgba(\"; for(var i=0;i&lt;3;i++)&#123; color+=parseInt(Math.random()*256)+\",\"; &#125; color+=alpha+\")\"; return color; &#125; console.log(randomColor(true)); 将数字转换为汉字 12345678910111213 function getCNNumber(n)&#123; if(n&lt;0 || n&gt;1000) return \"错误的消息\"; if(n&lt;10) return arr[n]; if(n===10) return \"十\"; if(n&lt;20) return \"十\"+arr[String(n)[1]]; if(n&gt;=100 &amp;&amp; n%100===0) return arr[String(n)[0]]+\"百\"; if(n&gt;100 &amp;&amp; n%10===0) return arr[String(n)[0]]+\"百\"+arr[String(n)[1]]+\"十\"; if(n%10===0) return arr[String(n)[0]]+\"十\"; if(n&lt;100) return arr[String(n)[0]]+\"十\"+arr[String(n)[1]]; if(n%100&lt;10) return arr[String(n)[0]]+\"百零\"+arr[String(n)[2]]; return arr[String(n)[0]]+\"百\"+arr[String(n)[1]]+\"十\"+arr[String(n)[2]]; &#125; console.log(getCNNumber(345)); 返回对象可以返回多个值 12345678function fn(w,h)&#123; // var perimeter=(w+h)*2; // var area=w*h; return &#123; perimeter:(w+h)*2, area:w*h &#125; &#125; 回调函数 123456789101112131415161718192021222324 function callBack()&#123; &#125; setInterval(callBack,1000); function fn1(f)&#123; f(); &#125; function fn2()&#123; console.log(\"aaa\"); &#125; fn1(fn2); var i=0; function fn1(f)&#123; console.log(\"a\"); f(fn1); console.log(i); &#125; function fn2(f)&#123; i++; console.log(\"b\"); if(i&lt;6000) f(fn2); &#125; fn1(fn2); // 堆栈溢出 递归或者回调的次数过多，没有阻止递归或者回调的条件 通过回调函数实现红绿灯功能 1234567891011121314151617181920212223242526272829function getLight(first,second,third)&#123; first(second,third); &#125; function getRedLight(fn,fn1)&#123; var f=arguments.callee; var ids=setTimeout(function()&#123; console.log(\"红灯\"); clearTimeout(ids); fn(fn1,f); &#125;,1000); &#125; function getYellowLight(fn,fn1)&#123; var f=arguments.callee; var ids=setTimeout(function()&#123; console.log(\"黄灯\"); clearTimeout(ids); fn(fn1,f); &#125;,1000); &#125; function getGreenLight(fn,fn1)&#123; var f=arguments.callee; var ids=setTimeout(function()&#123; console.log(\"绿灯\"); clearTimeout(ids); fn(fn1,f); &#125;,1000); &#125; // getRedLight(getYellowLight,getGreenLight); getLight(getGreenLight,getYellowLight,getRedLight)\\","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"函数","slug":"函数","permalink":"https://cooli-willson.github.io/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"3.js基础-循环和对象","slug":"3.js基础-循环和对象","date":"2020-01-22T07:51:40.150Z","updated":"2020-01-22T14:23:07.710Z","comments":true,"path":"2020/01/22/3.js基础-循环和对象/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/3.js%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"js基础-循环和对象 三目运算符 条件 ？ 条件是true返回的结果 ： 条件是false时返回的结果 123456789101112131415var max=3&gt;4 ? 3 : 4; var i=1; var s=--i ? i++ : ++i; console.log(s); var a=6, b=5, c=5; var max=a&gt;b ? (a&gt;c ? a : (c&gt;b ? c : b)) : b&gt;c ? b : (c&gt;a ? c : a); console.log(max); var s=3&gt;5 ? false : true;//返回布尔值的三元运算时，不用些三元方式 var s=3&gt;5; var obj= s ? s : 5;//判断一个值是否存在，如果不存在重新赋值，或 var obj=s || 5; var s= s===0 ? 0 : 5;//判断是否是0 如果不是0，就返回另一个值， var s= s &amp;&amp; 5 条件语句 if语句 123456789101112131415161718192021222324252627282930313233343536373839404142 var s=3; if(s&gt;5)&#123; &#125; if(s&lt;10)&#123; &#125;else&#123; &#125; if(s&gt;0)&#123; &#125;else if(s===0)&#123; &#125;else&#123; &#125; // if(隐式转换为布尔值)&#123; // &#125; // 条件中的结果不是 \"\",false,0,NaN,undefined,null就可以进入条件 var i = 0; var s = 0; if(++i)&#123; s=i++; &#125; if(i+1!==0)&#123; s=i+1; &#125; if(s=++i); console.log(s,i); if(i+1!==0) s=i+1; // 如果条件语句块只有一句话的时候，可以省略｛｝ if(i===0) i=i+2; i=i+3; console.log(i); if(i&gt;0) i=3; else if(i===0) i=5; else i=10; if()&#123; &#125; // 不管是否满足上面的条件，都需要判断下面的这个条件 if()&#123; &#125; if()&#123; &#125;else if()&#123; // 如果上面的条件满足，就不会判断下面这个条件 &#125; // 配合函数中的return将会很少使用到if else if switch case 语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 判断switch中表达式是否（绝对===）等于case中的值 var s=10; switch(s%10)&#123; case 1: // 语句1 break;//break作用是跳出switch语句块，从break后面的语句块将不再执行 // 但是如果没有break,仍然在不判断结果的情况下执行一个case的语句块，这叫穿越 case 2: // 语句2 break; case 3: // 语句3 break; case 0: // 语句4 break; &#125; // switch 或者穿越 var s=10; switch(s%10)&#123; case 0: case 1: case 2: case 3: case 4: s++; break; &#125; var s=10;//累积穿越 switch(s%10)&#123; case 0: s=100; case 1: case 2: case 3: case 4: s--; break; &#125; var s=95; switch(true)&#123; case s&gt;90: break; case s&gt;80: break; case s&gt;70: break; &#125; 状态机 1234567891011121314151617181920212223242526272829303132333435 var value=prompt(\"请输入你的成绩\"); // console.log(value); // document.write('你好'); var value=parseInt(prompt(\"请输入你的成绩\")); if(!isNaN(value))&#123; if(value&gt;100) document.write(\"输入错误\"); else if(value&gt;=90) document.write(\"A\"); else if(value&gt;=80) document.write(\"B\"); else if(value&gt;=70) document.write(\"C\"); else if(value&gt;=60) document.write(\"D\"); else if(value&gt;=0) document.write(\"E\"); else document.write(\"输入错误\"); &#125; var value = parseInt(prompt(\"请输入你的成绩\")); if (value === 100) document.write(\"A\"); else if (value &gt;= 0 &amp;&amp; value &lt; 100) &#123; switch (parseInt(value / 10)) &#123; case 9: document.write(\"A\"); break; case 8: document.write(\"B\"); break; case 7: document.write(\"C\"); break; case 6: document.write(\"D\"); break; default: document.write(\"E\"); &#125; &#125; else &#123; document.write(\"输出错误\"); &#125; 循环语句 for 循环 循环的目的是为了重复执行｛｝内的语句 123456 var i=0; while(i&lt;10)&#123; document.write(\"a\"); document.write(\"&lt;br&gt;\"); i++; &#125; 循环的必须条件 必须由起始值。 必须有一个循环条件 须有一个不断向条件外处理的语句 123456789 var str=\"\"; var i=0; str+=\"&lt;ul&gt;\"; while(i&lt;10)&#123; str+=\"&lt;li&gt;项目\"+i+\"&lt;/li&gt;\"; i++; &#125; str+=\"&lt;/ul&gt;\"; document.write(str); 循环是同步的，如果循环较长就会卡顿 123456789 console.log(\"a\"); var i=0; var s=0; while(i&lt;100000000000)&#123; s+=i; i++; &#125; console.log(\"b\"); console.log(s); 深度循环 1234567891011121314151617181920var obj=&#123; value:1,next:&#123; value:2,next:&#123; value:3,next:&#123; value:4,next:&#123; value:5,next:&#123; value:6,next:&#123; value:7 &#125; &#125; &#125; &#125; &#125; &#125; &#125; console.log(obj.value); while(obj=obj.next)&#123; console.log(obj.value); &#125; 轮盘赌算法(循环中的break) 1234567 var num=0; // 跳出，在循环中如果需要跳出循环（不再继续循环了） break while(true)&#123; num++; if(parseInt(Math.random()*10)===5) break; &#125; console.log(num); 循环中的continue 123456789 var str=\"\"; var num=47; while(num&lt;122)&#123; num++; if(num&gt;57 &amp;&amp; num&lt;65) continue; if(num&gt;90 &amp;&amp; num&lt;97) continue; str+=String.fromCharCode(num); &#125; document.write(str); 双重循环语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 var str = \"\"; var j = 0; // 设置锚点位置 AB: while (j &lt; 10) &#123; str += \"&lt;ul&gt;\"; var i = 0; while (i &lt; 10) &#123; str += \"&lt;li&gt;项目\" + i + \"&lt;/li&gt;\"; i++; // 跳出到锚点位置 if(i===4 &amp;&amp; j===4) break AB; &#125; str += \"&lt;/ul&gt;\"; j++; &#125; document.write(str); var table=\"&lt;table&gt;\"; var i=1,j=1; while(i&lt;10)&#123; table+=\"&lt;tr&gt;\"; j=1; while(j&lt;10)&#123; table+=\"&lt;td&gt;\"+i+\"*\"+j+\"=\"+i*j+\"&lt;/td&gt;\"; if(j&gt;=i) break;//跳出 j++; &#125; table+=\"&lt;/tr&gt;\"; i++; &#125; table+=\"&lt;/table&gt;\"; document.write(table); var y=2,w=0,bool; while(y&lt;100)&#123; // 用i除以1-自身之间的数值，如果没有余数，就不是素数（质数） bool=false; w=2; while(w&lt;y)&#123; if(y%w===0)&#123; bool=true; break; &#125; w++; &#125; if(!bool)&#123; console.log(y); &#125; y++; &#125; 循环的应用 打印等腰三角形 123456789101112131415 var i=0,j=0,k=0; while(i&lt;10)&#123; k=0; while(k&lt;10-i)&#123; document.write(\"&amp;ensp;\"); k++; &#125; j=1; while(j&lt;(i+1)*2)&#123; document.write(\"*\"); j++; &#125; document.write(\"&lt;br&gt;\"); i++; &#125; do while 循环 12345678910111213141516171819var i=0; do&#123; console.log(\"aa\"); i++; &#125;while(i&lt;10); // do while 是先执行语句块，再判断是否继续循环 var i=0; do&#123; console.log(\"a\"); i++; &#125;while(i&gt;0 &amp;&amp; i&lt;10); while(i&gt;0 &amp;&amp; i&lt;10)&#123; &#125; var n; do&#123; n=Math.random(); console.log(n); &#125;while(n&lt;0.5); for 循环 12345// for(初始变量;循环条件;向条件外变化的表达式)&#123;// 循环// &#125;for(var i=0;i&lt;10;i++)&#123;&#125; while循环 do whie循环 for循环的区别 12345678910111213141516171819202122232425262728var sum=0; for(var i=0;i&lt;=100;i++) sum+=i; console.log(sum); // 每次开始循环时，sum都会重置为0 // 定义变量，每次循环的开始先执行,执行一次 for(var i=0,sum=0,s=++i;i&lt;=100;i++) sum+=i; console.log(sum,s); // 条件语句，计算完成后必须转换为布尔值，是true才进入语句块 // 条件语句先判断，条件语句每次都会执行判断 for(var i=0,sum=0;i++&lt;100;) sum+=i; console.log(sum); // 变化是所有语句块运行完成后执行 // 如果使用while或者do while中continue，i++就需要写在continue的上面 for(var i=0,sum=0;i&lt;100;i++)&#123; sum+=i; if(i===20) continue; console.log(\"aa\"); &#125; console.log(sum); for(var i=0,sum=0;i&lt;=100;sum+=i++); console.log(sum); 对象的遍历 浅复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 //对象的属性 var a=3; var obj=&#123; // 创建对象时，如果key是一个变量，就需要写在[] [a]:10, // 这个a是一个字符Key a:20 &#125;; // 直接描述对象下有一个a的属性，值是1 obj.a=1; obj[\"a\"]=1;//对象[字符key]=value; // key就是属性名称，必须是字符串（ES5） var a=\"a\"; obj[a]=1;//中括号的方式是可以带入变量作为key的，点方法是不能使用变量 var s=4; obj[s]=1; var b=true; obj[b]=1; var o=&#123;a:1&#125;; obj[o]=2; var o1=&#123;a:2&#125;; console.log(obj[\"3\"]); console.log(obj.a); console.log(obj[\"a\"]); console.log(obj[\"a\"][\"b\"]); var obj=&#123; a:1, b:2, c:3, d:&#123; a:1,b:2 &#125; &#125; for(var prop in obj)&#123; // prop 就是obj下的所有属性名 key // 每循环一次就将属性名付给prop变量 console.log(prop,obj[prop]); &#125; // 浅复制 var obj1=&#123;&#125;; for(var prop in obj)&#123; obj1[prop]=obj[prop]; &#125; // 复制后切段引用关系，所以源对象属性值改变，新对象不变 obj.d.a=10; console.log(obj1); // 删除某个属性 delete obj.d; console.log(obj); 作业 表格的创建 123456789101112131415 var table=\"&lt;table&gt;\"; //table var i = 0, j = 0; while (i &lt; 10) &#123; table += \"&lt;tr&gt;\"; j = 0; while (j &lt; 10) &#123; table += \"&lt;td&gt;\" + \"&lt;/td&gt;\"; j++; &#125; table += \"&lt;/tr&gt;\" i++; &#125; table+= \"&lt;/table&gt;\"; document.write(table); 垃圾的三角形 12345678910111213141516 var i=0,j=0; while(i&lt;10)&#123; i++; var k=0; while(k&lt;(10-i))&#123; k++; document.write(\"&amp;nbsp;\"); &#125; j=1; while(j&lt;=i)&#123; j++; document.write(\"*\"); &#125; document.write(\"&lt;br&gt;\"); &#125; 垃圾的菱形 12345678910111213141516171819202122232425262728293031323334 //正三角 var i = 0; j = 0; while (i &lt; 6) &#123; i++; k = i; while (k &lt;= 5) &#123; document.write(\"&amp;nbsp;\"); k++; &#125; j = 1; while (j &lt;= i) &#123; document.write(\"*\"); j++; &#125; document.write(\"&lt;br&gt;\"); &#125; //倒三角 var i = 0; j = 0; while (i &lt; 6) &#123; i++; var k = 0; while (k &lt; i) &#123; document.write(\"&amp;nbsp;\"); k++ &#125; j = i; while (j &lt;= 5) &#123; document.write(\"*\"); j++; &#125; document.write(\"&lt;br&gt;\"); &#125; 水仙花数 123456789101112 var hundred, ten, unit, n; for (n = 100; n &lt; 1000; n++) &#123; hundred = parseInt(n / 100); ten = parseInt((n - (hundred * 100)) / 10); unit = parseInt(n % 10); if (n == ((hundred * hundred * hundred) + (ten * ten * ten) + (unit * unit * unit))) &#123; document.write(\"100-1000以内的水仙花数为\" + n + \"&lt;br&gt;\"); &#125; &#125; 弹窗计算机器 12345678910111213141516171819202122232425while(true)&#123; var num1,operator,num2,result; num1=parseInt(prompt(\"第1个数\")); num2=parseInt(prompt(\"第2个数\")); operator=prompt(\"运算符\"); if(!isNaN(num1)&amp;&amp;!isNaN(num2))&#123; switch(operator)&#123; case \"+\": result=num1+num2; break; case \"-\": result=num1-num2; break; case \"*\": result=num1*num2; break; case \"/\": result=num1/num2; break; &#125; alert(result); &#125;else&#123; alert(\"请输入正确数值\"); &#125; &#125; 阶乘 12345678910111213var num = parseInt(prompt(\"请输入一个数值\")); for(var i=num-1;i&gt;=1;i--)&#123; num*=i; &#125; document.write(num); var result = num; while (num &gt; 1) &#123; num--; result *= num; &#125; document.write(result); 判断质数 123456789101112131415161718192021222324252627282930var i, j; for (i = 100; i &lt; 1000; i++) &#123; var flag = 0; for (j =2; j &lt; i; j++) &#123; if (i % j == 0) flag++; &#125; if (flag==0) &#123; document.write(i + \"&lt;br&gt;\") &#125; &#125; var i = 100, j; var count; while (i &lt;= 1000) &#123; count = 0; i++; j = 2; while (j &lt; i) &#123; j++; if (i % j == 0) &#123; count++; &#125; &#125; if (count &lt; 2) &#123; document.write(i + \"&lt;br&gt;\"); &#125; &#125; 百钱买白鸡 123456789for (let x = 1; x &lt; 100; x++) &#123; for (let y = 1; y &lt; 100; y++) &#123; for (let z = 1; z &lt; 100; z++) &#123; if ((x + y + z === 100) &amp;&amp; (5 * x + 3 * y + z / 3 === 100)) &#123; document.write('当前 公鸡'+x+'只, 母鸡'+y+'只, 小鸡 '+z+'只'+'&lt;br&gt;'); &#125; &#125; &#125; &#125;","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"循环","slug":"循环","permalink":"https://cooli-willson.github.io/tags/%E5%BE%AA%E7%8E%AF/"},{"name":"对象","slug":"对象","permalink":"https://cooli-willson.github.io/tags/%E5%AF%B9%E8%B1%A1/"}]},{"title":"2.javascript 运算符","slug":"2.js基础-运算符","date":"2020-01-20T14:42:27.505Z","updated":"2020-01-20T17:14:12.032Z","comments":true,"path":"2020/01/20/2.js基础-运算符/","link":"","permalink":"https://cooli-willson.github.io/2020/01/20/2.js%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"算术运算符 字符相加 1234567891011121314151617181920 // 隐式转换 多种数据类型不同时，进行运算需要将这些数据转换为相同类型才能运算，这个过程就是隐式转换 var a=\"a\"; var b=\"b\"; var b=3; var b=true; var b=false; var b; var b=null; var b=&#123;a:1&#125;; // 遇到字符串相加时，另一种数据隐式转换为字符型.String() // 遇到字符串相加时，另一种数据隐式转换为字符型.String() console.log(a+b);//字符相加时，首尾相连 var age=30; var s=\"今年我\"+age+\"岁了\"; console.log(s); var s=10; s=s+\"\"; console.log(s); // 等号是赋值，因此先运算等号右边的结果，然后赋值给等号左边 布尔值相加 12345678// 布尔值相加，不包含加字符 // 布尔值转换为数值，除字符外所有内容都是隐式转换为数值运算 Number() var a=true; var b=3; var b=true; var b; var b=null; // 任何数值加NaN都为NaN 对象相加 12345678 // Object 对象相加时都会转换为字符串相加 var a=&#123;a:1&#125;; var b=&#123;b:1&#125;; console.log(a+b); var arr=[1,2,3];//数组转换为字符串时是将数组的元素转换为字符串相连 var a=&#123;a:1&#125;; console.log(arr+a); console.log([]+[]); 数值运算 12345678 // 减法 乘法 除法 取模都遵循转换为数值运算 var a=true; var b=false; var b=\"5\"; var b; var b=null; var b=&#123;a:1&#125;; console.log(a*b); 赋值运算符和一元运算符 赋值运算符 1234567891011121314// 赋值运算符 var a=3; a+=5;//a=a+5; a+=\"\";//快速转换字符串 a*=3; a/=3; a%=2; a-=2; // 赋值运算符也是有结果的 var s=a+=2; console.log(s,a); if(a-=2)&#123; console.log(\"a\"); &#125; 一元运算符 12345678910111213141516171819202122232425var a=\"3\";a++;//a=a+1 a+=1;//31a++;//一元运算符强制将值转换为数值+1var a=3;console.log(a+=1);// a=a+1 a-&gt;返回结果console.log(a++);// a-&gt;返回出来 a=a+1;console.log(++a);//a=a+1 a-&gt;返回结果// a++和++a a的结果相同 返回结果不同var y=a++;var y=++a;var x=1;if(--x)&#123; console.log(\"aa\");&#125;var x=1; x=2-3-4-5 1+2+2+3+4var y=x++ + x + x++ + x++ + x++;var y=x + ++x + x++ +x++ + x++;console.log(y,x);console.log(\"2\"&gt;\"10\"); //trueconsole.log(undefined==null); console.log(undefined&gt;null); ### 关系运算符 **关系运算符** &gt; 大小比较 12345678// &gt; &lt; &gt;= &lt;= == === != !==var a=\"aa\";var b=\"ab\";console.log(b&gt;a);//判断字符串大小时先判断字符串首字符的ascii 或者 Unicode码值,如果相同判断后面字符的比较结果console.log(true&gt;false);//隐式转换为数值console.log(true&gt;\"\");console.log(\"a\"&gt;1);//字符串与数值比较时，字符串转换为数值再比较console.log(undefined&gt;null); 辅助运算符和相等关系运算符 = 赋值 == 比较 === 精确比较 比较值和类型 123456789101112131415161718192021222324252627282930313233343536console.log(\"1\"==1);console.log(\"\"==0);console.log(0==false);console.log(\"\"==false);0==\"\"== falseundefined==null console.log(undefined==null);//判读空的结果是否相同console.log(null==\"\");//falseconsole.log(null==0);//falseconsole.log(null==false);//false// NaN永远不和任何内容相等，包括NaNvar a=\"a\";if(a==NaN)&#123; // 判断a是否是NaN // isNaN()里面的内容会自动隐式转换为数值if(isNaN(a))&#123; console.log(\"非数值\");&#125;var a;if(a==null)&#123; // undefined null console.log(\"aa\");&#125;if(a==0)&#123; // a是0 false \"\"&#125; var obj=&#123;a:1&#125;; var obj1=&#123;a:1&#125;; console.log(obj==obj1); // 引用地址不同 console.log([]==[]); console.log(\"1\"==1); console.log(\"1\"===1);//比较值和类型 // != 不相等 console.log(0!=null); console.log([]!=[]); 逻辑运算符 逻辑与 1234true &amp;&amp; true =true;true &amp;&amp; false =false;false &amp;&amp; true =false;false &amp;&amp; false =false; 逻辑或 1234true || true =true;true || false =true;false || true =true;false || false =false; 逻辑运算符与一元运算符的应用 &amp;&amp; 运算的两端，如果有一端转换为布尔值是false，就把这个值返回出去（值是什么就返回什么，不是返回false） 如果两端转换为布尔值都是true，就返回&amp;&amp;运算符右侧的值，先运行左侧再运行右侧 如果左侧运算的结果是false，直接返回左侧值，不运算右侧 + 如果||的左侧的结果是ture，就直接返回左侧，不运算右侧，熔断 12345678910111213 var a=1;a=a-- &amp;&amp; ++a;s=--a &amp;&amp; ++a;a=a++ &amp;&amp; --a;console.log(s,a);// &amp;&amp; 运算的两端，如果有一端转换为布尔值是false，就把这个值返回出去（值是什么就返回什么，不是返回false）// 如果两端转换为布尔值都是true，就返回&amp;&amp;运算符右侧的值，先运行左侧再运行右侧// 如果左侧运算的结果是false，直接返回左侧值，不运算右侧var a=1;a=--a || a++;a=a-- || a++;// 如果||的左侧的结果是ture，就直接返回左侧，不运算右侧，熔断console.log(a); &gt; 逻辑非 + !取反值，先将内容转换为布尔值，然后去反值 +所有！运算符得到的结果都是布尔值 12345678// !取反值，先将内容转换为布尔值，然后去反值console.log(!10);//falseconsole.log(!\"\");//true// 所有！运算符得到的结果都是布尔值console.log(!obj1);console.log(obj==!obj1);console.log(![]==[]);//trueconsole.log([]==[]);//false 二进制和十六进制（未详细整理） 1234567891011121314151617181920212223242526 // 数值转换二进制 0,1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 20 0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111,10000 0,1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 0,1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10 56=5*8(1)+6*8(0)=46 1010=1*2(3)+0*2(2)+1*2(1)+0*2(0)=10; 567=5*10(2)+6*10(1)+7*10(0);//16进制 RGB 0xFFFFFF 0xFF0000 0x00FF00 0x0000FF 0x000000 0xFFFF00 黄色 0xFF9900 橙色 0xFF00FF 紫色 0x00FFFF 靛色 0xFFFFFFFF 180*180 64 128 512 32400*4=129,600 console.log(Boolean(\"abc\"&gt;\"aad\")); 位运算（未详细整理） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 console.log(~3); var str=\"abcdef\"; console.log(str.indexOf(\"z\")); if(~str.indexOf(\"z\"))&#123; console.log(\"找到了z\"); &#125; // 位与运算 &amp; console.log(5&amp;6); 101 110 100=4; // 1&amp;1=1 // 1&amp;0=0 // 0&amp;1=0 // 0&amp;0=0 10101010 10 10101000 // 位或运算 | console.log(7|6); 111 110 111=7 // 1|1=1 // 1|0=1 // 0|1=1 // 0|0=0 console.log(85|1); // 位异或运算 ^ console.log(7^6); 111 110 001 // 1^1=0 // 1^0=1 // 0^1=1 // 0^0=0 var pass=7856; var key=2534; var value=pass^key; // console.log(pass^key); console.log(value^key); // &lt;&lt;左移位 &gt;&gt;右移位 console.log(24&gt;&gt;2); // 11000&gt;&gt;2 ==&gt; 110; // 8&lt;&lt;2 100000==&gt;32; // 1&lt;&lt;n 求2的多少次幂 console.log(1&lt;&lt;5); console.log( (0x0000FF&lt;&lt;16).toString(16))","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"运算符","slug":"运算符","permalink":"https://cooli-willson.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"1.javascript 基础-数据类型","slug":"1.javascript 基础-数据类型","date":"2020-01-20T13:51:37.020Z","updated":"2020-01-20T19:08:26.065Z","comments":true,"path":"2020/01/20/1.javascript 基础-数据类型/","link":"","permalink":"https://cooli-willson.github.io/2020/01/20/1.javascript%20%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"js 文件的引入 引入外部js 12&lt;script src=\"a.js\" async defer&gt;&lt;/script&gt;&lt;script src=\"b.js\"&gt;&lt;/script&gt; ES6的模块化导入 1234&lt;script type=\"module\"&gt; // ES6的模块化导入 import Box from \"./js/Box.js\"; &lt;/script&gt; 行内js的写法 123&lt;button onclick=\"alert('aaa')\"&gt;按钮&lt;/button&gt;&lt;a href=\"javascript:alert('aaa')\"&gt;超链接&lt;/a&gt;&lt;a href=\"javascript:void(0)\"&gt;超链接&lt;/a&gt; js标签 123456789 &lt;script&gt; a=10; &lt;/script&gt; &lt;script&gt; alert(b); &lt;/script&gt; &lt;script&gt; b=20;&lt;/script&gt; js注释 123456// a=3;//注释单行代码 /* a=3; b=4; */ //块状注释 // 不需要的禁止执行，注释后代码不会被执行，在以后可以复用 // 介绍说明代码作用 弹出框 123alert(\"aaa\");//弹出框confirm(\"你好\");//点击确定时返回true，否则返回falseprompt(\"请输入你的年龄\",\"18岁\");//输入弹出框，确定后会返回输入的内容 打印方式 1234console.log(\"aaaa\",\"bbbb\");//打印日志console.trace(\"aaa\");//用于显示当前执行的代码在堆栈中的调用路径。console.dir(\"aaa\");//打印部分标签内容console.error(\"错误的\");//打印错误 变量 常量和基本数据类型 变量 1234567891011a=4; b=6; // 定义变量 var a=4; var b=5; // 使用；结束一个代码语句，如果使用，表示没有结束该语句 var a=4, b=5; var a,b; // 先给a赋值，然后赋值给b var a=b=4; 变量命名规则 1234567891011121314151617181920212223242526272829303132 // 变量名称规则 // 变量要求小写字母开始，每个单词的首字母大写，叫做驼峰式命名 // var timeManager // 变量不能使用关键词和保留字 // var for; var int; // 变量尽量不要定义window的属性名，ES5中全局变量都会被设置在window的属性中 var a=10; console.log(window.a); console.log(a+5); window.status var status=20; console.log(status+5); //205 // 临时变量或者参数，起名时使用_开始 var _time=20;// 不能使用中文和拼音字母（我强制大家不能使用） var 姓名=\"谢天\"; console.log(姓名); var xingming=\"谢天\";var a=3; a=10;//值可以改变，就叫做变量 // 不希望值改变，常量ES6,常量不能修改 const EVENT_ID=\"eventid\"; EVENT_ID=\"abc\"; // 常量定义后的对象不能够被清除 const obj=&#123;a:1,b:2&#125;; 数据类型 字符型，数值型，布尔型，undefined,null,object ||E6 Symbol 五种基础类型，一种复杂类型 字符类型 1234567// 字符类型 String// \"\" '' ||ES6 `` var str1 = \"1\"; var str2 = '1'; var str3 = `1`; var str4 = \"这个'新的'鞋子价格不错\"; var str5 = '&#123;\"a\":4,\"b\":\"10\"&#125;'; 数值类型 123456789// 数值类型 Number var num1 = 1;//正整型var num2 = -1;//负整型var num3 = 1.3;//浮点型var num4 = 056;//8进制数值,0起头，数值不能大于7var num5 = 0xFF;//16进制数值，0x起头，单个数值不能大于Fvar num6 = 1.2e+3;//科学计数法var num7 = 1.2e-3;//科学计数法` 布尔类型 123// 布尔类型 Boolean var bool1 = true; var bool2 = false; 未定义型 123// 未定义型 undefined 值和类型相同 var und1; var und2 = undefined; 空值 123// 空值 null null的类型Object型 var nu = null; console.log(nu,typeof(nu)); 对象类型 123456789var obj = &#123; // 属性 id: 1001, name: \"电脑桌\", price: \"700\", getSum: function () &#123; // 方法 &#125; &#125;; 数据类型的存储 前五种基础类型都存储在栈中，对象存储在堆中 对象类型的特性 1234567891011121314151617181920212223242526var obj=&#123;a:1&#125;; console.log(String(obj));//[object Object] 所有的对象转换为字符串就会变成这样 console.log(JSON.stringify(obj));//将object对象转换为字符串（JSON字符串） console.log(JSON.parse('&#123;\"a\":1&#125;'));//将JSON字符串转换为对象 var obj1=JSON.parse(JSON.stringify(obj)); obj.a=5; console.log(obj,obj1) console.log(JSON.stringify(obj),JSON.stringify(obj1)); console.log(obj1===obj); // 变量名存储的是引用地址 var obj2=obj;//将引用地址赋值给obj2 obj.a=10; console.log(obj2.a); // 存在栈中，修改的是值 var num=3; var num1=num; num=10; console.log(num1); // 存在堆中，修改引用地址值的内容，地址不会发生改变 var obj1=JSON.parse(JSON.stringify(obj)); var obj=&#123;a:10,b:&#123;a:20&#125;&#125;; console.log(obj); obj.a=10; // 内存泄漏 不断的创建新对象，不使用的旧对象不清除 obj=null;//当给变量设置为null // 垃圾回收机制 gc 当对象的引用地址在栈中没有引用时，内存占比过高时，垃圾回收车会将其清除 数据类型的转换 任何类型转换为数值型 123456789101112131415161718192021222324252627// NaN 数值型 非数值var a=\"5\";var a=\"5a\";//字符串中如果有字符存在，转换后就变成NaNvar a=\"\";//空字符串转换为数值是 0var a=true;//1var a=false;//0var a;//undefined NaN 非数值var a=null;//0 null是0Number(值);console.log(Number(a));var a=\"52.1a\";//使用parseInt转字符串，从第一个数字字符开始到第一个字符类型为止转换为数值var a=\"a45\";//使用parseInt转字符串，从第一个数字字符开始到第一个字符类型为止转换为数值var a=\"4a5\";//使用parseInt转字符串，从第一个数字字符开始到第一个字符类型为止转换为数值var a=\"FF\";var a=\"101010010101\";color=\"#FF00FF\"--&gt;\"rgb(255,0,255)\";var a=true;//NaNvar a=false;//NaNvar a;//NaNvar a=null;//NaNvar a=&#123;a:1&#125;;console.log(Number(a));//NaN// parseInt(要转换的内容，该内容是什么进制) 将他转换为10进制数值console.log(parseInt(a,2))//转换为整型console.log(parseInt(a))//字符串转换为整型console.log(parseFloat(a))//字符串转换为浮点型 任何类型转换为字符串 1234567891011121314151617181920212223var a=10; var a=1555; var a=0; var a=0xFF; var a=4.1e+2; // 先将所有的数值都转换为10进制在转换为字符串 var a=true; var a=false; var a;//undefined var a=null;//null var a=&#123;a:1&#125;; console.log(a); console.log(String(a));//转换为字符串 // a.toString(按照什么进制转换为字符串); console.log(a.toString(36));//2-36 var a=new Date(); console.log(a.toLocaleString());//转换为本地字符串 console.log(a.toUTCString());//转换为格林尼治时间字符串 console.log(a.toString()); // toFixed toPrecision toExponential 都是针对数值转换 console.log(a.toFixed(1));//保留几位小数,会自动四舍五入 console.log(a.toPrecision(2));//总共保留几位，会自动四舍五入或者科学计数法 console.log(a.toExponential(2));//小数点后保留几位，不会自动四舍五入，一定科学计数法 任何类型转换为布尔值 1234567891011121314var a=\"\";//falsevar a=0;//falsevar a=undefined;//falsevar a=null;//falsevar a=NaN;//falsevar a=false;console.log(Boolean(a));// \"\" 0 undefined null NaN false 转换为布尔值都是false// 除上述6种以外转换为布尔值都是truevar a=\"0\";console.log(Boolean(a));var a=3;// 强转为对象类型console.log(Object(a));","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"数据类型","slug":"数据类型","permalink":"https://cooli-willson.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"通过数组方法实现的简单功能","slug":"通过数组方法实现的简单功能","date":"2020-01-19T08:04:27.014Z","updated":"2020-01-25T07:14:08.898Z","comments":true,"path":"2020/01/19/通过数组方法实现的简单功能/","link":"","permalink":"https://cooli-willson.github.io/2020/01/19/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%9F%E8%83%BD/","excerpt":"","text":"实现功能 去重 原生版 12345678910111213141516var arr=[1,2,2,4,3,4,5,4,2,6,2,7]; var arr1=[]; for(var i=0;i&lt;arr.length;i++)&#123; //遍历当前数组的长度 var bool=false; //flag for(var j=0;j&lt;arr1.length;j++)&#123; //循环arr1长度 if(arr[i]===arr1[j])&#123; //当arr的元素全等于arr1 bool=true; //改变flag的布尔值 break; //跳出循环 &#125; &#125; if(!bool)&#123; arr1.push(arr[i]); //将arr的元素赋值给arr1 &#125; &#125; arr=arr1.splice(0); arr1=null; 去重indexOf版 123456789 var arr=[1,2,2,4,3,4,5,4,2,6,2,7]; var arr1=[]; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr1.indexOf(arr[i])&lt;0) arr1.push(arr[i]); //当arr下的每个元素在index属性下返回负一时 将元素储存在arr1中 ？？？ &#125; arr=arr1.splice(0); arr1=null; console.log(arr); 去重delete版 123456789101112var arr=[1,2,2,4,3,4,5,4,2,6,2,7]; for(var i=1;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr.indexOf(arr[i],i+1)&gt;-1) delete arr[i]; //要查找的元素下标为i,从i+1开始，当找到相同元素时，将下标为i的元素删除 if(arr.lastIndexOf(arr[i],i-1)&gt;-1) delete arr[i]; //倒叙遍历，重复以上操作 &#125; var arr1=[]; //空数组arr1; for(var prop in arr)&#123; //循环arr的长度 arr1.push(arr[prop]); //将arr的元素储存在arr1中 &#125; arr=arr1.splice(0); //将arr数组的所有元素传递给arr1 arr1=null; //清空数组arr1 console.log(arr); //控制台打印arr 数组的遍历 for循环遍历 123456var arr=[1,2,3,,4,5,6]; arr.a=3; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 console.log(i,arr[i]); //打印下标 和下标的每个元素 &#125; for in循环遍历 12345for in 循环可以把数组的可枚举属性遍历到for in不能遍历到数组的空元素 for(var prop in arr)&#123; //prop相当于数组的下标 console.log(prop,arr[prop]); //打印下标，和下标的每个元素 &#125; 将获取的标签元素转换为数组类型 123456789// ES6var list=Array.from(inputs);console.log(list);// ES5var list=Array.prototype.slice.call(inputs);var list=[].slice.call(inputs);var list=Array.prototype.concat.apply([],inputs);var list=[].concat.apply([],inputs); 实现列表的全选功能??? 12345678910111213141516171819202122232425262728293031323334&lt;ul&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;全选&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;/ul&gt; var inputs=document.getElementsByTagName(\"input\"); //将获取的input标签的元素储存在inputs中 var arr=Array.from(inputs); //将获取的标签元素转换为数组类型 for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 arr[i].onclick=clickHandler; //当点击时调用clickHandler函数 &#125; function clickHandler()&#123; var self=this; //将当前元素用self存储 if(arr.indexOf(this)===0)&#123; //当前元素为0时 arr.forEach(function(item,index)&#123; if(index===0) return; //当前元素下标为0时 返回 // foreach中this被重新指向到window（所有的回调函数） item.checked=self.checked; //将所有元素都天机checked属性 &#125;) &#125;else&#123; arr[0].checked=arr.slice(1).every(function(item)&#123; //？？？ return item.checked; //??? &#125;) &#125; &#125; 对表格中的商品通过属性进行筛选 123456789101112131415161718192021var data=[ &#123;id:1001,icon:\"img/1.png\",name:\"餐饮0\",num:1,price:10&#125;, &#123;id:1002,icon:\"img/2.png\",name:\"餐饮1\",num:1,price:20&#125;, &#123;id:1003,icon:\"img/3.png\",name:\"餐饮2\",num:1,price:30&#125;, &#123;id:1004,icon:\"img/4.png\",name:\"餐饮3\",num:1,price:40&#125;, &#123;id:1005,icon:\"img/5.png\",name:\"餐饮4\",num:1,price:50&#125;, &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;, &#123;id:1007,icon:\"img/7.png\",name:\"餐饮6\",num:1,price:70&#125;, &#123;id:1008,icon:\"img/8.png\",name:\"餐饮7\",num:1,price:80&#125;, &#123;id:1009,icon:\"img/9.png\",name:\"餐饮8\",num:1,price:90&#125;, &#123;id:1010,icon:\"img/10.png\",name:\"餐饮9\",num:1,price:100&#125;];var arr=data.filter(function(item)&#123; return item.price&gt;60; //返回所有价格&gt;60的元素&#125;)console.log(arr);var item=data.filter(function(item)&#123; return item.id==1006; //返回id==1006的元素&#125;)[0];console.log(item); 实现购物车功能 12345678910111213141516171819202122var data=[ &#123;id:1001,icon:\"img/1.png\",name:\"餐饮0\",num:1,price:10&#125;, &#123;id:1002,icon:\"img/2.png\",name:\"餐饮1\",num:1,price:20&#125;, &#123;id:1003,icon:\"img/3.png\",name:\"餐饮2\",num:1,price:30&#125;, &#123;id:1004,icon:\"img/4.png\",name:\"餐饮3\",num:1,price:40&#125;, &#123;id:1005,icon:\"img/5.png\",name:\"餐饮4\",num:1,price:50&#125;, &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;, &#123;id:1007,icon:\"img/7.png\",name:\"餐饮6\",num:1,price:70&#125;, &#123;id:1008,icon:\"img/8.png\",name:\"餐饮7\",num:1,price:80&#125;, &#123;id:1009,icon:\"img/9.png\",name:\"餐饮8\",num:1,price:90&#125;, &#123;id:1010,icon:\"img/10.png\",name:\"餐饮9\",num:1,price:100&#125; ]; data.forEach(function(item)&#123; //遍历整个数组 item.selected=Math.random()&lt;0.5; //随机选择被选中的元素 item.num=parseInt(Math.random()*5+5); //给num属性随机赋值 item.total=item.num*item.price; //将数量和价格相乘得出的结果付给tatal（总价） &#125;); var sum=data.reduce(function(value,item)&#123; //归并data并且赋值到sum中 return item.selected ? value+item.total : value; //若选中就加到vale中，没有选则不加 &#125;,0); console.log(sum);","categories":[{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/categories/%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/tags/%E5%8A%9F%E8%83%BD/"},{"name":"数组","slug":"数组","permalink":"https://cooli-willson.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"数组方法的重构","slug":"数组方法的重构","date":"2020-01-19T08:04:24.522Z","updated":"2020-01-20T17:14:16.491Z","comments":true,"path":"2020/01/19/数组方法的重构/","link":"","permalink":"https://cooli-willson.github.io/2020/01/19/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E6%9E%84/","excerpt":"","text":"数组方法的重构 push 功能： *在数组尾部添加一个或者多个新元素，并且返回数组的新长度 使用方法： 1arr.push(5,6,7); push 重构 123456789var arr=[1,2,4,5,67,78];function push(arr)&#123; //传入参数为数组 for(var i=1;i&lt;arguments.length;i++)&#123; //循环除数组外其他元素的长度 arr[arr.length]=arguments[i]; //在尾部添加参数通过下标赋值 &#125; return arr.length; //返回数组长度 &#125;var i=push(arr,5,6,7); //调用push方法，参数为数组，5，6，7console.log(arr,i); */ //数组长度，新数组 pop 功能： #### *删除数组的**尾部**元素，并且返回这个**被删除的元素** 使用方法： 12// var item=arr.pop();// console.log(item,arr); pop 重构 1234567function pop(arr)&#123; var item=arr[arr.length-1]; //用item储存最后一个参数 arr.length--; //数组的长度减一 return item; //返回这个被删除的参数 &#125;pop(arr); unshift 功能： *将一个或者多个新元素添加在数组的最前面，返回数组的新长度 使用方法： 1arr.unshift(1,2,3); unshift 重构 12345678910111213function unshift(arr)&#123; var len=arguments.length-1; //len储存除数组以外的其他元素的长度 for(var i=arr.length-1;i&gt;=0;i--)&#123; //循环当前数组的长度 arr[i+len]=arr[i]; //将当前数组的元素向后移 &#125; for(var j=1;j&lt;arguments.length;j++)&#123; //循环参数的长度（除arr外） arr[j-1]=arguments[j]; //将参数赋值给数组的前面 &#125; return arr.length; //返回数组的新长度 &#125; unshift(arr,10,11,12); console.log(arr); shift 功能： 删除数组的第一个元素，并返回该元素 使用方法 1arr.shift(); shift 重构 123456789101112function shift (arr) &#123; if (!(arr instanceof Array)) throw new Error(\"请确保参数类型为数组\") //判断传入参数是否为数组 var el; if (arr.length &gt; 0) &#123; //如果数组有长度 el = arr[0] //将第一个元素储存在el中 for (var i = 0; i &lt; arr.length - 1; i++) &#123; //循环数组的长度 arr[i] = arr[i + 1] //将数组的每个元素前移一位 &#125; arr.length = arr.length - 1 //数组的长度减一 &#125; return el&#125; concat 功能： *复制，复制后给新数组添加新元素，多个数组连接形成数组 使用方法 123var arr=[1,2,3,4];var arr1=arr.concat(10,11,12); //连接形成新数组var arr1=arr.concat(); //复制数组 concat 重构??? 123456789101112131415161718function concat(arr)&#123; var array=[]; //定义一个新数组 var index=0; //下标变量 for(var i=0;i&lt;arr.length;i++,index++)&#123; // 循环数组的长度 array[index]=arr[i]; //将数组复制arr数组到array数组 &#125; for(var j=1;j&lt;arguments.length;j++,index++)&#123; //遍历参数的长度(除数组外) if(arguments[j].constructor===Array)&#123; //当参数为数组时 for(var k=0;k&lt;arguments[j].length;k++,index++)&#123; //遍历数组的长度 array[index]=arguments[j][k]; //将参数为数组的参数赋值给 &#125; index--; &#125;else&#123; array[index]=arguments[j]; &#125; &#125; return array; &#125; join 功能： *转换为字符串，使用参数进行分割 使用方法 123console.log(arr.join()); console.log(arr.join(\"#\"));//1#2#3#4console.log(arr.join(\"\"));//1234 join 重构（myself） 123456789function join(arr,and)&#123; //参数为数组和连接符 for(var i = 0; i&lt;arr.length-1;i++)&#123; //循环数组长度 arr[i]+=and; //数组加入连接符 &#125; return arr; &#125; var arr = [3, 1, 6, 5, 4, 8, 9]; join(arr,\"|\"); document.write(arr); splice 功能： *给数组中添加、删除、替换一个或者多个元素，返回被删除元素组成的数组 使用方法 12345678910111213141516// arr.splice(从什么位置开始,删除多少个元素,添加的元素...); // var arr1=arr.splice();//创建一个空数组// var arr1=arr.splice(0);//将数组的所有元素传递给新数组// 负数指从后向前数// var arr1=arr.splice(-2);//从数组的倒数第二位开始截取到尾部// var arr1=arr.splice(2,2);//从第二位开始删除2个元素// var arr1=arr.splice(ar2,0,12,14);//插入元素13，14，插入在第二位// var arr1=arr.splice(2,2,12,14);//替换元素，删除两位并且插入12，14// console.log(arr1,arr); splice 重构 1234567891011121314151617181920212223242526function splice(arr,start,count)&#123; //第一个参数是数组 第二个参数是开始位置 第三个参数是一共替换几个参数 var a=[]; //定义一个空数组 start=Number(start); //将开始参数设为数值型 count=Number(count); //将count转为数值型 if(isNaN(start))return a; //如果start为NaN 返回空数组 if(start&lt;0) start+=arr.length; //如果start小于0 start等于数组长度 数据从最后一位开始插入 if(isNaN(count)) count=arr.length-start; //？？？ for(var i=start,j=0;i&lt;arr.length;i++,j++)&#123; //遍历从start位置开始长度小于数组的长度 if(j&lt;count) a.push(arr[i]); //当循环次数小于count参数时储存在arr当前下标位置 arr[i]=arr[i+count]; //arr当前下标的值等于i+count; &#125; for(var l=0;l&lt;arguments.length-3;l++)&#123; //遍历处前三个参数外其他参数的值 for(var m=arr.length-1;m&gt;=start+l;m--)&#123; //??? arr[m+1]=arr[m]; //??? &#125; &#125; for(var n=3;n&lt;arguments.length;n++)&#123; //循环参数的长度 arr[start+n-3]=arguments[n]; //设定参数在数组中的下标赋值 &#125; for(var k=0;k&lt;count;k++)&#123; //替换时减去数组的长度 arr.length--; &#125; return a; &#125; var arr1=splice(arr,2,2,10,11,12); console.log(arr1,arr); slice 功能： *截取数组的某一段的值，返回一个新数组，原数组不改变 使用方法 1234567// var arr1=arr.slice();//复制一个新数组 // var arr1=arr.slice(1);//从第几项复制到尾部 // var arr1=arr.slice(-2);//从倒数第二位复制到尾部 // var arr1=arr.slice(2,3);//从第二位复制到第三位之前 // var arr1=arr.slice(-3,-1);//从倒数第三位复制到倒数第一位之前 // var arr1=arr.slice(2,-1);//从第二位复制到倒数第一位之前 // console.log(arr1,arr); slice 重构 123456789101112131415function slice(arr,start,end)&#123; //第一个参数为数组 第二个值为开始截取位置 start=Number(start); //将参数转为数值型 end=Number(end); //将参数转为数值型 if(isNaN(start)) start=0; //如果start为NaN 将strat变为0； if(isNaN(end)) end=arr.length; //如果end为NaN if(start&lt;0) start=start+arr.length; //如果参数为0,start为数组的长度 if(end&lt;0) end=end+arr.length; //如果参数为0，end为数组的长度 var a=[]; for(var i=start,j=0;i&lt;end;i++,j++)&#123; //循环开始到结束的下标 a[j]=arr[i]; //将截取的数组赋值给新数组a &#125; return a; //返回新数组 &#125; var arr1=slice(arr,2,-1); console.log(arr1,arr); indexOf 功能： *查找元素在数组中的下标，如果没有查找到返回-1 使用方法 1234567891011 //从前向后查找arr.indexOf(要查找的元素,从第几位开始查找被包含);console.log(arr.indexOf(3,2)); // 从后向前查找arr.lastIndexOf(要查找的元素,从第几位开始查找被包含); var index=-1;while(~(index=arr.indexOf(2,index+1)))&#123; //~加一取反 循环条件也是表达式 console.log(index)&#125; indexOf重构 1234567891011121314151617181920212223function CreateString(str)&#123; var obj = &#123; data: str, //indexOf 方法 IndexOf: function (chara1) &#123; for (var i = 0; i &lt; this.data.length; i++) &#123; if (str.substr(i, chara1.length) == chara1&#123; break; &#125; &#125; return i; &#125;, //lastIndexOf 方法 LastIndexOf: function (chara2) &#123; for (var i = this.data.length; i &gt; 0; i--) &#123; if (this.data.substr(i, chara2.length) == chara2) &#123; break; &#125; &#125; return i; &#125; &#125;&#125; delete 功能： #### *删除数组元素，不会造成数组的自动收缩，紧密，数组的长度不会发生改变 使用方法： 123var arr=[1,2,3,4,5,6];delete arr[2];console.log(arr); forEach循环 功能： *forEach不遍历空元素，也不遍历属性，forEach是匿名函数，无法阻止它在循环中中断循环跳出 使用方法： 12345var arr=[2,4,6,8,10,,12,14,16,18,20]; arr.a=10;arr.forEach(function(item,index,a)&#123; //item:当前元素 index:当前元素的下标 当前元素所属的数组对象 console.log(item,index,a);&#125;); forEach重构 1234567891011function forEach(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr[i]===undefined) continue; //当前元素为空时，直接执行下一次循环 fn(arr[i],i,arr); //fn参数为：当前元素，当前元素下标，当前元素的数组对象 &#125; &#125; // 桥接模式forEach(arr,function(item,index,a)&#123; //调用forEach函数 console.log(item,index,a); //打印每个参数值&#125;) */ map 功能： 1map同样不会遍历空数组，map与forEach不同的是：forEach不能返回任何内容，map会将回到函数中return的结果返回到新数组中 使用方法： 12345var a=arr.map(function(item,index,a)&#123; console.log(item,index,a); return item; &#125;);console.log(a); 重构map 12345678910111213function map(arr,fn)&#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr[i]===undefined) continue; //当前元素为空时直接进行下一次循环 a[i]=fn(arr[i],i,arr); //将函数fn存放在数组中 &#125; return a; //返回数组a,元素为每个函数 &#125; var a=map(arr,function(item,index,a)&#123; return item; &#125;); console.log(a); some 功能： 遍历数组，查找是否有满足条件（返回的结果如果是true）就直接跳出遍历，返回true 使用方法: 12345678910var arr=[1,2,3,4,5,6]; if(arr.some(function(item)&#123;item&gt;3&#125;))&#123; //遍历arr,查询元素是否有大于3的，有的话返回true &#125; var bool=arr.some(function(item,index,a)&#123; return item&gt;4; //遍历arr,查询元素是否有大于4的，有的话返回ture &#125;) console.log(bool); //打印结果为ture some重构 123456789101112function some(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr[i]===undefined) continue; //如果数组的元素为空，直接执行下一次的循环 if(fn(arr[i],i,arr)) return true; //如果fn函数的返回值为ture 返回ture &#125; return false; //当第二个if语句条件不成立时，返回flase &#125; var bool=some(arr,function(item)&#123; //执行some函数，返回值储存在bool中 return item&gt;10; //判断表达式的值并返回 &#125;) console.log(bool); every 功能： *判断每一个是否都满足条件，如果有一个返回的结果是false，直接返回false 使用方法： 1234var bool=arr.every(function(item)&#123; return item&gt;4; &#125;); console.log(bool); every重构 1234567891011function every(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; if(!fn(arr[i],i,arr)) return false; //当条件不满足时返回false &#125; return true; &#125; var bool=every(arr,function(item)&#123; return item&gt;4; //返回boolean值类型 &#125;); console.log(bool); fill 功能： *用于将一个固定数值替换数组的元素 使用方法： 123456789101112131415array.fill(value, start, end)参数 描述value 必需。填充的值。start 可选。开始填充位置。end 可选。停止填充位置 (默认为 array.length)填充 \"Runoob\" 到数组的最后两个元素：var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.fill(\"Runoob\", 2, 4);输出结果：Banana,Orange,Runoob,Runoob fill重构 12 filter 功能： *创建一个新的数组，新数组中的元素时通过检查置顶数组中符合条件的所有元素 注意： filter() 不会对空数组进行检测。 注意： filter() 不会改变原始数组。 使用方法： 123456789101112var arr1=arr.filter(function(item,index,a)&#123; // console.log(item,index,a); return item&gt;4; //当条件成立时返回 &#125;); console.log(arr1); array.filter(function(currentValue,index,arr), thisValue);参数 描述currentValue 必须。当前元素的值index 可选。当前元素的索引值arr 可选。当前元素属于的数组对象 filter 重构 123456789101112function filter(arr,fn)&#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(fn(arr[i],i,arr)) a[a.length]=arr[i]; //将在arr数组中满足条件的元素储存到a数组中 &#125; return a; &#125; var arr1=filter(arr,function(item)&#123; return item&gt;4 //符合表达式的进行返回 &#125;); console.log(arr1); reduce 功能： 归并 arr.reduce(function(上次归并值，本次遍历的元素，索引值，数组),初始化值)； 如果没有设置初始化值，上次归并值初始值为数组的第0项，本次遍历将从下标1开始 如果设置了初始化值，上次归并值初始值就是初始化值，本次遍历将从下标0开始* 使用方法： 1234567//arr.reduce(function(上次归并值，本次遍历的元素，索引值，数组),初始化值)； var arr=[1,2,3,4,5]; var sum= arr.reduce(function(value,item,index,a)&#123; //上次归并值，本次遍历的元素，下标，数组 console.log(value,item); return value+item; //返回归并值 &#125;,100); //初始化值为100 console.log(sum); */ reduce 重构 12345678910111213141516171819202122function reduce(arr,fn,initValue)&#123; //参数为 数组 初始化值 var start=0; if(initValue===undefined)&#123; //如果初始化值未定义 initValue=arr[0]; //将数组的第一个元素设为初始化值 start++; &#125; for(var i=start;i&lt;arr.length;i++)&#123; //当初始化值为第一个元素时，从第二个开始归并 initValue=fn(initValue,arr[i],i,arr) //桥接模式 &#125; return initValue; //返回初始值也就是归并值 &#125; var arr=[1,2,3,4]; var sum=reduce(arr,function(value,item)&#123; return value+item; //返回归并值 &#125;,100); console.log(sum); var sum=arr.reduce(function(value,item)&#123; //调用归并函数 console.log(value); &#125;,null) reverse 功能： * 倒序，不排序，原数组改变，返回原数组 使用方法 123var arr=[1,4,6,2,3,8,7,6,5,3,9];arr.reverse();console.log(arr); reverse 重构 1234567891011121314function reverse(arr)&#123; var len=parseInt(arr.length/2); //长度为数组长度的1/2 for(var i=0;i&lt;len;i++)&#123; //循环一数组1/2的长度 // arr[arr.length-1-i]=arr[i]; var temp=arr[arr.length-1-i]; //将最后一位赋值给临时变量 arr[arr.length-1-i]=arr[i]; //将第一位赋值给最后一位 arr[i]=temp; //将临时变量的值赋给第一位 &#125; return arr; //返回这个数组 &#125; reverse(arr); console.log(arr); sort 功能： *用于对数组的元素进行排序 使用方法： 123456789arrayObject.sort(sortby);参数 描述sortby 可选。规定排序顺序。必须是函数。arr.sort(); //按照ASCII码值进行排序 arr.sort(function(a,b)&#123; return a-b; //从大到小排列 &#125;) console.log(arr); sort重构 冒泡排序： 123456789101112131415161718192021222324252627282930var arr=[]; for(var i=0;i&lt;100;i++)&#123; arr.push(i); //创建一个1-100的数组 &#125; arr.sort(function()&#123; return Math.random()-0.5; //将数组的元素设为随机数 &#125;);// 冒泡排序// 1、从后向前循环// 2、内部从前向后循环到外层变量// 3、判断前值是否大于后值，交换 function sort1(arr)&#123; var len=arr.length; //循环数组的长度 while(len&gt;0)&#123; //当len小于0时停止循环 for(var i=0;i&lt;len;i++)&#123; //循环的长度不断减小 if(arr[i]&gt;arr[i+1])&#123; //当第一位比第二位大时 var temp=arr[i]; //当前元素存放到临时变量中 arr[i]=arr[i+1]; //将下一位元素赋值给当前元素 arr[i+1]=temp; //将临时变量赋给 &#125; &#125; len--; &#125; &#125; sort1(arr); console.log(arr); 选择排序 1234567891011121314151617181920212223242526272829var arr=[]; for(var i=0;i&lt;100;i++)&#123; arr.push(i); //创建一个1-100的数组 &#125; arr.sort(function()&#123; return Math.random()-0.5; //将数组的元素设为随机数 &#125;); // 选择排序// 先找出最小或者最大的索引值，然后用当前的下标的元素与这个最小的元素交换// 1、遍历数组// 2、设置最小的索引值为当前的索引值// 3、从当前的下一项开始遍历到数组的尾部// 4、判断所有遍历的值中最小的值得索引值 // 5、交换当前值和最小索引值的元素 function sort2(arr)&#123; var minIndex; //设置一个最小数的变量 for(var i=0;i&lt;arr.length;i++)&#123; //从第一个数开始循环 minIndex=i; //将第一个数预设为最小数 for(var j=i+1;j&lt;arr.length;j++)&#123; //从第二个数开始循环 minIndex=arr[minIndex]&lt;arr[j] ? minIndex : j; //比较前一位与后一位的值 将小的值存放到minIndex中 &#125; var temp=arr[i]; //将两个值进行交换 将最小的值存放在a[minIndex]中 arr[i]=arr[minIndex]; arr[minIndex]=temp; &#125; &#125; sort2(arr); console.log(arr); 快速排序 123456789101112131415 var arr=[1,4,2,2,3,10]; arr=sort3(arr); function sort3(arr)&#123; if(arr.length&lt;=1) return arr; var left=[]; var right=[]; var item=arr.splice(parseInt(arr.length/2),1)[0]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;item) left.push(arr[i]); else right.push(arr[i]); &#125; var arr1=sort3(left).concat(item,sort3(right)); return arr1; &#125;","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"数组","slug":"数组","permalink":"https://cooli-willson.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"重构","slug":"重构","permalink":"https://cooli-willson.github.io/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"pure主题使用方法","slug":"pure主题使用方法","date":"2020-01-19T07:07:33.135Z","updated":"2020-01-20T17:14:37.980Z","comments":true,"path":"2020/01/19/pure主题使用方法/","link":"","permalink":"https://cooli-willson.github.io/2020/01/19/pure%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"pure主题","slug":"pure主题","permalink":"https://cooli-willson.github.io/categories/pure%E4%B8%BB%E9%A2%98/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"https://cooli-willson.github.io/tags/hello-world/"},{"name":"pure","slug":"pure","permalink":"https://cooli-willson.github.io/tags/pure/"}]}]}