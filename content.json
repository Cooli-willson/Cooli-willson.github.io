{"meta":{"title":"Wilson'bolg","subtitle":"","description":"","author":"Wilson","url":"https://cooli-willson.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-01-20T16:36:03.439Z","updated":"2020-01-20T16:36:03.439Z","comments":false,"path":"/404.html","permalink":"https://cooli-willson.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-01-20T16:36:03.439Z","updated":"2020-01-20T16:36:03.439Z","comments":false,"path":"books/index.html","permalink":"https://cooli-willson.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-01-20T16:36:03.439Z","updated":"2020-01-20T16:36:03.439Z","comments":false,"path":"about/index.html","permalink":"https://cooli-willson.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2020-01-20T16:36:03.440Z","updated":"2020-01-20T16:36:03.440Z","comments":true,"path":"links/index.html","permalink":"https://cooli-willson.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-20T16:34:58.656Z","updated":"2020-01-20T16:34:58.656Z","comments":true,"path":"tags/index.html","permalink":"https://cooli-willson.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-01-20T17:07:20.316Z","updated":"2020-01-20T17:07:20.316Z","comments":true,"path":"repository/index.html","permalink":"https://cooli-willson.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-01-20T16:39:48.082Z","updated":"2020-01-20T16:39:48.082Z","comments":true,"path":"categories/index.html","permalink":"https://cooli-willson.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"倒计时功能","slug":"倒计时功能","date":"2020-01-22T16:39:05.532Z","updated":"2020-01-22T16:39:51.993Z","comments":true,"path":"2020/01/23/倒计时功能/","link":"","permalink":"https://cooli-willson.github.io/2020/01/23/%E5%80%92%E8%AE%A1%E6%97%B6%E5%8A%9F%E8%83%BD/","excerpt":"","text":"倒计时功能 12345input &#123; text-align: right; &#125; 12345 &lt;input type=\"text\" id=\"hour\"&gt;小时 &lt;input type=\"text\" id=\"minute\"&gt;分钟 &lt;input type=\"text\" id=\"second\"&gt;秒 &lt;button id=\"bn\"&gt;开始&lt;/button&gt; &lt;div id=\"div0\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142 var preset,inputs; init(); function init()&#123; inputs=document.getElementsByTagName(\"input\"); var bn=document.getElementById(\"bn\"); var div=document.getElementById(\"div0\"); for(var i=0;i&lt;inputs.length;i++)&#123; inputs[i].oninput=inputHandler; &#125; setInterval(animation,500,div); bn.onclick=clickHandler; &#125; function inputHandler()&#123; this.value=this.value.replace(/\\D/g,\"\"); &#125; function clickHandler()&#123; preset=new Date(); preset.setHours(preset.getHours()+Number(inputs[0].value)); preset.setMinutes(preset.getMinutes()+Number(inputs[1].value)); preset.setSeconds(preset.getSeconds()+Number(inputs[2].value)); setDisabled(true); &#125; function animation(elem)&#123; if(!preset) return; var date=new Date(); var time=preset-date; if(time&lt;0)&#123; preset=null; setDisabled(false); return; &#125; time=time/1000; var h=time&gt;=3600 ? parseInt(time/3600) : 0; var m=time&gt;=60 ? parseInt((time-h*3600)/60) : 0; var s=parseInt(time-h*3600-m*60); elem.innerHTML=h+\"小时\"+m+\"分\"+s+\"秒\"; &#125; function setDisabled(bool)&#123; for(var i=0;i&lt;inputs.length;i++)&#123; inputs[i].disabled=bool; &#125; &#125;","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"字符串","slug":"字符串","permalink":"https://cooli-willson.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"获取中文时间","slug":"获取中文时间","date":"2020-01-22T16:38:42.439Z","updated":"2020-01-22T16:38:50.567Z","comments":true,"path":"2020/01/23/获取中文时间/","link":"","permalink":"https://cooli-willson.github.io/2020/01/23/%E8%8E%B7%E5%8F%96%E4%B8%AD%E6%96%87%E6%97%B6%E9%97%B4/","excerpt":"","text":"获取中文时间 1&lt;div id=\"div0\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839 var arr=[\"零\",\"一\",\"二\",\"三\",\"四\",\"五\",\"六\",\"七\",\"八\",\"九\"]; init(); function init()&#123; var div=document.getElementById(\"div0\"); setInterval(animation,500,div); &#125; function animation(elem)&#123; var date=new Date(); var time=\"\"; time+=getYearCN(date.getFullYear()); time+=getCNNumber(date.getMonth()+1)+\"月\"; time+=getCNNumber(date.getDate())+\"日&amp;emsp;\"; time+=\"星期\"+(date.getDay()===0 ? \"日\" : getCNNumber(date.getDay()))+\"&amp;emsp;\"; time+=getCNNumber(date.getHours())+\"点\"; time+=getCNNumber(date.getMinutes(),true)+\"分\"; time+=date.getSeconds()===0 ? \"\" : getCNNumber(date.getSeconds(),true)+\"秒\"; elem.innerHTML=time; &#125; function getYearCN(year)&#123; var y=\"\"; year=String(year); for(var i=0;i&lt;year.length;i++)&#123; y+=arr[year[i]]; &#125; return \"公元\"+y+\"年\"; &#125; function getCNNumber(n,bool)&#123; if(n&lt;0 || n&gt;1000) return \"错误的消息\"; if(n&lt;10) return bool ? \"零\"+arr[n] : arr[n]; if(n===10) return \"十\"; if(n&lt;20) return \"十\"+arr[String(n)[1]]; if(n&gt;=100 &amp;&amp; n%100===0) return arr[String(n)[0]]+\"百\"; if(n&gt;100 &amp;&amp; n%10===0) return arr[String(n)[0]]+\"百\"+arr[String(n)[1]]+\"十\"; if(n%10===0) return arr[String(n)[0]]+\"十\"; if(n&lt;100) return arr[String(n)[0]]+\"十\"+arr[String(n)[1]]; if(n%100&lt;10) return arr[String(n)[0]]+\"百零\"+arr[String(n)[2]]; return arr[String(n)[0]]+\"百\"+arr[String(n)[1]]+\"十\"+arr[String(n)[2]]; &#125;","categories":[],"tags":[]},{"title":"特殊数组和字符串","slug":"6.特殊数组和字符串","date":"2020-01-22T16:36:58.776Z","updated":"2020-01-22T16:39:58.954Z","comments":true,"path":"2020/01/23/6.特殊数组和字符串/","link":"","permalink":"https://cooli-willson.github.io/2020/01/23/6.%E7%89%B9%E6%AE%8A%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"特殊数组和字符串 复杂型数组 二维数组 123456789 var arr=[]; for(var i=0;i&lt;10;i++)&#123; arr[i]=[]; for(var j=0;j&lt;10;j++)&#123; arr[i][j]=i*10+j; &#125; &#125; // 行列唯一对应值 console.log(arr); 对象型数组 1234567891011121314 var data=[ &#123;id:1001,icon:\"img/1.png\",name:\"餐饮0\",num:1,price:10&#125;, &#123;id:1002,icon:\"img/2.png\",name:\"餐饮1\",num:1,price:20&#125;, &#123;id:1003,icon:\"img/3.png\",name:\"餐饮2\",num:1,price:30&#125;, &#123;id:1004,icon:\"img/4.png\",name:\"餐饮3\",num:1,price:40&#125;, &#123;id:1005,icon:\"img/5.png\",name:\"餐饮4\",num:1,price:50&#125;, &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;, &#123;id:1007,icon:\"img/7.png\",name:\"餐饮6\",num:1,price:70&#125;, &#123;id:1008,icon:\"img/8.png\",name:\"餐饮7\",num:1,price:80&#125;, &#123;id:1009,icon:\"img/9.png\",name:\"餐饮8\",num:1,price:90&#125;, &#123;id:1010,icon:\"img/10.png\",name:\"餐饮9\",num:1,price:100&#125;]; var obj= &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;; console.log(data.indexOf(obj)); flatMap 以及重构 123456789101112131415161718192021 var arr = [ [1, 2, 3], [4, 5, 6], 7, 8, 9 ]; // var arr1=arr.flatMap(function(item,index,a)&#123; // return item; // &#125;) // console.log(arr1); function flatMap(arr, item) &#123; //第一个参数为遍历数组，第二个元素为新数组 for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i].constructor===Array)&#123; // if(Array.isArray(arr[i]))&#123; //第二种当前元素是否为数组的方式 if(arr[i]) flatMap(arr[i], item); //当前元素为数组时使用递归的方式继续遍历内数组 &#125; else &#123; item.push(arr[i]); //将每个元素push到item中去 &#125; &#125; return item; &#125; console.log(flatMap(arr, [])); 使用方法的方式 1234567891011121314 var arr=new Array(1,2,3); // 实例化方法 arr.forEach(function()&#123; &#125;); // 静态方法 Array.isArray(); // 把构造函数看成对象，增加的方法 Array.from(); // static //数学方法 Math // Math全部都是静态属性和方法 Math是一种静态类 // 该类别不能实例化 var math=new Math();//错误 console.log(math); math方法的使用 123456789101112131415161718192021222324252627282930 console.log(Math.PI); console.log(Math.SQRT2); console.log(Math.abs(-5));//绝对值 if(a&lt;0) a=-a; console.log(0.1+0.2===0.3); Math.round(3.2);//四舍五入 console.log(Math.round(-3.6)); console.log(Math.round(-4+0.5)); console.log(Math.floor(3.6));//向下取整 3 console.log(Math.ceil(3.2));//向上取整 4 console.log(Math.max(3,5,7,8));//8 求最大值 console.log(Math.min(3,5,7,8));//3 求最小值 var arr=[1,2,3,4,5,6,10]; console.log(Math.max.apply(null,arr));//求数组中的最大值 console.log(Math.min.apply(null,arr));//求数组中的最小值 console.log(Math.sqrt(9))//平方根 console.log(Math.pow(2,2)); console.log(Math.pow(2,32)); console.log(Math.pow(4,0.5));//平方根 console.log(Math.pow(4,1/3));//立方根 console.log(1&lt;&lt;32); // Math.random() 随机值 0-1 console.log(Math.random()); console.log(Math.floor(Math.random()*50)); console.log(Math.ceil(Math.random()*50)); function random(min,max)&#123; return Math.floor(Math.random()*(max-min))+min; &#125; console.log(random(50,150)); String基础 不同声明或者使用方式储存的位置也是不同的 123456789101112131415161718 var str = \"abcdefghijk\"; var str='abc'; var str=`abc`; var str=String(\"abc\");//存在栈中 var str1=new String(\"abc\");//字符型对象，存在堆中的 var str2=new String(\"abc\");//字符型对象，存在堆中的 console.log(str2===str1);//不相等 console.log(str[0]);//获取字符串的下标是0的字符 str[0]=10; // str[0] 是只读，不能设置值 // str.length 长度，只读，只能获取字符串的字符个数 var len=str.length-1; var str1=\"\"; while(len&gt;=0)&#123; str1+=str[len]; len--; &#125; console.log(str1); 字符串连接 1234567 // str=str.concat(\"abc\");连接字符串 str+=\"abc\"; var str1=str+\"abc\"; var age=15; var str=\"今年小明\"+age+\"岁了\"; var str=\"今年小明\".concat(age,\"岁了\"); console.log(str); 字符串和数组通用的方法 1234 console.log(str.charAt(1));//str[1]; console.log(str.indexOf(\"b\",1)); console.log(str.lastIndexOf(\"b\")); console.log(str.slice(0,1));//截取赋值0，1 随机颜色 123456789 function randomColor()&#123; var color=\"rgb(\"; for(var i=0;i&lt;3;i++)&#123; color+=Math.floor(Math.random()*256)+\",\"; &#125; color=color.slice(0,-1)+\")\"; return color; &#125; console.log(randomColor()); 随机4位大小写验证码 12345678910111213141516171819202122 function getStr() &#123; var arr = []; for (var i = 48; i &lt; 123; i++) &#123; if (i &gt; 57 &amp;&amp; i &lt; 65) continue; if (i &gt; 90 &amp;&amp; i &lt; 97) continue; arr.push(String.fromCharCode(i)); &#125; /* arr.sort(function()&#123; return Math.random()-0.5; &#125;); arr.length=4; return arr.join(\"\"); */ var str = \"\"; while (str.length &lt; 4) &#123; var s = Math.floor(Math.random() * arr.length); if (str.indexOf(arr[s]) &gt; -1) continue; str += arr[s]; &#125; return str; &#125; console.log(getStr()); 随机字母和数字验证码 123456789101112131415 var arr = []; for (var i = 48; i &lt; 123; i++) &#123; if (i &gt; 57 &amp;&amp; i &lt; 65) continue; if (i &gt; 90 &amp;&amp; i &lt; 97) continue; arr.push(String.fromCharCode(i)); &#125; var arr1=[]; var i=0; while(arr.length&gt;0)&#123; if(i&gt;3) break; var n=Math.floor(Math.random()*arr.length); arr1.push(arr.splice(n,1)[0]); i++; &#125; console.log(arr1); 字符串方法 123456789101112131415161718192021222324 // 正则中使用的方法 console.log(str.search(\"a\"));//查找 console.log(str.match(\"a\"));//查找 console.log(str.replace(要查找的内容,要替换的值或者回调函数)) console.log(str.replace(\"a\",\"z\"));//替换字符串中指定的内容，返回被替换后的字符串，原字符串不改变 // 现在仅能替换第一个被查找到的元素 // substring不允许使用负数（负数就是0） // 反向截取 console.log(str.substring(4,0)); // substr // 截取固定长度的字符串 // str.substr(从什么位置开始，截取字符串的长度); // 开始位置可以使用负数,如果没有给长度，就会截取到尾部 console.log(str.substr(-6)); var str=\"xietian@163.com\"; console.log(str.substring(str.indexOf(\"@\")+1)); var str=\"a,b,c,d,e\"; console.log(str.split(\",\"));//将字符串以什么符号切割成数组 console.log(str.split(\"\").reverse().join(\"\")); var str=\"xietian@163.com\"; console.log(str.split(\"@\")[1]); console.log(str.toUpperCase());//转换成大写 console.log(str[0].toUpperCase()+str.slice(1)); console.log(str.toLowerCase());//转换为小写字母 Date 12345678var date=new Date(); console.log(date); console.log(date.toUTCString());//获取格林尼治日期时间 console.log(date.toLocaleString());//获取本地日期时间 console.log(date.toLocaleDateString());//获取本地日期 console.log(date.toLocaleTimeString());//获取本地时间 console.log(date.getTime());//获取时间戳 1970.1.1，0点到现在的毫秒数 // 时间戳永远都不相同 循环10000次的时间 123456var time=new Date().getTime(); for(var i=0;i&lt;10000;i++)&#123; var a=Math.pow(2,20); var a=1&lt;&lt;20; &#125; console.log(new Date().getTime()-time); 计算循环的时间 12345678910111213141516171819202122232425262728293031323334353637383940 var dateManager=&#123; date:&#123;&#125;, num:0, start:function()&#123; // 对象的方法中，如果调用了该对象的属性，就需要使用this this.num++; // dateManager.num++; this.date[\"date_\"+this.num]=new Date().getTime(); return \"date_\"+this.num &#125;, end:function(id)&#123; var time=this.date[id]; delete this.date[id]; return new Date().getTime()-time; &#125; &#125; /* var dm=dateManager; dateManager=&#123;&#125;; dm.start(); var id=date.start(); // ..... // .... var ids=date.start(); // ... console.log(date.end(id)); //... console.log(date.end(ids)); */ var id1=dateManager.start(); for(var i=0;i&lt;1000000;i++)&#123; &#125; var id2=dateManager.start(); var ids=setTimeout(function()&#123; console.log(dateManager.end(id1)); clearTimeout(ids); ids=setTimeout(function()&#123; clearTimeout(ids); console.log(dateManager.end(id2)); &#125;,1000) &#125;,1000) 获取日期 1234567891011121314151617var date=new Date(); console.log(date.getYear()); console.log(date.getFullYear());//年 console.log(date.getMonth());0-11//月 console.log(date.getDate());//日期 console.log(date.getDay());//星期 星期日0，1-6星期一-星期六 console.log(date.getHours());//小时 console.log(date.getMinutes());//分 console.log(date.getSeconds());//秒 console.log(date.getMilliseconds());//毫秒 console.log(date.getUTCDate());//格林尼治日期 date.setFullYear(2021); // 设置日期时间时，如果超出范围，就会自动进位 date.setMonth(12); console.log(date); date.setMinutes(date.getMinutes()+5); console.log(date);","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"字符串","slug":"字符串","permalink":"https://cooli-willson.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"5.js基础 递归和数组","slug":"5.js基础 递归和数组","date":"2020-01-22T15:12:26.387Z","updated":"2020-01-22T15:15:20.512Z","comments":true,"path":"2020/01/22/5.js基础 递归和数组/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/5.js%E5%9F%BA%E7%A1%80%20%E9%80%92%E5%BD%92%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"5.js基础 递归和数组 递归 递归与回调函数的使用 123456789101112131415161718 function fn1()&#123; i++; // console.log(i); if(i&lt;4) fn2(); console.log(i); &#125; function fn2()&#123; i++; // console.log(i); if(i&lt;4) fn3(); console.log(i); &#125; function fn3()&#123; i++; // console.log(i); // if(i&lt;4) fn(); console.log(i); &#125; 浅复制与深层复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var obj = &#123; a: 1, b: 2, c: &#123; a: 3, b: 4, c: &#123; a: 5, b: 6, c: &#123; a: 7, b: 8 &#125; &#125; &#125; &#125;; var obj1=&#123;&#125;; for(var prop in obj)&#123; obj1[prop]=obj[prop]; &#125; obj.c.a=10; console.log(obj1); function cloneObj(target,source)&#123; for(var prop in source)&#123; if(typeof source[prop]===\"object\" &amp;&amp; source[prop]!==null)&#123; target[prop]=&#123;&#125;; cloneObj(target[prop],source[prop]) &#125;else&#123; target[prop]=source[prop]; &#125; &#125; return target; &#125;// 同样的属性 使用引用关系的方式深度遍历 var o = source.c; target.c = &#123;&#125;; var o1 = target.c; while (o) &#123; for (var prop in o) &#123; if (typeof o[prop] !== \"object\" || o[prop] === null) &#123; o1[prop] = o[prop]; &#125; &#125; o = o.c; if (o) &#123; o1.c = &#123;&#125;; o1 = o1.c; &#125; &#125; return target &#125; var obj1 = &#123;&#125;; obj1 = cloneObj(obj1, obj); // obj.c.c.a = 10; console.log(obj1); 数组的创建 什么是数组 12345678var arr=[]; var arr=new Array(); var arr=new Object([]); // 数组是一个引用列表 // 列表：顺序，只有值，紧密，速度慢 var arr=[3,1,6,5,4,8,9]; console.log(arr); 字面量创建数组 1234567 var arr=[1,2,3,4,5]; // arr是数组 1是索引值（下标） arr[1]元素（下标变量） console.log(arr[1]); arr[1]=10;//可以修改下标变量的结果 console.log(arr[1]); arr[5]=10; arr[7]=10;//数组的紧密型，如果中间空余，就会自动补充空元素 数组的使用与特性 123456789101112131415161718192021222324252627282930313233// 遍历内容较多，当添加删除元素时，因为数组紧密型，速度变慢，尤其前面插入和删除 arr[-1]=10; console.log(arr); // length 数组得长度 console.log(arr.length);//表示当前数组得索引下标的最大值+1，因为从0开始 // 当添加不是索引数据（0开始），-1，不会累计在长度中，而作为对象的key，value增加内容 arr[\"6\"]=10; arr[arr.length]=10;//在数组的尾部添加一个新元素 // 每次添加元素后，长度会发生改变，length会变化的，因此下面这句不会修改最后一个元素，而是添加一个新元素 arr[arr.length]=11;//在数组的尾部添加一个新元素 arr.length=10;//如果直接设置数组的长度，长度大于原来的数组的长度时，添加空元素，让数量达到这个设置的值 arr.length=arr.length-1;//如果长度比原来少一个，就会删除最尾部元素 arr.length--; arr.length=0;//表示清空数组 arr=[];//引用地址变化了 arr.length=-2;//数组的长度不能为负值 arr.length=\"a\";//如果给的不是数值，会隐式转换为数值，如果值是NaN，就会报错 console.log(arr,arr.length); // 构造函数创建 // 构造函数实例化对象 var arr=new Array(1,2,3,4,5); console.log(arr); // 字符串转数组类型 var arr=Array(1,2,3,4,5); console.log(arr); // 数组通过构造函数创建时，如果只有一个参数，并且参数是正整数， // 这个数就是数组的长度，而不作为数组的新元素 // 如果是数字，但不是正整数，都会报错 // 如果不是数字，则作为数组的第一个元素添加 var arr=new Array(1); var arr=new Array(\"3\"); var arr=Array(5); console.log(arr);","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"递归","slug":"递归","permalink":"https://cooli-willson.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"数组","slug":"数组","permalink":"https://cooli-willson.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"在表格中插入文字和图片","slug":"在表格中插入文字和图片","date":"2020-01-22T14:58:53.660Z","updated":"2020-01-22T15:00:06.582Z","comments":true,"path":"2020/01/22/在表格中插入文字和图片/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/%E5%9C%A8%E8%A1%A8%E6%A0%BC%E4%B8%AD%E6%8F%92%E5%85%A5%E6%96%87%E5%AD%97%E5%92%8C%E5%9B%BE%E7%89%87/","excerpt":"","text":"在表格中插入文字和图片 CSS部分 123456789101112 table &#123; border-collapse: collapse; width: 800px; &#125; td &#123; border: 1px solid #000000; text-align: center; &#125; img &#123; width: 50px; height: 50px; &#125; js部分 1234567891011121314151617181920212223242526272829303132 // fn(); var data1 = [ &#123; id: 1001, icon: \"img/icon01.png\", name: \"餐饮0\", num: 1, price: 10 &#125;, &#123; id: 1002, icon: \"img/icon02.png\", name: \"餐饮1\", num: 1, price: 20 &#125;, &#123; id: 1003, icon: \"img/icon03.png\", name: \"餐饮2\", num: 1, price: 30 &#125;, &#123; id: 1004, icon: \"img/icon04.png\", name: \"餐饮3\", num: 1, price: 40 &#125;, &#123; id: 1005, icon: \"img/icon05.png\", name: \"餐饮4\", num: 1, price: 50 &#125;, &#123; id: 1006, icon: \"img/icon06.png\", name: \"餐饮5\", num: 1, price: 60 &#125;, &#123; id: 1007, icon: \"img/icon07.png\", name: \"餐饮6\", num: 1, price: 70 &#125;, &#123; id: 1008, icon: \"img/icon08.png\", name: \"餐饮7\", num: 1, price: 80 &#125;, &#123; id: 1009, icon: \"img/icon09.png\", name: \"餐饮8\", num: 1, price: 90 &#125;, &#123; id: 1010, icon: \"img/icon10.png\", name: \"餐饮9\", num: 1, price: 100 &#125; ]; function createTable(data) &#123; var table = \"&lt;table&gt;\"; for (var prop in data) &#123; table += \"&lt;tr&gt;\"; var obj = data[prop]; for (var attr in obj) &#123; if (attr === \"icon\") &#123; table += \"&lt;td&gt;&lt;img src='\" + obj[attr] + \"'&gt;&lt;/td&gt;\"; &#125; else &#123; table += \"&lt;td&gt;\" + obj[attr] + \"&lt;/td&gt;\"; &#125; &#125; table += \"&lt;/tr&gt;\"; &#125; table += \"&lt;/table&gt;\"; document.write(table); &#125; createTable(data1);","categories":[{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/categories/%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"循环","slug":"循环","permalink":"https://cooli-willson.github.io/tags/%E5%BE%AA%E7%8E%AF/"}]},{"title":"实现简单的计算器功能","slug":"实现简单的计算器功能","date":"2020-01-22T14:49:54.302Z","updated":"2020-01-22T14:51:39.320Z","comments":true,"path":"2020/01/22/实现简单的计算器功能/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%E5%8A%9F%E8%83%BD/","excerpt":"","text":"实现简易计算器功能 css部分 12345678910111213141516171819202122232425262728293031323334353637383940414243.div0 &#123; height: 340px; width: 275px; border: 1px solid #000; margin: 0 auto; background-color:#aa0055; &#125; .div0&gt;div &#123; padding-left: 20px; padding-top: 10px; &#125; .div0&gt;div&gt;div &#123; height: 50px; width: 50px; font-size: 20px; line-height: 50px; text-align: center; float: left; border: 1px solid #000; margin-right: 10px; margin-top: 10px; box-shadow: 3px 3px 2px #4f0027; user-select: none; /* 将输入模式改为光标 */ background-color: #ff7dbe; color: #fff; font-weight: bolder; border-radius: 80%; &#125; .div0&gt;div&gt;div:hover &#123; box-shadow: -2px -2px 2px #4f0027; &#125; .div0&gt;input &#123; display: block; height: 50px; width: 250px; margin: 0 auto; text-align: right; padding-right: 20px; background-color: #6f0037; font-size: 30px; color: #fff; font-weight: bolder; &#125; html部分 123456789101112131415161718192021 &lt;div class=\"div0\"&gt; &lt;input type=\"text\" value=\"0\" id=\"input0\" disabled&gt; &lt;!-- 禁止输入 --&gt; &lt;div&gt; &lt;div id=\"div1\"&gt;1&lt;/div&gt; &lt;div id=\"div2\"&gt;2&lt;/div&gt; &lt;div id=\"div3\"&gt;3&lt;/div&gt; &lt;div id=\"div4\"&gt;4&lt;/div&gt; &lt;div id=\"div5\"&gt;5&lt;/div&gt; &lt;div id=\"div6\"&gt;6&lt;/div&gt; &lt;div id=\"div7\"&gt;7&lt;/div&gt; &lt;div id=\"div8\"&gt;8&lt;/div&gt; &lt;div id=\"div9\"&gt;9&lt;/div&gt; &lt;div id=\"div10\"&gt;0&lt;/div&gt; &lt;div id=\"div11\"&gt;+&lt;/div&gt; &lt;div id=\"div12\"&gt;-&lt;/div&gt; &lt;div id=\"div13\"&gt;*&lt;/div&gt; &lt;div id=\"div14\"&gt;/&lt;/div&gt; &lt;div id=\"div15\"&gt;=&lt;/div&gt; &lt;div id=\"div16\"&gt;C&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; js部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 var value, type, input; var value = \"0\"; getValue(); function getValue() &#123; input = document.getElementById(\"input0\");//将input标签储存在input中 for (var i = 1; i &lt; 17; i++) &#123;//遍历每个标签 var div = document.getElementById(\"div\" + i); //将得到div标签存放到div变量中 div.onclick = clickFunction; //当前div点击时调用clickFunction函数 &#125; &#125; function clickFunction() &#123; switch (this.innerHTML) &#123; //通过当前点击获取的值来判断该执行怎样的操作 case \"+\": case \"-\": case \"*\": case \"/\": type = this.innerHTML; //将运算符储存在type变量中 value = input.value; //将当前拼接的字符串储存在value中 input.value = \"0\"; //在点击运算运算符后显示屏幕显示为0 break; case \"=\": getResult(); //调用计算函数 break; case \"C\": //清空操作 当前所有值都设为初始值 value = \"0\"; input.value = \"0\"; type = \"\"; break; default: input.value=Number(input.value+this.innerHTML);//通过Number将拼接成字符串的结果转换为数值型赋值给input.value &#125; &#125; function getResult()&#123; switch(type)&#123; //通过运算符来判断该执行那种运算操作 case \"+\": input.value=Number(value)+Number(input.value); return; //return可以直接返回 break还要继续判断 case \"-\": input.value=Number(value)-Number(input.value); return; case \"*\": input.value=Number(value)*Number(input.value); return; case \"/\": input.value=Number(value)/input.value!==0? Number(input.value):\"输入错误\"; //正则表达式,若被除数为0，则提示“输入错误”; return; &#125; &#125;","categories":[{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/categories/%E5%8A%9F%E8%83%BD/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"计算器","slug":"计算器","permalink":"https://cooli-willson.github.io/tags/%E8%AE%A1%E7%AE%97%E5%99%A8/"}]},{"title":"4.javascript 基础-函数","slug":"4.js基础-函数","date":"2020-01-22T14:20:23.154Z","updated":"2020-01-22T14:34:39.677Z","comments":true,"path":"2020/01/22/4.js基础-函数/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/4.js%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数 函数的创建 命名函数创建 当前函数最在script标签创建时，优先将该函数储存在堆中，并且函数名储存在栈中 当前这个代码所在的script标签的上面的script的标签中任意函数和全局变量都是可以被调用的 但是当前代码所在的script标签下面的script的标签中函数和全局变量是不可以调用的 函数名：驼峰式命名法，首字母一般都是小写，如果该函数是构造函数，函数名首字母需要大写 函数后面的（）是执行当前函数需要传入参数内容 {}里面是函数的语句块，当执行函数时，该语句的内容就会被执行 1234function fn(a,b)&#123; console.log(a+b); &#125; fn(3,4) 匿名函数 代码运行到定义匿名函数后才可以调用该匿名函数 12345var fn=function()&#123; &#125; (function()&#123; // 自执行函数 &#125;)(); 函数的作用域 函数内与函数外的变量 12345678910111213141516171819202122232425262728293031// 函数外的变量，在函数中可以调用到 var a=10; function fn()&#123; console.log(a); &#125; fn(); // 函数内定义的变量不能被函数外调用 function fn()&#123; var a=10; // 在函数内使用var定义的变量就是局部变量 // 在函数外用var定义的变量就是全局变量。 // 不使用var直接给一个变量赋值就是相当于给window增加一个属性，那么这个属性也是全局变量 &#125; fn(); console.log(a); // var是定义变量，如果在函数中没有用var定义变量，直接使用变量，该变量是全局变量 function fn()&#123; a=10; &#125; fn(); console.log(a); // this===window // var b=10; function fn()&#123; // window被省略了,如果没有使用var定义变量，就意味着直接在window对象下增加这个属性 a=10; &#125; fn(); console.log(a); 局部变量与全局变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var a=10; function fn()&#123; var a=5; console.log(a);//5 // 有局部变量时，先调用局部变量，没有局部变量才带哦用全局变量 &#125; fn(); console.log(a);//10 var a=10; function fn()&#123; // 在函数中任意位置使用var定义的变量，在该函数的任意位置都认为该变量是局部变量 console.log(a);//undefined var a=5; &#125; fn(); console.log(a);//10 var a=10; function fn()&#123; var a=20; // console.log(a+window.a); console.log(a+this.a); &#125; fn(); // function fn(a)&#123; // // console.log(a); // // 参数就是局部变量 // &#125; // fn(5); var a=10; function fn(a)&#123; console.log(a);//5 var a=20; // 这里相当于重新定义了一个局部变量a &#125; fn(5); var a=5; function fn()&#123; var a=10; function fn1()&#123; var b=20; var a=100; console.log(a); &#125; fn1(); console.log(b); &#125; fn(); a(a);//a都是全局变量，下面a=10还没有运行，所以在这里全局变量就是函数a,我们把函数a当前参数填入 var a=10;//覆盖了函数a，函数a在这里也是全局变量 function a(a)&#123; console.log(a); var a=10; &#125; // a(a); var a; a(a); a=5; function a(a)&#123; console.log(a); var a=10; &#125; 函数的参数 参数可以时任意内容，如没有对应填入，该参数就是undefined、 执行函数时，填入的参数就相当于给参数赋值 js是一个弱类型语言，因此，参数不能强制约定类型 ES5中不能和设置参数的默认值 执行函数时填入值与函数参数顺序时一一对应关系 12345678910111213141516function fn(obj)&#123; // 相当于给obj赋值一个o，obj和o的引用地址相同 // 当修改obj的属性时，全局的o属性也会被修改 obj.a=10; &#125; var o=&#123;a:1&#125;; fn(o); function fn(obj)&#123; // 重新设置了obj的新的引用地址 obj=&#123; a:3 &#125; &#125; var o=&#123;a:1&#125;; fn(o); 回调函数 123456789101112131415function fn(f)&#123; var a=10; f(a); &#125; function fn1(a)&#123; console.log(a+10); &#125; function fn2(a)&#123; console.log(a+100); &#125; function fn3(a)&#123; console.log(a+1000); &#125; fn(fn2); 如果参数的数量不确定，就不设置参数 12345678910111213141516function getMaxValue()&#123; // console.log(arguments);//ES5以上版本时尽量少用,arguments参数集 if(arguments.length===0) return; var max=arguments[0]; for(var i=1;i&lt;arguments.length;i++)&#123; max=max&gt;arguments[i] ? max : arguments[i]; &#125; console.log(max); &#125; getMaxValue(1,4,7,2,3,10); function getMaxValue()&#123; // console.log(arguments.callee);//该函数自己 // console.log(arguments.callee.caller); &#125; getMaxValue(1,3,5,7); 递归 12345678910111213141516 var i=0 function fn()&#123; i++; if(i&lt;10) fn(); &#125; fn(); console.log(i); // 用于匿名函数中调用自身函数 var i=0; (function()&#123; i++; if(i&lt;10) arguments.callee(); &#125;)(); console.log(i); 函数之间的调用 1234567891011121314151617181920 var i=0; function fn1(f)&#123; console.log(\"a\"); f(); &#125; function fn3(f)&#123; console.log(\"c\"); f(); &#125; function fn2()&#123; // 调用当前函数的环境函数 // console.log(arguments.callee.caller); console.log(\"b\"); i++; if(i&lt;10) arguments.callee.caller(arguments.callee); &#125; // 耦合 fn3(fn2); 随机生成颜色大小不同的50个方块 12345678910111213141516171819202122232425262728 var w, c; init(); function init() &#123; for (var i = 0; i &lt; 50; i++) &#123; w = Math.random() * 50 + 50; c = randomColor(); createDiv(w, w, c); &#125; &#125; function createDiv(_width, _height, _color) &#123; var str = \"\"; str += \"&lt;div style='\"; str += \"width:\" + _width + \"px;\"; str += \"height:\" + _height + \"px;\"; str += \"background-color:\" + _color + \";\"; str += \"position:absolute;\"; str += \"left:\" + Math.random() * 1000 + \"px;\"; str += \"top:\" + Math.random() * 600 + \"px;\"; str += \"'&gt;&lt;/div&gt;\"; document.write(str); &#125; function randomColor() &#123; var color = \"#\"; for (var i = 0; i &lt; 6; i++) &#123; color += parseInt(Math.random() * 16).toString(16); &#125; return color; &#125; return 点击切换div的颜色 123456789101112131415161718192021 function fn(n)&#123; console.log(\"aa\"); if(n&lt;5) return; &#125; fn(3); // 把id是div0的元素获取成为DOM变量 var div=document.getElementById(\"div0\"); // 设置行内样式 div.style.width=\"100px\"; div.style.height=\"100px\"; div.style.backgroundColor=\"red\"; var bool=false; div.onclick=function()&#123; bool=!bool; div.style.backgroundColor=bool ? \"blue\" :\"red\"; &#125; div.onclick=clickHandler; function clickHandler()&#123; bool=!bool; div.style.backgroundColor=bool ? \"blue\" :\"red\"; &#125; 定时器 setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 setTimeout() ：在指定的毫秒数后调用函数或计算表达式。 setInterval() 语法 setInterval(code,millisec) 参数 描述 code 必须。要调用的函数或要执行的代码串。 millisec 必须。周期性执行或调用code之间的时间间隔，以毫秒计 1234567891011121314 setInterval(function()&#123; // 间隔多长时间执行该函数，时间是毫秒数 console.log(\"aa\"); return; &#125;,1000); var time=0; // setInterval(执行的函数，间隔的时间);返回一个数值，可以根据这个数值清楚执行函数 var ids=setInterval(animation,1000); function animation()&#123; time++; if(time&gt;5) clearInterval(ids);//clearInterval(创建时间间隔id) 清楚时间间隔执行 console.log(\"aa\"); &#125; setTimeout() 语法 setTimeout(code,millisec) 参数 描述 code 必需。要调用的函数后要执行的javascript代码串 millisec 在执行代码浅需要等待的毫秒数 12345678910 // 多少时间后执行该函数 // setTimeout(执行的函数，间隔的时间);//多长时间后执行 var ids=setTimeout(function()&#123; console.log(\"aa\"); clearTimeout(ids);//清除时间间隔，每次用完必须清除 &#125;,5000); // setInterval和setTimeout第三个参数都是可以给执行函数传入参数的 var ids=setInterval(animation,1000,5); function animation(n)&#123; &#125; return 阻断 12345678910111213141516171819var disc=0,bool=false; init(); function init() &#123; var div = document.getElementById(\"div0\"); div.style.width = \"50px\"; div.style.height = \"50px\"; div.style.backgroundColor = \"red\"; div.style.position = \"absolute\"; div.style.left=\"0px\"; div.onclick=function()&#123; bool=!bool; &#125; setInterval(anmiation,16,div); &#125; function anmiation(div)&#123; if(!bool) return; disc++; div.style.left=disc+\"px\"; &#125; return break continue的区别 12345678910111213141516 function fn()&#123; for(var i=0;i&lt;10;i++)&#123; if(i===5) return; &#125; console.log(\"a\"); &#125; fn(); // return 有时候可以替代break // return 返回值 // 可以允许函数返回一个值，仅一个。。 function fn()&#123; return \"a\"; &#125; // 函数在执行时，将会返回一个结果，如果函数中没有return，就会返回undefined var s=fn(); console.log(s); 随机颜色 123456789101112131415function randomColor(alpha)&#123; // 如果没有参数，随机 alpha=alpha==undefined ? Math.random().toFixed(2) : alpha; // 传入的参数转换为数值 alpha=Number(alpha); // 如果传入的参数是非数值，就让透明度为1 if(isNaN(alpha))alpha=1; var color=\"rgba(\"; for(var i=0;i&lt;3;i++)&#123; color+=parseInt(Math.random()*256)+\",\"; &#125; color+=alpha+\")\"; return color; &#125; console.log(randomColor(true)); 将数字转换为汉字 12345678910111213 function getCNNumber(n)&#123; if(n&lt;0 || n&gt;1000) return \"错误的消息\"; if(n&lt;10) return arr[n]; if(n===10) return \"十\"; if(n&lt;20) return \"十\"+arr[String(n)[1]]; if(n&gt;=100 &amp;&amp; n%100===0) return arr[String(n)[0]]+\"百\"; if(n&gt;100 &amp;&amp; n%10===0) return arr[String(n)[0]]+\"百\"+arr[String(n)[1]]+\"十\"; if(n%10===0) return arr[String(n)[0]]+\"十\"; if(n&lt;100) return arr[String(n)[0]]+\"十\"+arr[String(n)[1]]; if(n%100&lt;10) return arr[String(n)[0]]+\"百零\"+arr[String(n)[2]]; return arr[String(n)[0]]+\"百\"+arr[String(n)[1]]+\"十\"+arr[String(n)[2]]; &#125; console.log(getCNNumber(345)); 返回对象可以返回多个值 12345678function fn(w,h)&#123; // var perimeter=(w+h)*2; // var area=w*h; return &#123; perimeter:(w+h)*2, area:w*h &#125; &#125; 回调函数 123456789101112131415161718192021222324 function callBack()&#123; &#125; setInterval(callBack,1000); function fn1(f)&#123; f(); &#125; function fn2()&#123; console.log(\"aaa\"); &#125; fn1(fn2); var i=0; function fn1(f)&#123; console.log(\"a\"); f(fn1); console.log(i); &#125; function fn2(f)&#123; i++; console.log(\"b\"); if(i&lt;6000) f(fn2); &#125; fn1(fn2); // 堆栈溢出 递归或者回调的次数过多，没有阻止递归或者回调的条件 通过回调函数实现红绿灯功能 1234567891011121314151617181920212223242526272829function getLight(first,second,third)&#123; first(second,third); &#125; function getRedLight(fn,fn1)&#123; var f=arguments.callee; var ids=setTimeout(function()&#123; console.log(\"红灯\"); clearTimeout(ids); fn(fn1,f); &#125;,1000); &#125; function getYellowLight(fn,fn1)&#123; var f=arguments.callee; var ids=setTimeout(function()&#123; console.log(\"黄灯\"); clearTimeout(ids); fn(fn1,f); &#125;,1000); &#125; function getGreenLight(fn,fn1)&#123; var f=arguments.callee; var ids=setTimeout(function()&#123; console.log(\"绿灯\"); clearTimeout(ids); fn(fn1,f); &#125;,1000); &#125; // getRedLight(getYellowLight,getGreenLight); getLight(getGreenLight,getYellowLight,getRedLight)\\","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"函数","slug":"函数","permalink":"https://cooli-willson.github.io/tags/%E5%87%BD%E6%95%B0/"}]},{"title":"3.js基础-循环和对象","slug":"3.js基础-循环和对象","date":"2020-01-22T07:51:40.150Z","updated":"2020-01-22T14:23:07.710Z","comments":true,"path":"2020/01/22/3.js基础-循环和对象/","link":"","permalink":"https://cooli-willson.github.io/2020/01/22/3.js%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"js基础-循环和对象 三目运算符 条件 ？ 条件是true返回的结果 ： 条件是false时返回的结果 123456789101112131415var max=3&gt;4 ? 3 : 4; var i=1; var s=--i ? i++ : ++i; console.log(s); var a=6, b=5, c=5; var max=a&gt;b ? (a&gt;c ? a : (c&gt;b ? c : b)) : b&gt;c ? b : (c&gt;a ? c : a); console.log(max); var s=3&gt;5 ? false : true;//返回布尔值的三元运算时，不用些三元方式 var s=3&gt;5; var obj= s ? s : 5;//判断一个值是否存在，如果不存在重新赋值，或 var obj=s || 5; var s= s===0 ? 0 : 5;//判断是否是0 如果不是0，就返回另一个值， var s= s &amp;&amp; 5 条件语句 if语句 123456789101112131415161718192021222324252627282930313233343536373839404142 var s=3; if(s&gt;5)&#123; &#125; if(s&lt;10)&#123; &#125;else&#123; &#125; if(s&gt;0)&#123; &#125;else if(s===0)&#123; &#125;else&#123; &#125; // if(隐式转换为布尔值)&#123; // &#125; // 条件中的结果不是 \"\",false,0,NaN,undefined,null就可以进入条件 var i = 0; var s = 0; if(++i)&#123; s=i++; &#125; if(i+1!==0)&#123; s=i+1; &#125; if(s=++i); console.log(s,i); if(i+1!==0) s=i+1; // 如果条件语句块只有一句话的时候，可以省略｛｝ if(i===0) i=i+2; i=i+3; console.log(i); if(i&gt;0) i=3; else if(i===0) i=5; else i=10; if()&#123; &#125; // 不管是否满足上面的条件，都需要判断下面的这个条件 if()&#123; &#125; if()&#123; &#125;else if()&#123; // 如果上面的条件满足，就不会判断下面这个条件 &#125; // 配合函数中的return将会很少使用到if else if switch case 语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 判断switch中表达式是否（绝对===）等于case中的值 var s=10; switch(s%10)&#123; case 1: // 语句1 break;//break作用是跳出switch语句块，从break后面的语句块将不再执行 // 但是如果没有break,仍然在不判断结果的情况下执行一个case的语句块，这叫穿越 case 2: // 语句2 break; case 3: // 语句3 break; case 0: // 语句4 break; &#125; // switch 或者穿越 var s=10; switch(s%10)&#123; case 0: case 1: case 2: case 3: case 4: s++; break; &#125; var s=10;//累积穿越 switch(s%10)&#123; case 0: s=100; case 1: case 2: case 3: case 4: s--; break; &#125; var s=95; switch(true)&#123; case s&gt;90: break; case s&gt;80: break; case s&gt;70: break; &#125; 状态机 1234567891011121314151617181920212223242526272829303132333435 var value=prompt(\"请输入你的成绩\"); // console.log(value); // document.write('你好'); var value=parseInt(prompt(\"请输入你的成绩\")); if(!isNaN(value))&#123; if(value&gt;100) document.write(\"输入错误\"); else if(value&gt;=90) document.write(\"A\"); else if(value&gt;=80) document.write(\"B\"); else if(value&gt;=70) document.write(\"C\"); else if(value&gt;=60) document.write(\"D\"); else if(value&gt;=0) document.write(\"E\"); else document.write(\"输入错误\"); &#125; var value = parseInt(prompt(\"请输入你的成绩\")); if (value === 100) document.write(\"A\"); else if (value &gt;= 0 &amp;&amp; value &lt; 100) &#123; switch (parseInt(value / 10)) &#123; case 9: document.write(\"A\"); break; case 8: document.write(\"B\"); break; case 7: document.write(\"C\"); break; case 6: document.write(\"D\"); break; default: document.write(\"E\"); &#125; &#125; else &#123; document.write(\"输出错误\"); &#125; 循环语句 for 循环 循环的目的是为了重复执行｛｝内的语句 123456 var i=0; while(i&lt;10)&#123; document.write(\"a\"); document.write(\"&lt;br&gt;\"); i++; &#125; 循环的必须条件 必须由起始值。 必须有一个循环条件 须有一个不断向条件外处理的语句 123456789 var str=\"\"; var i=0; str+=\"&lt;ul&gt;\"; while(i&lt;10)&#123; str+=\"&lt;li&gt;项目\"+i+\"&lt;/li&gt;\"; i++; &#125; str+=\"&lt;/ul&gt;\"; document.write(str); 循环是同步的，如果循环较长就会卡顿 123456789 console.log(\"a\"); var i=0; var s=0; while(i&lt;100000000000)&#123; s+=i; i++; &#125; console.log(\"b\"); console.log(s); 深度循环 1234567891011121314151617181920var obj=&#123; value:1,next:&#123; value:2,next:&#123; value:3,next:&#123; value:4,next:&#123; value:5,next:&#123; value:6,next:&#123; value:7 &#125; &#125; &#125; &#125; &#125; &#125; &#125; console.log(obj.value); while(obj=obj.next)&#123; console.log(obj.value); &#125; 轮盘赌算法(循环中的break) 1234567 var num=0; // 跳出，在循环中如果需要跳出循环（不再继续循环了） break while(true)&#123; num++; if(parseInt(Math.random()*10)===5) break; &#125; console.log(num); 循环中的continue 123456789 var str=\"\"; var num=47; while(num&lt;122)&#123; num++; if(num&gt;57 &amp;&amp; num&lt;65) continue; if(num&gt;90 &amp;&amp; num&lt;97) continue; str+=String.fromCharCode(num); &#125; document.write(str); 双重循环语句 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 var str = \"\"; var j = 0; // 设置锚点位置 AB: while (j &lt; 10) &#123; str += \"&lt;ul&gt;\"; var i = 0; while (i &lt; 10) &#123; str += \"&lt;li&gt;项目\" + i + \"&lt;/li&gt;\"; i++; // 跳出到锚点位置 if(i===4 &amp;&amp; j===4) break AB; &#125; str += \"&lt;/ul&gt;\"; j++; &#125; document.write(str); var table=\"&lt;table&gt;\"; var i=1,j=1; while(i&lt;10)&#123; table+=\"&lt;tr&gt;\"; j=1; while(j&lt;10)&#123; table+=\"&lt;td&gt;\"+i+\"*\"+j+\"=\"+i*j+\"&lt;/td&gt;\"; if(j&gt;=i) break;//跳出 j++; &#125; table+=\"&lt;/tr&gt;\"; i++; &#125; table+=\"&lt;/table&gt;\"; document.write(table); var y=2,w=0,bool; while(y&lt;100)&#123; // 用i除以1-自身之间的数值，如果没有余数，就不是素数（质数） bool=false; w=2; while(w&lt;y)&#123; if(y%w===0)&#123; bool=true; break; &#125; w++; &#125; if(!bool)&#123; console.log(y); &#125; y++; &#125; 循环的应用 打印等腰三角形 123456789101112131415 var i=0,j=0,k=0; while(i&lt;10)&#123; k=0; while(k&lt;10-i)&#123; document.write(\"&amp;ensp;\"); k++; &#125; j=1; while(j&lt;(i+1)*2)&#123; document.write(\"*\"); j++; &#125; document.write(\"&lt;br&gt;\"); i++; &#125; do while 循环 12345678910111213141516171819var i=0; do&#123; console.log(\"aa\"); i++; &#125;while(i&lt;10); // do while 是先执行语句块，再判断是否继续循环 var i=0; do&#123; console.log(\"a\"); i++; &#125;while(i&gt;0 &amp;&amp; i&lt;10); while(i&gt;0 &amp;&amp; i&lt;10)&#123; &#125; var n; do&#123; n=Math.random(); console.log(n); &#125;while(n&lt;0.5); for 循环 12345// for(初始变量;循环条件;向条件外变化的表达式)&#123;// 循环// &#125;for(var i=0;i&lt;10;i++)&#123;&#125; while循环 do whie循环 for循环的区别 12345678910111213141516171819202122232425262728var sum=0; for(var i=0;i&lt;=100;i++) sum+=i; console.log(sum); // 每次开始循环时，sum都会重置为0 // 定义变量，每次循环的开始先执行,执行一次 for(var i=0,sum=0,s=++i;i&lt;=100;i++) sum+=i; console.log(sum,s); // 条件语句，计算完成后必须转换为布尔值，是true才进入语句块 // 条件语句先判断，条件语句每次都会执行判断 for(var i=0,sum=0;i++&lt;100;) sum+=i; console.log(sum); // 变化是所有语句块运行完成后执行 // 如果使用while或者do while中continue，i++就需要写在continue的上面 for(var i=0,sum=0;i&lt;100;i++)&#123; sum+=i; if(i===20) continue; console.log(\"aa\"); &#125; console.log(sum); for(var i=0,sum=0;i&lt;=100;sum+=i++); console.log(sum); 对象的遍历 浅复制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 //对象的属性 var a=3; var obj=&#123; // 创建对象时，如果key是一个变量，就需要写在[] [a]:10, // 这个a是一个字符Key a:20 &#125;; // 直接描述对象下有一个a的属性，值是1 obj.a=1; obj[\"a\"]=1;//对象[字符key]=value; // key就是属性名称，必须是字符串（ES5） var a=\"a\"; obj[a]=1;//中括号的方式是可以带入变量作为key的，点方法是不能使用变量 var s=4; obj[s]=1; var b=true; obj[b]=1; var o=&#123;a:1&#125;; obj[o]=2; var o1=&#123;a:2&#125;; console.log(obj[\"3\"]); console.log(obj.a); console.log(obj[\"a\"]); console.log(obj[\"a\"][\"b\"]); var obj=&#123; a:1, b:2, c:3, d:&#123; a:1,b:2 &#125; &#125; for(var prop in obj)&#123; // prop 就是obj下的所有属性名 key // 每循环一次就将属性名付给prop变量 console.log(prop,obj[prop]); &#125; // 浅复制 var obj1=&#123;&#125;; for(var prop in obj)&#123; obj1[prop]=obj[prop]; &#125; // 复制后切段引用关系，所以源对象属性值改变，新对象不变 obj.d.a=10; console.log(obj1); // 删除某个属性 delete obj.d; console.log(obj); 作业 表格的创建 123456789101112131415 var table=\"&lt;table&gt;\"; //table var i = 0, j = 0; while (i &lt; 10) &#123; table += \"&lt;tr&gt;\"; j = 0; while (j &lt; 10) &#123; table += \"&lt;td&gt;\" + \"&lt;/td&gt;\"; j++; &#125; table += \"&lt;/tr&gt;\" i++; &#125; table+= \"&lt;/table&gt;\"; document.write(table); 垃圾的三角形 12345678910111213141516 var i=0,j=0; while(i&lt;10)&#123; i++; var k=0; while(k&lt;(10-i))&#123; k++; document.write(\"&amp;nbsp;\"); &#125; j=1; while(j&lt;=i)&#123; j++; document.write(\"*\"); &#125; document.write(\"&lt;br&gt;\"); &#125; 垃圾的菱形 12345678910111213141516171819202122232425262728293031323334 //正三角 var i = 0; j = 0; while (i &lt; 6) &#123; i++; k = i; while (k &lt;= 5) &#123; document.write(\"&amp;nbsp;\"); k++; &#125; j = 1; while (j &lt;= i) &#123; document.write(\"*\"); j++; &#125; document.write(\"&lt;br&gt;\"); &#125; //倒三角 var i = 0; j = 0; while (i &lt; 6) &#123; i++; var k = 0; while (k &lt; i) &#123; document.write(\"&amp;nbsp;\"); k++ &#125; j = i; while (j &lt;= 5) &#123; document.write(\"*\"); j++; &#125; document.write(\"&lt;br&gt;\"); &#125; 水仙花数 123456789101112 var hundred, ten, unit, n; for (n = 100; n &lt; 1000; n++) &#123; hundred = parseInt(n / 100); ten = parseInt((n - (hundred * 100)) / 10); unit = parseInt(n % 10); if (n == ((hundred * hundred * hundred) + (ten * ten * ten) + (unit * unit * unit))) &#123; document.write(\"100-1000以内的水仙花数为\" + n + \"&lt;br&gt;\"); &#125; &#125; 弹窗计算机器 12345678910111213141516171819202122232425while(true)&#123; var num1,operator,num2,result; num1=parseInt(prompt(\"第1个数\")); num2=parseInt(prompt(\"第2个数\")); operator=prompt(\"运算符\"); if(!isNaN(num1)&amp;&amp;!isNaN(num2))&#123; switch(operator)&#123; case \"+\": result=num1+num2; break; case \"-\": result=num1-num2; break; case \"*\": result=num1*num2; break; case \"/\": result=num1/num2; break; &#125; alert(result); &#125;else&#123; alert(\"请输入正确数值\"); &#125; &#125; 阶乘 12345678910111213var num = parseInt(prompt(\"请输入一个数值\")); for(var i=num-1;i&gt;=1;i--)&#123; num*=i; &#125; document.write(num); var result = num; while (num &gt; 1) &#123; num--; result *= num; &#125; document.write(result); 判断质数 123456789101112131415161718192021222324252627282930var i, j; for (i = 100; i &lt; 1000; i++) &#123; var flag = 0; for (j =2; j &lt; i; j++) &#123; if (i % j == 0) flag++; &#125; if (flag==0) &#123; document.write(i + \"&lt;br&gt;\") &#125; &#125; var i = 100, j; var count; while (i &lt;= 1000) &#123; count = 0; i++; j = 2; while (j &lt; i) &#123; j++; if (i % j == 0) &#123; count++; &#125; &#125; if (count &lt; 2) &#123; document.write(i + \"&lt;br&gt;\"); &#125; &#125; 百钱买白鸡 123456789for (let x = 1; x &lt; 100; x++) &#123; for (let y = 1; y &lt; 100; y++) &#123; for (let z = 1; z &lt; 100; z++) &#123; if ((x + y + z === 100) &amp;&amp; (5 * x + 3 * y + z / 3 === 100)) &#123; document.write('当前 公鸡'+x+'只, 母鸡'+y+'只, 小鸡 '+z+'只'+'&lt;br&gt;'); &#125; &#125; &#125; &#125;","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"循环","slug":"循环","permalink":"https://cooli-willson.github.io/tags/%E5%BE%AA%E7%8E%AF/"},{"name":"对象","slug":"对象","permalink":"https://cooli-willson.github.io/tags/%E5%AF%B9%E8%B1%A1/"}]},{"title":"2.javascript 运算符","slug":"2.js基础-运算符","date":"2020-01-20T14:42:27.505Z","updated":"2020-01-20T17:14:12.032Z","comments":true,"path":"2020/01/20/2.js基础-运算符/","link":"","permalink":"https://cooli-willson.github.io/2020/01/20/2.js%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"算术运算符 字符相加 1234567891011121314151617181920 // 隐式转换 多种数据类型不同时，进行运算需要将这些数据转换为相同类型才能运算，这个过程就是隐式转换 var a=\"a\"; var b=\"b\"; var b=3; var b=true; var b=false; var b; var b=null; var b=&#123;a:1&#125;; // 遇到字符串相加时，另一种数据隐式转换为字符型.String() // 遇到字符串相加时，另一种数据隐式转换为字符型.String() console.log(a+b);//字符相加时，首尾相连 var age=30; var s=\"今年我\"+age+\"岁了\"; console.log(s); var s=10; s=s+\"\"; console.log(s); // 等号是赋值，因此先运算等号右边的结果，然后赋值给等号左边 布尔值相加 12345678// 布尔值相加，不包含加字符 // 布尔值转换为数值，除字符外所有内容都是隐式转换为数值运算 Number() var a=true; var b=3; var b=true; var b; var b=null; // 任何数值加NaN都为NaN 对象相加 12345678 // Object 对象相加时都会转换为字符串相加 var a=&#123;a:1&#125;; var b=&#123;b:1&#125;; console.log(a+b); var arr=[1,2,3];//数组转换为字符串时是将数组的元素转换为字符串相连 var a=&#123;a:1&#125;; console.log(arr+a); console.log([]+[]); 数值运算 12345678 // 减法 乘法 除法 取模都遵循转换为数值运算 var a=true; var b=false; var b=\"5\"; var b; var b=null; var b=&#123;a:1&#125;; console.log(a*b); 赋值运算符和一元运算符 赋值运算符 1234567891011121314// 赋值运算符 var a=3; a+=5;//a=a+5; a+=\"\";//快速转换字符串 a*=3; a/=3; a%=2; a-=2; // 赋值运算符也是有结果的 var s=a+=2; console.log(s,a); if(a-=2)&#123; console.log(\"a\"); &#125; 一元运算符 12345678910111213141516171819202122232425var a=\"3\";a++;//a=a+1 a+=1;//31a++;//一元运算符强制将值转换为数值+1var a=3;console.log(a+=1);// a=a+1 a-&gt;返回结果console.log(a++);// a-&gt;返回出来 a=a+1;console.log(++a);//a=a+1 a-&gt;返回结果// a++和++a a的结果相同 返回结果不同var y=a++;var y=++a;var x=1;if(--x)&#123; console.log(\"aa\");&#125;var x=1; x=2-3-4-5 1+2+2+3+4var y=x++ + x + x++ + x++ + x++;var y=x + ++x + x++ +x++ + x++;console.log(y,x);console.log(\"2\"&gt;\"10\"); //trueconsole.log(undefined==null); console.log(undefined&gt;null); ### 关系运算符 **关系运算符** &gt; 大小比较 12345678// &gt; &lt; &gt;= &lt;= == === != !==var a=\"aa\";var b=\"ab\";console.log(b&gt;a);//判断字符串大小时先判断字符串首字符的ascii 或者 Unicode码值,如果相同判断后面字符的比较结果console.log(true&gt;false);//隐式转换为数值console.log(true&gt;\"\");console.log(\"a\"&gt;1);//字符串与数值比较时，字符串转换为数值再比较console.log(undefined&gt;null); 辅助运算符和相等关系运算符 = 赋值 == 比较 === 精确比较 比较值和类型 123456789101112131415161718192021222324252627282930313233343536console.log(\"1\"==1);console.log(\"\"==0);console.log(0==false);console.log(\"\"==false);0==\"\"== falseundefined==null console.log(undefined==null);//判读空的结果是否相同console.log(null==\"\");//falseconsole.log(null==0);//falseconsole.log(null==false);//false// NaN永远不和任何内容相等，包括NaNvar a=\"a\";if(a==NaN)&#123; // 判断a是否是NaN // isNaN()里面的内容会自动隐式转换为数值if(isNaN(a))&#123; console.log(\"非数值\");&#125;var a;if(a==null)&#123; // undefined null console.log(\"aa\");&#125;if(a==0)&#123; // a是0 false \"\"&#125; var obj=&#123;a:1&#125;; var obj1=&#123;a:1&#125;; console.log(obj==obj1); // 引用地址不同 console.log([]==[]); console.log(\"1\"==1); console.log(\"1\"===1);//比较值和类型 // != 不相等 console.log(0!=null); console.log([]!=[]); 逻辑运算符 逻辑与 1234true &amp;&amp; true =true;true &amp;&amp; false =false;false &amp;&amp; true =false;false &amp;&amp; false =false; 逻辑或 1234true || true =true;true || false =true;false || true =true;false || false =false; 逻辑运算符与一元运算符的应用 &amp;&amp; 运算的两端，如果有一端转换为布尔值是false，就把这个值返回出去（值是什么就返回什么，不是返回false） 如果两端转换为布尔值都是true，就返回&amp;&amp;运算符右侧的值，先运行左侧再运行右侧 如果左侧运算的结果是false，直接返回左侧值，不运算右侧 + 如果||的左侧的结果是ture，就直接返回左侧，不运算右侧，熔断 12345678910111213 var a=1;a=a-- &amp;&amp; ++a;s=--a &amp;&amp; ++a;a=a++ &amp;&amp; --a;console.log(s,a);// &amp;&amp; 运算的两端，如果有一端转换为布尔值是false，就把这个值返回出去（值是什么就返回什么，不是返回false）// 如果两端转换为布尔值都是true，就返回&amp;&amp;运算符右侧的值，先运行左侧再运行右侧// 如果左侧运算的结果是false，直接返回左侧值，不运算右侧var a=1;a=--a || a++;a=a-- || a++;// 如果||的左侧的结果是ture，就直接返回左侧，不运算右侧，熔断console.log(a); &gt; 逻辑非 + !取反值，先将内容转换为布尔值，然后去反值 +所有！运算符得到的结果都是布尔值 12345678// !取反值，先将内容转换为布尔值，然后去反值console.log(!10);//falseconsole.log(!\"\");//true// 所有！运算符得到的结果都是布尔值console.log(!obj1);console.log(obj==!obj1);console.log(![]==[]);//trueconsole.log([]==[]);//false 二进制和十六进制（未详细整理） 1234567891011121314151617181920212223242526 // 数值转换二进制 0,1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 20 0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111,10000 0,1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 0,1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10 56=5*8(1)+6*8(0)=46 1010=1*2(3)+0*2(2)+1*2(1)+0*2(0)=10; 567=5*10(2)+6*10(1)+7*10(0);//16进制 RGB 0xFFFFFF 0xFF0000 0x00FF00 0x0000FF 0x000000 0xFFFF00 黄色 0xFF9900 橙色 0xFF00FF 紫色 0x00FFFF 靛色 0xFFFFFFFF 180*180 64 128 512 32400*4=129,600 console.log(Boolean(\"abc\"&gt;\"aad\")); 位运算（未详细整理） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 console.log(~3); var str=\"abcdef\"; console.log(str.indexOf(\"z\")); if(~str.indexOf(\"z\"))&#123; console.log(\"找到了z\"); &#125; // 位与运算 &amp; console.log(5&amp;6); 101 110 100=4; // 1&amp;1=1 // 1&amp;0=0 // 0&amp;1=0 // 0&amp;0=0 10101010 10 10101000 // 位或运算 | console.log(7|6); 111 110 111=7 // 1|1=1 // 1|0=1 // 0|1=1 // 0|0=0 console.log(85|1); // 位异或运算 ^ console.log(7^6); 111 110 001 // 1^1=0 // 1^0=1 // 0^1=1 // 0^0=0 var pass=7856; var key=2534; var value=pass^key; // console.log(pass^key); console.log(value^key); // &lt;&lt;左移位 &gt;&gt;右移位 console.log(24&gt;&gt;2); // 11000&gt;&gt;2 ==&gt; 110; // 8&lt;&lt;2 100000==&gt;32; // 1&lt;&lt;n 求2的多少次幂 console.log(1&lt;&lt;5); console.log( (0x0000FF&lt;&lt;16).toString(16))","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"运算符","slug":"运算符","permalink":"https://cooli-willson.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"}]},{"title":"1.javascript 基础-数据类型","slug":"1.javascript 基础-数据类型","date":"2020-01-20T13:51:37.020Z","updated":"2020-01-20T19:08:26.065Z","comments":true,"path":"2020/01/20/1.javascript 基础-数据类型/","link":"","permalink":"https://cooli-willson.github.io/2020/01/20/1.javascript%20%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"js 文件的引入 引入外部js 12&lt;script src=\"a.js\" async defer&gt;&lt;/script&gt;&lt;script src=\"b.js\"&gt;&lt;/script&gt; ES6的模块化导入 1234&lt;script type=\"module\"&gt; // ES6的模块化导入 import Box from \"./js/Box.js\"; &lt;/script&gt; 行内js的写法 123&lt;button onclick=\"alert('aaa')\"&gt;按钮&lt;/button&gt;&lt;a href=\"javascript:alert('aaa')\"&gt;超链接&lt;/a&gt;&lt;a href=\"javascript:void(0)\"&gt;超链接&lt;/a&gt; js标签 123456789 &lt;script&gt; a=10; &lt;/script&gt; &lt;script&gt; alert(b); &lt;/script&gt; &lt;script&gt; b=20;&lt;/script&gt; js注释 123456// a=3;//注释单行代码 /* a=3; b=4; */ //块状注释 // 不需要的禁止执行，注释后代码不会被执行，在以后可以复用 // 介绍说明代码作用 弹出框 123alert(\"aaa\");//弹出框confirm(\"你好\");//点击确定时返回true，否则返回falseprompt(\"请输入你的年龄\",\"18岁\");//输入弹出框，确定后会返回输入的内容 打印方式 1234console.log(\"aaaa\",\"bbbb\");//打印日志console.trace(\"aaa\");//用于显示当前执行的代码在堆栈中的调用路径。console.dir(\"aaa\");//打印部分标签内容console.error(\"错误的\");//打印错误 变量 常量和基本数据类型 变量 1234567891011a=4; b=6; // 定义变量 var a=4; var b=5; // 使用；结束一个代码语句，如果使用，表示没有结束该语句 var a=4, b=5; var a,b; // 先给a赋值，然后赋值给b var a=b=4; 变量命名规则 1234567891011121314151617181920212223242526272829303132 // 变量名称规则 // 变量要求小写字母开始，每个单词的首字母大写，叫做驼峰式命名 // var timeManager // 变量不能使用关键词和保留字 // var for; var int; // 变量尽量不要定义window的属性名，ES5中全局变量都会被设置在window的属性中 var a=10; console.log(window.a); console.log(a+5); window.status var status=20; console.log(status+5); //205 // 临时变量或者参数，起名时使用_开始 var _time=20;// 不能使用中文和拼音字母（我强制大家不能使用） var 姓名=\"谢天\"; console.log(姓名); var xingming=\"谢天\";var a=3; a=10;//值可以改变，就叫做变量 // 不希望值改变，常量ES6,常量不能修改 const EVENT_ID=\"eventid\"; EVENT_ID=\"abc\"; // 常量定义后的对象不能够被清除 const obj=&#123;a:1,b:2&#125;; 数据类型 字符型，数值型，布尔型，undefined,null,object ||E6 Symbol 五种基础类型，一种复杂类型 字符类型 1234567// 字符类型 String// \"\" '' ||ES6 `` var str1 = \"1\"; var str2 = '1'; var str3 = `1`; var str4 = \"这个'新的'鞋子价格不错\"; var str5 = '&#123;\"a\":4,\"b\":\"10\"&#125;'; 数值类型 123456789// 数值类型 Number var num1 = 1;//正整型var num2 = -1;//负整型var num3 = 1.3;//浮点型var num4 = 056;//8进制数值,0起头，数值不能大于7var num5 = 0xFF;//16进制数值，0x起头，单个数值不能大于Fvar num6 = 1.2e+3;//科学计数法var num7 = 1.2e-3;//科学计数法` 布尔类型 123// 布尔类型 Boolean var bool1 = true; var bool2 = false; 未定义型 123// 未定义型 undefined 值和类型相同 var und1; var und2 = undefined; 空值 123// 空值 null null的类型Object型 var nu = null; console.log(nu,typeof(nu)); 对象类型 123456789var obj = &#123; // 属性 id: 1001, name: \"电脑桌\", price: \"700\", getSum: function () &#123; // 方法 &#125; &#125;; 数据类型的存储 前五种基础类型都存储在栈中，对象存储在堆中 对象类型的特性 1234567891011121314151617181920212223242526var obj=&#123;a:1&#125;; console.log(String(obj));//[object Object] 所有的对象转换为字符串就会变成这样 console.log(JSON.stringify(obj));//将object对象转换为字符串（JSON字符串） console.log(JSON.parse('&#123;\"a\":1&#125;'));//将JSON字符串转换为对象 var obj1=JSON.parse(JSON.stringify(obj)); obj.a=5; console.log(obj,obj1) console.log(JSON.stringify(obj),JSON.stringify(obj1)); console.log(obj1===obj); // 变量名存储的是引用地址 var obj2=obj;//将引用地址赋值给obj2 obj.a=10; console.log(obj2.a); // 存在栈中，修改的是值 var num=3; var num1=num; num=10; console.log(num1); // 存在堆中，修改引用地址值的内容，地址不会发生改变 var obj1=JSON.parse(JSON.stringify(obj)); var obj=&#123;a:10,b:&#123;a:20&#125;&#125;; console.log(obj); obj.a=10; // 内存泄漏 不断的创建新对象，不使用的旧对象不清除 obj=null;//当给变量设置为null // 垃圾回收机制 gc 当对象的引用地址在栈中没有引用时，内存占比过高时，垃圾回收车会将其清除 数据类型的转换 任何类型转换为数值型 123456789101112131415161718192021222324252627// NaN 数值型 非数值var a=\"5\";var a=\"5a\";//字符串中如果有字符存在，转换后就变成NaNvar a=\"\";//空字符串转换为数值是 0var a=true;//1var a=false;//0var a;//undefined NaN 非数值var a=null;//0 null是0Number(值);console.log(Number(a));var a=\"52.1a\";//使用parseInt转字符串，从第一个数字字符开始到第一个字符类型为止转换为数值var a=\"a45\";//使用parseInt转字符串，从第一个数字字符开始到第一个字符类型为止转换为数值var a=\"4a5\";//使用parseInt转字符串，从第一个数字字符开始到第一个字符类型为止转换为数值var a=\"FF\";var a=\"101010010101\";color=\"#FF00FF\"--&gt;\"rgb(255,0,255)\";var a=true;//NaNvar a=false;//NaNvar a;//NaNvar a=null;//NaNvar a=&#123;a:1&#125;;console.log(Number(a));//NaN// parseInt(要转换的内容，该内容是什么进制) 将他转换为10进制数值console.log(parseInt(a,2))//转换为整型console.log(parseInt(a))//字符串转换为整型console.log(parseFloat(a))//字符串转换为浮点型 任何类型转换为字符串 1234567891011121314151617181920212223var a=10; var a=1555; var a=0; var a=0xFF; var a=4.1e+2; // 先将所有的数值都转换为10进制在转换为字符串 var a=true; var a=false; var a;//undefined var a=null;//null var a=&#123;a:1&#125;; console.log(a); console.log(String(a));//转换为字符串 // a.toString(按照什么进制转换为字符串); console.log(a.toString(36));//2-36 var a=new Date(); console.log(a.toLocaleString());//转换为本地字符串 console.log(a.toUTCString());//转换为格林尼治时间字符串 console.log(a.toString()); // toFixed toPrecision toExponential 都是针对数值转换 console.log(a.toFixed(1));//保留几位小数,会自动四舍五入 console.log(a.toPrecision(2));//总共保留几位，会自动四舍五入或者科学计数法 console.log(a.toExponential(2));//小数点后保留几位，不会自动四舍五入，一定科学计数法 任何类型转换为布尔值 1234567891011121314var a=\"\";//falsevar a=0;//falsevar a=undefined;//falsevar a=null;//falsevar a=NaN;//falsevar a=false;console.log(Boolean(a));// \"\" 0 undefined null NaN false 转换为布尔值都是false// 除上述6种以外转换为布尔值都是truevar a=\"0\";console.log(Boolean(a));var a=3;// 强转为对象类型console.log(Object(a));","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"数据类型","slug":"数据类型","permalink":"https://cooli-willson.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"通过数组方法实现的简单功能","slug":"通过数组方法实现的简单功能","date":"2020-01-19T08:04:27.014Z","updated":"2020-01-20T17:14:20.222Z","comments":true,"path":"2020/01/19/通过数组方法实现的简单功能/","link":"","permalink":"https://cooli-willson.github.io/2020/01/19/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%9F%E8%83%BD/","excerpt":"","text":"实现功能 去重 原生版 12345678910111213141516var arr=[1,2,2,4,3,4,5,4,2,6,2,7]; var arr1=[]; for(var i=0;i&lt;arr.length;i++)&#123; //遍历当前数组的长度 var bool=false; //flag for(var j=0;j&lt;arr1.length;j++)&#123; //循环arr1长度 if(arr[i]===arr1[j])&#123; //当arr的元素全等于arr1 bool=true; //改变flag的布尔值 break; //跳出循环 &#125; &#125; if(!bool)&#123; arr1.push(arr[i]); //将arr的元素赋值给arr1 &#125; &#125; arr=arr1.splice(0); arr1=null; 去重indexOf版 123456789 var arr=[1,2,2,4,3,4,5,4,2,6,2,7]; var arr1=[]; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr1.indexOf(arr[i])&lt;0) arr1.push(arr[i]); //当arr下的每个元素在index属性下返回负一时 将元素储存在arr1中 ？？？ &#125; arr=arr1.splice(0); arr1=null; console.log(arr); 去重delete版 123456789101112var arr=[1,2,2,4,3,4,5,4,2,6,2,7]; for(var i=1;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr.indexOf(arr[i],i+1)&gt;-1) delete arr[i]; //要查找的元素下标为i,从i+1开始，当找到相同元素时，将下标为i的元素删除 if(arr.lastIndexOf(arr[i],i-1)&gt;-1) delete arr[i]; //倒叙遍历，重复以上操作 &#125; var arr1=[]; //空数组arr1; for(var prop in arr)&#123; //循环arr的长度 arr1.push(arr[prop]); //将arr的元素储存在arr1中 &#125; arr=arr1.splice(0); //将arr数组的所有元素传递给arr1 arr1=null; //清空数组arr1 console.log(arr); //控制台打印arr 数组的遍历 for循环遍历 123456var arr=[1,2,3,,4,5,6]; arr.a=3; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 console.log(i,arr[i]); //打印下标 和下标的每个元素 &#125; for in循环遍历 12345for in 循环可以把数组的可枚举属性遍历到for in不能遍历到数组的空元素 for(var prop in arr)&#123; //prop相当于数组的下标 console.log(prop,arr[prop]); //打印下标，和下标的每个元素 &#125; 将获取的标签元素转换为数组类型 123456789// ES6var list=Array.from(inputs);console.log(list);// ES5var list=Array.prototype.slice.call(inputs);var list=[].slice.call(inputs);var list=Array.prototype.concat.apply([],inputs);var list=[].concat.apply([],inputs); 实现列表的全选功能??? 12345678910111213141516171819202122232425262728293031323334&lt;ul&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;全选&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;/ul&gt; var inputs=document.getElementsByTagName(\"input\"); //将获取的input标签的元素储存在inputs中 var arr=Array.from(inputs); //将获取的标签元素转换为数组类型 for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 arr[i].onclick=clickHandler; //当点击时调用clickHandler函数 &#125; function clickHandler()&#123; var self=this; //将当前元素用self存储 if(arr.indexOf(this)===0)&#123; //当前元素为0时 arr.forEach(function(item,index)&#123; if(index===0) return; //当前元素下标为0时 返回 // foreach中this被重新指向到window（所有的回调函数） item.checked=self.checked; //将所有元素都天机checked属性 &#125;) &#125;else&#123; arr[0].checked=arr.slice(1).every(function(item)&#123; //？？？ return item.checked; //??? &#125;) &#125; &#125; 对表格中的商品通过属性进行筛选 123456789101112131415161718192021var data=[ &#123;id:1001,icon:\"img/1.png\",name:\"餐饮0\",num:1,price:10&#125;, &#123;id:1002,icon:\"img/2.png\",name:\"餐饮1\",num:1,price:20&#125;, &#123;id:1003,icon:\"img/3.png\",name:\"餐饮2\",num:1,price:30&#125;, &#123;id:1004,icon:\"img/4.png\",name:\"餐饮3\",num:1,price:40&#125;, &#123;id:1005,icon:\"img/5.png\",name:\"餐饮4\",num:1,price:50&#125;, &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;, &#123;id:1007,icon:\"img/7.png\",name:\"餐饮6\",num:1,price:70&#125;, &#123;id:1008,icon:\"img/8.png\",name:\"餐饮7\",num:1,price:80&#125;, &#123;id:1009,icon:\"img/9.png\",name:\"餐饮8\",num:1,price:90&#125;, &#123;id:1010,icon:\"img/10.png\",name:\"餐饮9\",num:1,price:100&#125;];var arr=data.filter(function(item)&#123; return item.price&gt;60; //返回所有价格&gt;60的元素&#125;)console.log(arr);var item=data.filter(function(item)&#123; return item.id==1006; //返回id==1006的元素&#125;)[0];console.log(item); 实现购物车功能 12345678910111213141516171819202122var data=[ &#123;id:1001,icon:\"img/1.png\",name:\"餐饮0\",num:1,price:10&#125;, &#123;id:1002,icon:\"img/2.png\",name:\"餐饮1\",num:1,price:20&#125;, &#123;id:1003,icon:\"img/3.png\",name:\"餐饮2\",num:1,price:30&#125;, &#123;id:1004,icon:\"img/4.png\",name:\"餐饮3\",num:1,price:40&#125;, &#123;id:1005,icon:\"img/5.png\",name:\"餐饮4\",num:1,price:50&#125;, &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;, &#123;id:1007,icon:\"img/7.png\",name:\"餐饮6\",num:1,price:70&#125;, &#123;id:1008,icon:\"img/8.png\",name:\"餐饮7\",num:1,price:80&#125;, &#123;id:1009,icon:\"img/9.png\",name:\"餐饮8\",num:1,price:90&#125;, &#123;id:1010,icon:\"img/10.png\",name:\"餐饮9\",num:1,price:100&#125; ]; data.forEach(function(item)&#123; //遍历整个数组 item.selected=Math.random()&lt;0.5; //随机选择被选中的元素 item.num=parseInt(Math.random()*5+5); //给num属性随机赋值 item.total=item.num*item.price; //将数量和价格相乘得出的结果付给tatal（总价） &#125;); var sum=data.reduce(function(value,item)&#123; //归并data并且赋值到sum中 return item.selected ? value+item.total : value; //若选中就加到vale中，没有选则不加 &#125;,0); console.log(sum);","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"数组","slug":"数组","permalink":"https://cooli-willson.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"功能","slug":"功能","permalink":"https://cooli-willson.github.io/tags/%E5%8A%9F%E8%83%BD/"}]},{"title":"数组方法的重构","slug":"数组方法的重构","date":"2020-01-19T08:04:24.522Z","updated":"2020-01-20T17:14:16.491Z","comments":true,"path":"2020/01/19/数组方法的重构/","link":"","permalink":"https://cooli-willson.github.io/2020/01/19/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E6%9E%84/","excerpt":"","text":"数组方法的重构 push 功能： *在数组尾部添加一个或者多个新元素，并且返回数组的新长度 使用方法： 1arr.push(5,6,7); push 重构 123456789var arr=[1,2,4,5,67,78];function push(arr)&#123; //传入参数为数组 for(var i=1;i&lt;arguments.length;i++)&#123; //循环除数组外其他元素的长度 arr[arr.length]=arguments[i]; //在尾部添加参数通过下标赋值 &#125; return arr.length; //返回数组长度 &#125;var i=push(arr,5,6,7); //调用push方法，参数为数组，5，6，7console.log(arr,i); */ //数组长度，新数组 pop 功能： #### *删除数组的**尾部**元素，并且返回这个**被删除的元素** 使用方法： 12// var item=arr.pop();// console.log(item,arr); pop 重构 1234567function pop(arr)&#123; var item=arr[arr.length-1]; //用item储存最后一个参数 arr.length--; //数组的长度减一 return item; //返回这个被删除的参数 &#125;pop(arr); unshift 功能： *将一个或者多个新元素添加在数组的最前面，返回数组的新长度 使用方法： 1arr.unshift(1,2,3); unshift 重构 12345678910111213function unshift(arr)&#123; var len=arguments.length-1; //len储存除数组以外的其他元素的长度 for(var i=arr.length-1;i&gt;=0;i--)&#123; //循环当前数组的长度 arr[i+len]=arr[i]; //将当前数组的元素向后移 &#125; for(var j=1;j&lt;arguments.length;j++)&#123; //循环参数的长度（除arr外） arr[j-1]=arguments[j]; //将参数赋值给数组的前面 &#125; return arr.length; //返回数组的新长度 &#125; unshift(arr,10,11,12); console.log(arr); shift 功能： 删除数组的第一个元素，并返回该元素 使用方法 1arr.shift(); shift 重构 123456789101112function shift (arr) &#123; if (!(arr instanceof Array)) throw new Error(\"请确保参数类型为数组\") //判断传入参数是否为数组 var el; if (arr.length &gt; 0) &#123; //如果数组有长度 el = arr[0] //将第一个元素储存在el中 for (var i = 0; i &lt; arr.length - 1; i++) &#123; //循环数组的长度 arr[i] = arr[i + 1] //将数组的每个元素前移一位 &#125; arr.length = arr.length - 1 //数组的长度减一 &#125; return el&#125; concat 功能： *复制，复制后给新数组添加新元素，多个数组连接形成数组 使用方法 123var arr=[1,2,3,4];var arr1=arr.concat(10,11,12); //连接形成新数组var arr1=arr.concat(); //复制数组 concat 重构??? 123456789101112131415161718function concat(arr)&#123; var array=[]; //定义一个新数组 var index=0; //下标变量 for(var i=0;i&lt;arr.length;i++,index++)&#123; // 循环数组的长度 array[index]=arr[i]; //将数组复制arr数组到array数组 &#125; for(var j=1;j&lt;arguments.length;j++,index++)&#123; //遍历参数的长度(除数组外) if(arguments[j].constructor===Array)&#123; //当参数为数组时 for(var k=0;k&lt;arguments[j].length;k++,index++)&#123; //遍历数组的长度 array[index]=arguments[j][k]; //将参数为数组的参数赋值给 &#125; index--; &#125;else&#123; array[index]=arguments[j]; &#125; &#125; return array; &#125; join 功能： *转换为字符串，使用参数进行分割 使用方法 123console.log(arr.join()); console.log(arr.join(\"#\"));//1#2#3#4console.log(arr.join(\"\"));//1234 join 重构（myself） 123456789function join(arr,and)&#123; //参数为数组和连接符 for(var i = 0; i&lt;arr.length-1;i++)&#123; //循环数组长度 arr[i]+=and; //数组加入连接符 &#125; return arr; &#125; var arr = [3, 1, 6, 5, 4, 8, 9]; join(arr,\"|\"); document.write(arr); splice 功能： *给数组中添加、删除、替换一个或者多个元素，返回被删除元素组成的数组 使用方法 12345678910111213141516// arr.splice(从什么位置开始,删除多少个元素,添加的元素...); // var arr1=arr.splice();//创建一个空数组// var arr1=arr.splice(0);//将数组的所有元素传递给新数组// 负数指从后向前数// var arr1=arr.splice(-2);//从数组的倒数第二位开始截取到尾部// var arr1=arr.splice(2,2);//从第二位开始删除2个元素// var arr1=arr.splice(ar2,0,12,14);//插入元素13，14，插入在第二位// var arr1=arr.splice(2,2,12,14);//替换元素，删除两位并且插入12，14// console.log(arr1,arr); splice 重构 1234567891011121314151617181920212223242526function splice(arr,start,count)&#123; //第一个参数是数组 第二个参数是开始位置 第三个参数是一共替换几个参数 var a=[]; //定义一个空数组 start=Number(start); //将开始参数设为数值型 count=Number(count); //将count转为数值型 if(isNaN(start))return a; //如果start为NaN 返回空数组 if(start&lt;0) start+=arr.length; //如果start小于0 start等于数组长度 数据从最后一位开始插入 if(isNaN(count)) count=arr.length-start; //？？？ for(var i=start,j=0;i&lt;arr.length;i++,j++)&#123; //遍历从start位置开始长度小于数组的长度 if(j&lt;count) a.push(arr[i]); //当循环次数小于count参数时储存在arr当前下标位置 arr[i]=arr[i+count]; //arr当前下标的值等于i+count; &#125; for(var l=0;l&lt;arguments.length-3;l++)&#123; //遍历处前三个参数外其他参数的值 for(var m=arr.length-1;m&gt;=start+l;m--)&#123; //??? arr[m+1]=arr[m]; //??? &#125; &#125; for(var n=3;n&lt;arguments.length;n++)&#123; //循环参数的长度 arr[start+n-3]=arguments[n]; //设定参数在数组中的下标赋值 &#125; for(var k=0;k&lt;count;k++)&#123; //替换时减去数组的长度 arr.length--; &#125; return a; &#125; var arr1=splice(arr,2,2,10,11,12); console.log(arr1,arr); slice 功能： *截取数组的某一段的值，返回一个新数组，原数组不改变 使用方法 1234567// var arr1=arr.slice();//复制一个新数组 // var arr1=arr.slice(1);//从第几项复制到尾部 // var arr1=arr.slice(-2);//从倒数第二位复制到尾部 // var arr1=arr.slice(2,3);//从第二位复制到第三位之前 // var arr1=arr.slice(-3,-1);//从倒数第三位复制到倒数第一位之前 // var arr1=arr.slice(2,-1);//从第二位复制到倒数第一位之前 // console.log(arr1,arr); slice 重构 123456789101112131415function slice(arr,start,end)&#123; //第一个参数为数组 第二个值为开始截取位置 start=Number(start); //将参数转为数值型 end=Number(end); //将参数转为数值型 if(isNaN(start)) start=0; //如果start为NaN 将strat变为0； if(isNaN(end)) end=arr.length; //如果end为NaN if(start&lt;0) start=start+arr.length; //如果参数为0,start为数组的长度 if(end&lt;0) end=end+arr.length; //如果参数为0，end为数组的长度 var a=[]; for(var i=start,j=0;i&lt;end;i++,j++)&#123; //循环开始到结束的下标 a[j]=arr[i]; //将截取的数组赋值给新数组a &#125; return a; //返回新数组 &#125; var arr1=slice(arr,2,-1); console.log(arr1,arr); indexOf 功能： *查找元素在数组中的下标，如果没有查找到返回-1 使用方法 1234567891011 //从前向后查找arr.indexOf(要查找的元素,从第几位开始查找被包含);console.log(arr.indexOf(3,2)); // 从后向前查找arr.lastIndexOf(要查找的元素,从第几位开始查找被包含); var index=-1;while(~(index=arr.indexOf(2,index+1)))&#123; //~加一取反 循环条件也是表达式 console.log(index)&#125; indexOf重构 1234567891011121314151617181920212223function CreateString(str)&#123; var obj = &#123; data: str, //indexOf 方法 IndexOf: function (chara1) &#123; for (var i = 0; i &lt; this.data.length; i++) &#123; if (str.substr(i, chara1.length) == chara1&#123; break; &#125; &#125; return i; &#125;, //lastIndexOf 方法 LastIndexOf: function (chara2) &#123; for (var i = this.data.length; i &gt; 0; i--) &#123; if (this.data.substr(i, chara2.length) == chara2) &#123; break; &#125; &#125; return i; &#125; &#125;&#125; delete 功能： #### *删除数组元素，不会造成数组的自动收缩，紧密，数组的长度不会发生改变 使用方法： 123var arr=[1,2,3,4,5,6];delete arr[2];console.log(arr); forEach循环 功能： *forEach不遍历空元素，也不遍历属性，forEach是匿名函数，无法阻止它在循环中中断循环跳出 使用方法： 12345var arr=[2,4,6,8,10,,12,14,16,18,20]; arr.a=10;arr.forEach(function(item,index,a)&#123; //item:当前元素 index:当前元素的下标 当前元素所属的数组对象 console.log(item,index,a);&#125;); forEach重构 1234567891011function forEach(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr[i]===undefined) continue; //当前元素为空时，直接执行下一次循环 fn(arr[i],i,arr); //fn参数为：当前元素，当前元素下标，当前元素的数组对象 &#125; &#125; // 桥接模式forEach(arr,function(item,index,a)&#123; //调用forEach函数 console.log(item,index,a); //打印每个参数值&#125;) */ map 功能： 1map同样不会遍历空数组，map与forEach不同的是：forEach不能返回任何内容，map会将回到函数中return的结果返回到新数组中 使用方法： 12345var a=arr.map(function(item,index,a)&#123; console.log(item,index,a); return item; &#125;);console.log(a); 重构map 12345678910111213function map(arr,fn)&#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr[i]===undefined) continue; //当前元素为空时直接进行下一次循环 a[i]=fn(arr[i],i,arr); //将函数fn存放在数组中 &#125; return a; //返回数组a,元素为每个函数 &#125; var a=map(arr,function(item,index,a)&#123; return item; &#125;); console.log(a); some 功能： 遍历数组，查找是否有满足条件（返回的结果如果是true）就直接跳出遍历，返回true 使用方法: 12345678910var arr=[1,2,3,4,5,6]; if(arr.some(function(item)&#123;item&gt;3&#125;))&#123; //遍历arr,查询元素是否有大于3的，有的话返回true &#125; var bool=arr.some(function(item,index,a)&#123; return item&gt;4; //遍历arr,查询元素是否有大于4的，有的话返回ture &#125;) console.log(bool); //打印结果为ture some重构 123456789101112function some(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr[i]===undefined) continue; //如果数组的元素为空，直接执行下一次的循环 if(fn(arr[i],i,arr)) return true; //如果fn函数的返回值为ture 返回ture &#125; return false; //当第二个if语句条件不成立时，返回flase &#125; var bool=some(arr,function(item)&#123; //执行some函数，返回值储存在bool中 return item&gt;10; //判断表达式的值并返回 &#125;) console.log(bool); every 功能： *判断每一个是否都满足条件，如果有一个返回的结果是false，直接返回false 使用方法： 1234var bool=arr.every(function(item)&#123; return item&gt;4; &#125;); console.log(bool); every重构 1234567891011function every(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; if(!fn(arr[i],i,arr)) return false; //当条件不满足时返回false &#125; return true; &#125; var bool=every(arr,function(item)&#123; return item&gt;4; //返回boolean值类型 &#125;); console.log(bool); fill 功能： *用于将一个固定数值替换数组的元素 使用方法： 123456789101112131415array.fill(value, start, end)参数 描述value 必需。填充的值。start 可选。开始填充位置。end 可选。停止填充位置 (默认为 array.length)填充 \"Runoob\" 到数组的最后两个元素：var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.fill(\"Runoob\", 2, 4);输出结果：Banana,Orange,Runoob,Runoob fill重构 12 filter 功能： *创建一个新的数组，新数组中的元素时通过检查置顶数组中符合条件的所有元素 注意： filter() 不会对空数组进行检测。 注意： filter() 不会改变原始数组。 使用方法： 123456789101112var arr1=arr.filter(function(item,index,a)&#123; // console.log(item,index,a); return item&gt;4; //当条件成立时返回 &#125;); console.log(arr1); array.filter(function(currentValue,index,arr), thisValue);参数 描述currentValue 必须。当前元素的值index 可选。当前元素的索引值arr 可选。当前元素属于的数组对象 filter 重构 123456789101112function filter(arr,fn)&#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(fn(arr[i],i,arr)) a[a.length]=arr[i]; //将在arr数组中满足条件的元素储存到a数组中 &#125; return a; &#125; var arr1=filter(arr,function(item)&#123; return item&gt;4 //符合表达式的进行返回 &#125;); console.log(arr1); reduce 功能： 归并 arr.reduce(function(上次归并值，本次遍历的元素，索引值，数组),初始化值)； 如果没有设置初始化值，上次归并值初始值为数组的第0项，本次遍历将从下标1开始 如果设置了初始化值，上次归并值初始值就是初始化值，本次遍历将从下标0开始* 使用方法： 1234567//arr.reduce(function(上次归并值，本次遍历的元素，索引值，数组),初始化值)； var arr=[1,2,3,4,5]; var sum= arr.reduce(function(value,item,index,a)&#123; //上次归并值，本次遍历的元素，下标，数组 console.log(value,item); return value+item; //返回归并值 &#125;,100); //初始化值为100 console.log(sum); */ reduce 重构 12345678910111213141516171819202122function reduce(arr,fn,initValue)&#123; //参数为 数组 初始化值 var start=0; if(initValue===undefined)&#123; //如果初始化值未定义 initValue=arr[0]; //将数组的第一个元素设为初始化值 start++; &#125; for(var i=start;i&lt;arr.length;i++)&#123; //当初始化值为第一个元素时，从第二个开始归并 initValue=fn(initValue,arr[i],i,arr) //桥接模式 &#125; return initValue; //返回初始值也就是归并值 &#125; var arr=[1,2,3,4]; var sum=reduce(arr,function(value,item)&#123; return value+item; //返回归并值 &#125;,100); console.log(sum); var sum=arr.reduce(function(value,item)&#123; //调用归并函数 console.log(value); &#125;,null) reverse 功能： * 倒序，不排序，原数组改变，返回原数组 使用方法 123var arr=[1,4,6,2,3,8,7,6,5,3,9];arr.reverse();console.log(arr); reverse 重构 1234567891011121314function reverse(arr)&#123; var len=parseInt(arr.length/2); //长度为数组长度的1/2 for(var i=0;i&lt;len;i++)&#123; //循环一数组1/2的长度 // arr[arr.length-1-i]=arr[i]; var temp=arr[arr.length-1-i]; //将最后一位赋值给临时变量 arr[arr.length-1-i]=arr[i]; //将第一位赋值给最后一位 arr[i]=temp; //将临时变量的值赋给第一位 &#125; return arr; //返回这个数组 &#125; reverse(arr); console.log(arr); sort 功能： *用于对数组的元素进行排序 使用方法： 123456789arrayObject.sort(sortby);参数 描述sortby 可选。规定排序顺序。必须是函数。arr.sort(); //按照ASCII码值进行排序 arr.sort(function(a,b)&#123; return a-b; //从大到小排列 &#125;) console.log(arr); sort重构 冒泡排序： 123456789101112131415161718192021222324252627282930var arr=[]; for(var i=0;i&lt;100;i++)&#123; arr.push(i); //创建一个1-100的数组 &#125; arr.sort(function()&#123; return Math.random()-0.5; //将数组的元素设为随机数 &#125;);// 冒泡排序// 1、从后向前循环// 2、内部从前向后循环到外层变量// 3、判断前值是否大于后值，交换 function sort1(arr)&#123; var len=arr.length; //循环数组的长度 while(len&gt;0)&#123; //当len小于0时停止循环 for(var i=0;i&lt;len;i++)&#123; //循环的长度不断减小 if(arr[i]&gt;arr[i+1])&#123; //当第一位比第二位大时 var temp=arr[i]; //当前元素存放到临时变量中 arr[i]=arr[i+1]; //将下一位元素赋值给当前元素 arr[i+1]=temp; //将临时变量赋给 &#125; &#125; len--; &#125; &#125; sort1(arr); console.log(arr); 选择排序 1234567891011121314151617181920212223242526272829var arr=[]; for(var i=0;i&lt;100;i++)&#123; arr.push(i); //创建一个1-100的数组 &#125; arr.sort(function()&#123; return Math.random()-0.5; //将数组的元素设为随机数 &#125;); // 选择排序// 先找出最小或者最大的索引值，然后用当前的下标的元素与这个最小的元素交换// 1、遍历数组// 2、设置最小的索引值为当前的索引值// 3、从当前的下一项开始遍历到数组的尾部// 4、判断所有遍历的值中最小的值得索引值 // 5、交换当前值和最小索引值的元素 function sort2(arr)&#123; var minIndex; //设置一个最小数的变量 for(var i=0;i&lt;arr.length;i++)&#123; //从第一个数开始循环 minIndex=i; //将第一个数预设为最小数 for(var j=i+1;j&lt;arr.length;j++)&#123; //从第二个数开始循环 minIndex=arr[minIndex]&lt;arr[j] ? minIndex : j; //比较前一位与后一位的值 将小的值存放到minIndex中 &#125; var temp=arr[i]; //将两个值进行交换 将最小的值存放在a[minIndex]中 arr[i]=arr[minIndex]; arr[minIndex]=temp; &#125; &#125; sort2(arr); console.log(arr); 快速排序 123456789101112131415 var arr=[1,4,2,2,3,10]; arr=sort3(arr); function sort3(arr)&#123; if(arr.length&lt;=1) return arr; var left=[]; var right=[]; var item=arr.splice(parseInt(arr.length/2),1)[0]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;item) left.push(arr[i]); else right.push(arr[i]); &#125; var arr1=sort3(left).concat(item,sort3(right)); return arr1; &#125;","categories":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/categories/js%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"https://cooli-willson.github.io/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"数组","slug":"数组","permalink":"https://cooli-willson.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"重构","slug":"重构","permalink":"https://cooli-willson.github.io/tags/%E9%87%8D%E6%9E%84/"}]},{"title":"pure主题使用方法","slug":"pure主题使用方法","date":"2020-01-19T07:07:33.135Z","updated":"2020-01-20T17:14:37.980Z","comments":true,"path":"2020/01/19/pure主题使用方法/","link":"","permalink":"https://cooli-willson.github.io/2020/01/19/pure%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"pure主题","slug":"pure主题","permalink":"https://cooli-willson.github.io/categories/pure%E4%B8%BB%E9%A2%98/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"https://cooli-willson.github.io/tags/hello-world/"},{"name":"pure","slug":"pure","permalink":"https://cooli-willson.github.io/tags/pure/"}]}]}