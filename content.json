{"meta":{"title":"Wilson'bolg","subtitle":"","description":"","author":"Wilson","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-01-19T07:36:05.000Z","updated":"2020-01-19T07:36:05.771Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-19T07:40:21.000Z","updated":"2020-01-19T07:40:21.463Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2.js基础-运算符","slug":"2.js基础-运算符","date":"2020-01-20T14:42:27.505Z","updated":"2020-01-20T15:05:01.520Z","comments":true,"path":"2020/01/20/2.js基础-运算符/","link":"","permalink":"http://yoursite.com/2020/01/20/2.js%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"javascript 运算符 算术运算符 字符相加 1234567891011121314151617181920 // 隐式转换 多种数据类型不同时，进行运算需要将这些数据转换为相同类型才能运算，这个过程就是隐式转换 var a=\"a\"; var b=\"b\"; var b=3; var b=true; var b=false; var b; var b=null; var b=&#123;a:1&#125;; // 遇到字符串相加时，另一种数据隐式转换为字符型.String() // 遇到字符串相加时，另一种数据隐式转换为字符型.String() console.log(a+b);//字符相加时，首尾相连 var age=30; var s=\"今年我\"+age+\"岁了\"; console.log(s); var s=10; s=s+\"\"; console.log(s); // 等号是赋值，因此先运算等号右边的结果，然后赋值给等号左边 布尔值相加 12345678// 布尔值相加，不包含加字符 // 布尔值转换为数值，除字符外所有内容都是隐式转换为数值运算 Number() var a=true; var b=3; var b=true; var b; var b=null; // 任何数值加NaN都为NaN 对象相加 12345678 // Object 对象相加时都会转换为字符串相加 var a=&#123;a:1&#125;; var b=&#123;b:1&#125;; console.log(a+b); var arr=[1,2,3];//数组转换为字符串时是将数组的元素转换为字符串相连 var a=&#123;a:1&#125;; console.log(arr+a); console.log([]+[]); 数值运算 12345678 // 减法 乘法 除法 取模都遵循转换为数值运算 var a=true; var b=false; var b=\"5\"; var b; var b=null; var b=&#123;a:1&#125;; console.log(a*b); 赋值运算符和一元运算符 赋值运算符 1234567891011121314// 赋值运算符 var a=3; a+=5;//a=a+5; a+=\"\";//快速转换字符串 a*=3; a/=3; a%=2; a-=2; // 赋值运算符也是有结果的 var s=a+=2; console.log(s,a); if(a-=2)&#123; console.log(\"a\"); &#125; 一元运算符 12345678910111213141516171819202122232425var a=\"3\";a++;//a=a+1 a+=1;//31a++;//一元运算符强制将值转换为数值+1var a=3;console.log(a+=1);// a=a+1 a-&gt;返回结果console.log(a++);// a-&gt;返回出来 a=a+1;console.log(++a);//a=a+1 a-&gt;返回结果// a++和++a a的结果相同 返回结果不同var y=a++;var y=++a;var x=1;if(--x)&#123; console.log(\"aa\");&#125;var x=1; x=2-3-4-5 1+2+2+3+4var y=x++ + x + x++ + x++ + x++;var y=x + ++x + x++ +x++ + x++;console.log(y,x);console.log(\"2\"&gt;\"10\"); //trueconsole.log(undefined==null); console.log(undefined&gt;null); ### 关系运算符 **关系运算符** &gt; 大小比较 12345678// &gt; &lt; &gt;= &lt;= == === != !==var a=\"aa\";var b=\"ab\";console.log(b&gt;a);//判断字符串大小时先判断字符串首字符的ascii 或者 Unicode码值,如果相同判断后面字符的比较结果console.log(true&gt;false);//隐式转换为数值console.log(true&gt;\"\");console.log(\"a\"&gt;1);//字符串与数值比较时，字符串转换为数值再比较console.log(undefined&gt;null); 辅助运算符和相等关系运算符 = 赋值 == 比较 === 精确比较 比较值和类型 123456789101112131415161718192021222324252627282930313233343536console.log(\"1\"==1);console.log(\"\"==0);console.log(0==false);console.log(\"\"==false);0==\"\"== falseundefined==null console.log(undefined==null);//判读空的结果是否相同console.log(null==\"\");//falseconsole.log(null==0);//falseconsole.log(null==false);//false// NaN永远不和任何内容相等，包括NaNvar a=\"a\";if(a==NaN)&#123; // 判断a是否是NaN // isNaN()里面的内容会自动隐式转换为数值if(isNaN(a))&#123; console.log(\"非数值\");&#125;var a;if(a==null)&#123; // undefined null console.log(\"aa\");&#125;if(a==0)&#123; // a是0 false \"\"&#125; var obj=&#123;a:1&#125;; var obj1=&#123;a:1&#125;; console.log(obj==obj1); // 引用地址不同 console.log([]==[]); console.log(\"1\"==1); console.log(\"1\"===1);//比较值和类型 // != 不相等 console.log(0!=null); console.log([]!=[]); 逻辑运算符 逻辑与 1234true &amp;&amp; true =true;true &amp;&amp; false =false;false &amp;&amp; true =false;false &amp;&amp; false =false; 逻辑或 1234true || true =true;true || false =true;false || true =true;false || false =false; 逻辑运算符与一元运算符的应用 &amp;&amp; 运算的两端，如果有一端转换为布尔值是false，就把这个值返回出去（值是什么就返回什么，不是返回false） 如果两端转换为布尔值都是true，就返回&amp;&amp;运算符右侧的值，先运行左侧再运行右侧 如果左侧运算的结果是false，直接返回左侧值，不运算右侧 + 如果||的左侧的结果是ture，就直接返回左侧，不运算右侧，熔断 12345678910111213 var a=1;a=a-- &amp;&amp; ++a;s=--a &amp;&amp; ++a;a=a++ &amp;&amp; --a;console.log(s,a);// &amp;&amp; 运算的两端，如果有一端转换为布尔值是false，就把这个值返回出去（值是什么就返回什么，不是返回false）// 如果两端转换为布尔值都是true，就返回&amp;&amp;运算符右侧的值，先运行左侧再运行右侧// 如果左侧运算的结果是false，直接返回左侧值，不运算右侧var a=1;a=--a || a++;a=a-- || a++;// 如果||的左侧的结果是ture，就直接返回左侧，不运算右侧，熔断console.log(a); &gt; 逻辑非 + !取反值，先将内容转换为布尔值，然后去反值 +所有！运算符得到的结果都是布尔值 12345678// !取反值，先将内容转换为布尔值，然后去反值console.log(!10);//falseconsole.log(!\"\");//true// 所有！运算符得到的结果都是布尔值console.log(!obj1);console.log(obj==!obj1);console.log(![]==[]);//trueconsole.log([]==[]);//false 二进制和十六进制（未详细整理） 1234567891011121314151617181920212223242526 // 数值转换二进制 0,1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 20 0,1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111,10000 0,1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 0,1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10 56=5*8(1)+6*8(0)=46 1010=1*2(3)+0*2(2)+1*2(1)+0*2(0)=10; 567=5*10(2)+6*10(1)+7*10(0);//16进制 RGB 0xFFFFFF 0xFF0000 0x00FF00 0x0000FF 0x000000 0xFFFF00 黄色 0xFF9900 橙色 0xFF00FF 紫色 0x00FFFF 靛色 0xFFFFFFFF 180*180 64 128 512 32400*4=129,600 console.log(Boolean(\"abc\"&gt;\"aad\")); 位运算（未详细整理） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 console.log(~3); var str=\"abcdef\"; console.log(str.indexOf(\"z\")); if(~str.indexOf(\"z\"))&#123; console.log(\"找到了z\"); &#125; // 位与运算 &amp; console.log(5&amp;6); 101 110 100=4; // 1&amp;1=1 // 1&amp;0=0 // 0&amp;1=0 // 0&amp;0=0 10101010 10 10101000 // 位或运算 | console.log(7|6); 111 110 111=7 // 1|1=1 // 1|0=1 // 0|1=1 // 0|0=0 console.log(85|1); // 位异或运算 ^ console.log(7^6); 111 110 001 // 1^1=0 // 1^0=1 // 0^1=1 // 0^0=0 var pass=7856; var key=2534; var value=pass^key; // console.log(pass^key); console.log(value^key); // &lt;&lt;左移位 &gt;&gt;右移位 console.log(24&gt;&gt;2); // 11000&gt;&gt;2 ==&gt; 110; // 8&lt;&lt;2 100000==&gt;32; // 1&lt;&lt;n 求2的多少次幂 console.log(1&lt;&lt;5); console.log( (0x0000FF&lt;&lt;16).toString(16))","categories":[],"tags":[]},{"title":"1.js基础-数据类型","slug":"1.js基础-数据类型","date":"2020-01-20T13:51:37.020Z","updated":"2020-01-20T14:01:10.350Z","comments":true,"path":"2020/01/20/1.js基础-数据类型/","link":"","permalink":"http://yoursite.com/2020/01/20/1.js%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"1、javascript 基础 js 文件的引入 引入外部js 12&lt;script src=\"a.js\" async defer&gt;&lt;/script&gt;&lt;script src=\"b.js\"&gt;&lt;/script&gt; ES6的模块化导入 1234&lt;script type=\"module\"&gt; // ES6的模块化导入 import Box from \"./js/Box.js\"; &lt;/script&gt; 行内js的写法 123&lt;button onclick=\"alert('aaa')\"&gt;按钮&lt;/button&gt;&lt;a href=\"javascript:alert('aaa')\"&gt;超链接&lt;/a&gt;&lt;a href=\"javascript:void(0)\"&gt;超链接&lt;/a&gt; js标签 123456789 &lt;script&gt; a=10; &lt;/script&gt; &lt;script&gt; alert(b); &lt;/script&gt; &lt;script&gt; b=20;&lt;/script&gt; js注释 123456// a=3;//注释单行代码 /* a=3; b=4; */ //块状注释 // 不需要的禁止执行，注释后代码不会被执行，在以后可以复用 // 介绍说明代码作用 弹出框 123alert(\"aaa\");//弹出框confirm(\"你好\");//点击确定时返回true，否则返回falseprompt(\"请输入你的年龄\",\"18岁\");//输入弹出框，确定后会返回输入的内容 打印方式 1234console.log(\"aaaa\",\"bbbb\");//打印日志console.trace(\"aaa\");//用于显示当前执行的代码在堆栈中的调用路径。console.dir(\"aaa\");//打印部分标签内容console.error(\"错误的\");//打印错误 变量 常量和基本数据类型 变量 1234567891011a=4; b=6; // 定义变量 var a=4; var b=5; // 使用；结束一个代码语句，如果使用，表示没有结束该语句 var a=4, b=5; var a,b; // 先给a赋值，然后赋值给b var a=b=4; 变量命名规则 1234567891011121314151617181920212223242526272829303132 // 变量名称规则 // 变量要求小写字母开始，每个单词的首字母大写，叫做驼峰式命名 // var timeManager // 变量不能使用关键词和保留字 // var for; var int; // 变量尽量不要定义window的属性名，ES5中全局变量都会被设置在window的属性中 var a=10; console.log(window.a); console.log(a+5); window.status var status=20; console.log(status+5); //205 // 临时变量或者参数，起名时使用_开始 var _time=20;// 不能使用中文和拼音字母（我强制大家不能使用） var 姓名=\"谢天\"; console.log(姓名); var xingming=\"谢天\";var a=3; a=10;//值可以改变，就叫做变量 // 不希望值改变，常量ES6,常量不能修改 const EVENT_ID=\"eventid\"; EVENT_ID=\"abc\"; // 常量定义后的对象不能够被清除 const obj=&#123;a:1,b:2&#125;; 数据类型 字符型，数值型，布尔型，undefined,null,object ||E6 Symbol 五种基础类型，一种复杂类型 字符类型 1234567// 字符类型 String// \"\" '' ||ES6 `` var str1 = \"1\"; var str2 = '1'; var str3 = `1`; var str4 = \"这个'新的'鞋子价格不错\"; var str5 = '&#123;\"a\":4,\"b\":\"10\"&#125;'; 数值类型 123456789// 数值类型 Number var num1 = 1;//正整型var num2 = -1;//负整型var num3 = 1.3;//浮点型var num4 = 056;//8进制数值,0起头，数值不能大于7var num5 = 0xFF;//16进制数值，0x起头，单个数值不能大于Fvar num6 = 1.2e+3;//科学计数法var num7 = 1.2e-3;//科学计数法` 布尔类型 123// 布尔类型 Boolean var bool1 = true; var bool2 = false; 未定义型 123// 未定义型 undefined 值和类型相同 var und1; var und2 = undefined; 空值 123// 空值 null null的类型Object型 var nu = null; console.log(nu,typeof(nu)); 对象类型 123456789var obj = &#123; // 属性 id: 1001, name: \"电脑桌\", price: \"700\", getSum: function () &#123; // 方法 &#125; &#125;; 数据类型的存储 前五种基础类型都存储在栈中，对象存储在堆中 对象类型的特性 1234567891011121314151617181920212223242526var obj=&#123;a:1&#125;; console.log(String(obj));//[object Object] 所有的对象转换为字符串就会变成这样 console.log(JSON.stringify(obj));//将object对象转换为字符串（JSON字符串） console.log(JSON.parse('&#123;\"a\":1&#125;'));//将JSON字符串转换为对象 var obj1=JSON.parse(JSON.stringify(obj)); obj.a=5; console.log(obj,obj1) console.log(JSON.stringify(obj),JSON.stringify(obj1)); console.log(obj1===obj); // 变量名存储的是引用地址 var obj2=obj;//将引用地址赋值给obj2 obj.a=10; console.log(obj2.a); // 存在栈中，修改的是值 var num=3; var num1=num; num=10; console.log(num1); // 存在堆中，修改引用地址值的内容，地址不会发生改变 var obj1=JSON.parse(JSON.stringify(obj)); var obj=&#123;a:10,b:&#123;a:20&#125;&#125;; console.log(obj); obj.a=10; // 内存泄漏 不断的创建新对象，不使用的旧对象不清除 obj=null;//当给变量设置为null // 垃圾回收机制 gc 当对象的引用地址在栈中没有引用时，内存占比过高时，垃圾回收车会将其清除 数据类型的转换 任何类型转换为数值型 123456789101112131415161718192021222324252627// NaN 数值型 非数值var a=\"5\";var a=\"5a\";//字符串中如果有字符存在，转换后就变成NaNvar a=\"\";//空字符串转换为数值是 0var a=true;//1var a=false;//0var a;//undefined NaN 非数值var a=null;//0 null是0Number(值);console.log(Number(a));var a=\"52.1a\";//使用parseInt转字符串，从第一个数字字符开始到第一个字符类型为止转换为数值var a=\"a45\";//使用parseInt转字符串，从第一个数字字符开始到第一个字符类型为止转换为数值var a=\"4a5\";//使用parseInt转字符串，从第一个数字字符开始到第一个字符类型为止转换为数值var a=\"FF\";var a=\"101010010101\";color=\"#FF00FF\"--&gt;\"rgb(255,0,255)\";var a=true;//NaNvar a=false;//NaNvar a;//NaNvar a=null;//NaNvar a=&#123;a:1&#125;;console.log(Number(a));//NaN// parseInt(要转换的内容，该内容是什么进制) 将他转换为10进制数值console.log(parseInt(a,2))//转换为整型console.log(parseInt(a))//字符串转换为整型console.log(parseFloat(a))//字符串转换为浮点型 任何类型转换为字符串 1234567891011121314151617181920212223var a=10; var a=1555; var a=0; var a=0xFF; var a=4.1e+2; // 先将所有的数值都转换为10进制在转换为字符串 var a=true; var a=false; var a;//undefined var a=null;//null var a=&#123;a:1&#125;; console.log(a); console.log(String(a));//转换为字符串 // a.toString(按照什么进制转换为字符串); console.log(a.toString(36));//2-36 var a=new Date(); console.log(a.toLocaleString());//转换为本地字符串 console.log(a.toUTCString());//转换为格林尼治时间字符串 console.log(a.toString()); // toFixed toPrecision toExponential 都是针对数值转换 console.log(a.toFixed(1));//保留几位小数,会自动四舍五入 console.log(a.toPrecision(2));//总共保留几位，会自动四舍五入或者科学计数法 console.log(a.toExponential(2));//小数点后保留几位，不会自动四舍五入，一定科学计数法 任何类型转换为布尔值 1234567891011121314var a=\"\";//falsevar a=0;//falsevar a=undefined;//falsevar a=null;//falsevar a=NaN;//falsevar a=false;console.log(Boolean(a));// \"\" 0 undefined null NaN false 转换为布尔值都是false// 除上述6种以外转换为布尔值都是truevar a=\"0\";console.log(Boolean(a));var a=3;// 强转为对象类型console.log(Object(a));","categories":[],"tags":[]},{"title":"通过数组方法实现的简单功能","slug":"通过数组方法实现的简单功能","date":"2020-01-19T08:04:27.014Z","updated":"2020-01-19T08:04:27.019Z","comments":true,"path":"2020/01/19/通过数组方法实现的简单功能/","link":"","permalink":"http://yoursite.com/2020/01/19/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%9F%E8%83%BD/","excerpt":"","text":"实现功能 去重 原生版 12345678910111213141516var arr=[1,2,2,4,3,4,5,4,2,6,2,7]; var arr1=[]; for(var i=0;i&lt;arr.length;i++)&#123; //遍历当前数组的长度 var bool=false; //flag for(var j=0;j&lt;arr1.length;j++)&#123; //循环arr1长度 if(arr[i]===arr1[j])&#123; //当arr的元素全等于arr1 bool=true; //改变flag的布尔值 break; //跳出循环 &#125; &#125; if(!bool)&#123; arr1.push(arr[i]); //将arr的元素赋值给arr1 &#125; &#125; arr=arr1.splice(0); arr1=null; 去重indexOf版 123456789 var arr=[1,2,2,4,3,4,5,4,2,6,2,7]; var arr1=[]; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr1.indexOf(arr[i])&lt;0) arr1.push(arr[i]); //当arr下的每个元素在index属性下返回负一时 将元素储存在arr1中 ？？？ &#125; arr=arr1.splice(0); arr1=null; console.log(arr); 去重delete版 123456789101112var arr=[1,2,2,4,3,4,5,4,2,6,2,7]; for(var i=1;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr.indexOf(arr[i],i+1)&gt;-1) delete arr[i]; //要查找的元素下标为i,从i+1开始，当找到相同元素时，将下标为i的元素删除 if(arr.lastIndexOf(arr[i],i-1)&gt;-1) delete arr[i]; //倒叙遍历，重复以上操作 &#125; var arr1=[]; //空数组arr1; for(var prop in arr)&#123; //循环arr的长度 arr1.push(arr[prop]); //将arr的元素储存在arr1中 &#125; arr=arr1.splice(0); //将arr数组的所有元素传递给arr1 arr1=null; //清空数组arr1 console.log(arr); //控制台打印arr 数组的遍历 for循环遍历 123456var arr=[1,2,3,,4,5,6]; arr.a=3; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 console.log(i,arr[i]); //打印下标 和下标的每个元素 &#125; for in循环遍历 12345for in 循环可以把数组的可枚举属性遍历到for in不能遍历到数组的空元素 for(var prop in arr)&#123; //prop相当于数组的下标 console.log(prop,arr[prop]); //打印下标，和下标的每个元素 &#125; 将获取的标签元素转换为数组类型 123456789// ES6var list=Array.from(inputs);console.log(list);// ES5var list=Array.prototype.slice.call(inputs);var list=[].slice.call(inputs);var list=Array.prototype.concat.apply([],inputs);var list=[].concat.apply([],inputs); 实现列表的全选功能??? 12345678910111213141516171819202122232425262728293031323334&lt;ul&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;全选&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"checkbox\"&gt;&lt;/li&gt; &lt;/ul&gt; var inputs=document.getElementsByTagName(\"input\"); //将获取的input标签的元素储存在inputs中 var arr=Array.from(inputs); //将获取的标签元素转换为数组类型 for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 arr[i].onclick=clickHandler; //当点击时调用clickHandler函数 &#125; function clickHandler()&#123; var self=this; //将当前元素用self存储 if(arr.indexOf(this)===0)&#123; //当前元素为0时 arr.forEach(function(item,index)&#123; if(index===0) return; //当前元素下标为0时 返回 // foreach中this被重新指向到window（所有的回调函数） item.checked=self.checked; //将所有元素都天机checked属性 &#125;) &#125;else&#123; arr[0].checked=arr.slice(1).every(function(item)&#123; //？？？ return item.checked; //??? &#125;) &#125; &#125; 对表格中的商品通过属性进行筛选 123456789101112131415161718192021var data=[ &#123;id:1001,icon:\"img/1.png\",name:\"餐饮0\",num:1,price:10&#125;, &#123;id:1002,icon:\"img/2.png\",name:\"餐饮1\",num:1,price:20&#125;, &#123;id:1003,icon:\"img/3.png\",name:\"餐饮2\",num:1,price:30&#125;, &#123;id:1004,icon:\"img/4.png\",name:\"餐饮3\",num:1,price:40&#125;, &#123;id:1005,icon:\"img/5.png\",name:\"餐饮4\",num:1,price:50&#125;, &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;, &#123;id:1007,icon:\"img/7.png\",name:\"餐饮6\",num:1,price:70&#125;, &#123;id:1008,icon:\"img/8.png\",name:\"餐饮7\",num:1,price:80&#125;, &#123;id:1009,icon:\"img/9.png\",name:\"餐饮8\",num:1,price:90&#125;, &#123;id:1010,icon:\"img/10.png\",name:\"餐饮9\",num:1,price:100&#125;];var arr=data.filter(function(item)&#123; return item.price&gt;60; //返回所有价格&gt;60的元素&#125;)console.log(arr);var item=data.filter(function(item)&#123; return item.id==1006; //返回id==1006的元素&#125;)[0];console.log(item); 实现购物车功能 12345678910111213141516171819202122var data=[ &#123;id:1001,icon:\"img/1.png\",name:\"餐饮0\",num:1,price:10&#125;, &#123;id:1002,icon:\"img/2.png\",name:\"餐饮1\",num:1,price:20&#125;, &#123;id:1003,icon:\"img/3.png\",name:\"餐饮2\",num:1,price:30&#125;, &#123;id:1004,icon:\"img/4.png\",name:\"餐饮3\",num:1,price:40&#125;, &#123;id:1005,icon:\"img/5.png\",name:\"餐饮4\",num:1,price:50&#125;, &#123;id:1006,icon:\"img/6.png\",name:\"餐饮5\",num:1,price:60&#125;, &#123;id:1007,icon:\"img/7.png\",name:\"餐饮6\",num:1,price:70&#125;, &#123;id:1008,icon:\"img/8.png\",name:\"餐饮7\",num:1,price:80&#125;, &#123;id:1009,icon:\"img/9.png\",name:\"餐饮8\",num:1,price:90&#125;, &#123;id:1010,icon:\"img/10.png\",name:\"餐饮9\",num:1,price:100&#125; ]; data.forEach(function(item)&#123; //遍历整个数组 item.selected=Math.random()&lt;0.5; //随机选择被选中的元素 item.num=parseInt(Math.random()*5+5); //给num属性随机赋值 item.total=item.num*item.price; //将数量和价格相乘得出的结果付给tatal（总价） &#125;); var sum=data.reduce(function(value,item)&#123; //归并data并且赋值到sum中 return item.selected ? value+item.total : value; //若选中就加到vale中，没有选则不加 &#125;,0); console.log(sum);","categories":[],"tags":[]},{"title":"数组方法的重构","slug":"数组方法的重构","date":"2020-01-19T08:04:24.522Z","updated":"2020-01-19T08:49:27.895Z","comments":true,"path":"2020/01/19/数组方法的重构/","link":"","permalink":"http://yoursite.com/2020/01/19/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E6%9E%84/","excerpt":"","text":"数组方法的重构 push 功能： *在数组尾部添加一个或者多个新元素，并且返回数组的新长度 使用方法： 1arr.push(5,6,7); push 重构 123456789var arr=[1,2,4,5,67,78];function push(arr)&#123; //传入参数为数组 for(var i=1;i&lt;arguments.length;i++)&#123; //循环除数组外其他元素的长度 arr[arr.length]=arguments[i]; //在尾部添加参数通过下标赋值 &#125; return arr.length; //返回数组长度 &#125;var i=push(arr,5,6,7); //调用push方法，参数为数组，5，6，7console.log(arr,i); */ //数组长度，新数组 pop 功能： #### *删除数组的**尾部**元素，并且返回这个**被删除的元素** 使用方法： 12// var item=arr.pop();// console.log(item,arr); pop 重构 1234567function pop(arr)&#123; var item=arr[arr.length-1]; //用item储存最后一个参数 arr.length--; //数组的长度减一 return item; //返回这个被删除的参数 &#125;pop(arr); unshift 功能： *将一个或者多个新元素添加在数组的最前面，返回数组的新长度 使用方法： 1arr.unshift(1,2,3); unshift 重构 12345678910111213function unshift(arr)&#123; var len=arguments.length-1; //len储存除数组以外的其他元素的长度 for(var i=arr.length-1;i&gt;=0;i--)&#123; //循环当前数组的长度 arr[i+len]=arr[i]; //将当前数组的元素向后移 &#125; for(var j=1;j&lt;arguments.length;j++)&#123; //循环参数的长度（除arr外） arr[j-1]=arguments[j]; //将参数赋值给数组的前面 &#125; return arr.length; //返回数组的新长度 &#125; unshift(arr,10,11,12); console.log(arr); shift 功能： 删除数组的第一个元素，并返回该元素 使用方法 1arr.shift(); shift 重构 123456789101112function shift (arr) &#123; if (!(arr instanceof Array)) throw new Error(\"请确保参数类型为数组\") //判断传入参数是否为数组 var el; if (arr.length &gt; 0) &#123; //如果数组有长度 el = arr[0] //将第一个元素储存在el中 for (var i = 0; i &lt; arr.length - 1; i++) &#123; //循环数组的长度 arr[i] = arr[i + 1] //将数组的每个元素前移一位 &#125; arr.length = arr.length - 1 //数组的长度减一 &#125; return el&#125; concat 功能： *复制，复制后给新数组添加新元素，多个数组连接形成数组 使用方法 123var arr=[1,2,3,4];var arr1=arr.concat(10,11,12); //连接形成新数组var arr1=arr.concat(); //复制数组 concat 重构??? 123456789101112131415161718function concat(arr)&#123; var array=[]; //定义一个新数组 var index=0; //下标变量 for(var i=0;i&lt;arr.length;i++,index++)&#123; // 循环数组的长度 array[index]=arr[i]; //将数组复制arr数组到array数组 &#125; for(var j=1;j&lt;arguments.length;j++,index++)&#123; //遍历参数的长度(除数组外) if(arguments[j].constructor===Array)&#123; //当参数为数组时 for(var k=0;k&lt;arguments[j].length;k++,index++)&#123; //遍历数组的长度 array[index]=arguments[j][k]; //将参数为数组的参数赋值给 &#125; index--; &#125;else&#123; array[index]=arguments[j]; &#125; &#125; return array; &#125; join 功能： *转换为字符串，使用参数进行分割 使用方法 123console.log(arr.join()); console.log(arr.join(\"#\"));//1#2#3#4console.log(arr.join(\"\"));//1234 join 重构（myself） 123456789function join(arr,and)&#123; //参数为数组和连接符 for(var i = 0; i&lt;arr.length-1;i++)&#123; //循环数组长度 arr[i]+=and; //数组加入连接符 &#125; return arr; &#125; var arr = [3, 1, 6, 5, 4, 8, 9]; join(arr,\"|\"); document.write(arr); splice 功能： *给数组中添加、删除、替换一个或者多个元素，返回被删除元素组成的数组 使用方法 12345678910111213141516// arr.splice(从什么位置开始,删除多少个元素,添加的元素...); // var arr1=arr.splice();//创建一个空数组// var arr1=arr.splice(0);//将数组的所有元素传递给新数组// 负数指从后向前数// var arr1=arr.splice(-2);//从数组的倒数第二位开始截取到尾部// var arr1=arr.splice(2,2);//从第二位开始删除2个元素// var arr1=arr.splice(ar2,0,12,14);//插入元素13，14，插入在第二位// var arr1=arr.splice(2,2,12,14);//替换元素，删除两位并且插入12，14// console.log(arr1,arr); splice 重构 1234567891011121314151617181920212223242526function splice(arr,start,count)&#123; //第一个参数是数组 第二个参数是开始位置 第三个参数是一共替换几个参数 var a=[]; //定义一个空数组 start=Number(start); //将开始参数设为数值型 count=Number(count); //将count转为数值型 if(isNaN(start))return a; //如果start为NaN 返回空数组 if(start&lt;0) start+=arr.length; //如果start小于0 start等于数组长度 数据从最后一位开始插入 if(isNaN(count)) count=arr.length-start; //？？？ for(var i=start,j=0;i&lt;arr.length;i++,j++)&#123; //遍历从start位置开始长度小于数组的长度 if(j&lt;count) a.push(arr[i]); //当循环次数小于count参数时储存在arr当前下标位置 arr[i]=arr[i+count]; //arr当前下标的值等于i+count; &#125; for(var l=0;l&lt;arguments.length-3;l++)&#123; //遍历处前三个参数外其他参数的值 for(var m=arr.length-1;m&gt;=start+l;m--)&#123; //??? arr[m+1]=arr[m]; //??? &#125; &#125; for(var n=3;n&lt;arguments.length;n++)&#123; //循环参数的长度 arr[start+n-3]=arguments[n]; //设定参数在数组中的下标赋值 &#125; for(var k=0;k&lt;count;k++)&#123; //替换时减去数组的长度 arr.length--; &#125; return a; &#125; var arr1=splice(arr,2,2,10,11,12); console.log(arr1,arr); slice 功能： *截取数组的某一段的值，返回一个新数组，原数组不改变 使用方法 1234567// var arr1=arr.slice();//复制一个新数组 // var arr1=arr.slice(1);//从第几项复制到尾部 // var arr1=arr.slice(-2);//从倒数第二位复制到尾部 // var arr1=arr.slice(2,3);//从第二位复制到第三位之前 // var arr1=arr.slice(-3,-1);//从倒数第三位复制到倒数第一位之前 // var arr1=arr.slice(2,-1);//从第二位复制到倒数第一位之前 // console.log(arr1,arr); slice 重构 123456789101112131415function slice(arr,start,end)&#123; //第一个参数为数组 第二个值为开始截取位置 start=Number(start); //将参数转为数值型 end=Number(end); //将参数转为数值型 if(isNaN(start)) start=0; //如果start为NaN 将strat变为0； if(isNaN(end)) end=arr.length; //如果end为NaN if(start&lt;0) start=start+arr.length; //如果参数为0,start为数组的长度 if(end&lt;0) end=end+arr.length; //如果参数为0，end为数组的长度 var a=[]; for(var i=start,j=0;i&lt;end;i++,j++)&#123; //循环开始到结束的下标 a[j]=arr[i]; //将截取的数组赋值给新数组a &#125; return a; //返回新数组 &#125; var arr1=slice(arr,2,-1); console.log(arr1,arr); indexOf 功能： *查找元素在数组中的下标，如果没有查找到返回-1 使用方法 1234567891011 //从前向后查找arr.indexOf(要查找的元素,从第几位开始查找被包含);console.log(arr.indexOf(3,2)); // 从后向前查找arr.lastIndexOf(要查找的元素,从第几位开始查找被包含); var index=-1;while(~(index=arr.indexOf(2,index+1)))&#123; //~加一取反 循环条件也是表达式 console.log(index)&#125; indexOf重构 1234567891011121314151617181920212223function CreateString(str)&#123; var obj = &#123; data: str, //indexOf 方法 IndexOf: function (chara1) &#123; for (var i = 0; i &lt; this.data.length; i++) &#123; if (str.substr(i, chara1.length) == chara1&#123; break; &#125; &#125; return i; &#125;, //lastIndexOf 方法 LastIndexOf: function (chara2) &#123; for (var i = this.data.length; i &gt; 0; i--) &#123; if (this.data.substr(i, chara2.length) == chara2) &#123; break; &#125; &#125; return i; &#125; &#125;&#125; delete 功能： #### *删除数组元素，不会造成数组的自动收缩，紧密，数组的长度不会发生改变 使用方法： 123var arr=[1,2,3,4,5,6];delete arr[2];console.log(arr); forEach循环 功能： *forEach不遍历空元素，也不遍历属性，forEach是匿名函数，无法阻止它在循环中中断循环跳出 使用方法： 12345var arr=[2,4,6,8,10,,12,14,16,18,20]; arr.a=10;arr.forEach(function(item,index,a)&#123; //item:当前元素 index:当前元素的下标 当前元素所属的数组对象 console.log(item,index,a);&#125;); forEach重构 1234567891011function forEach(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr[i]===undefined) continue; //当前元素为空时，直接执行下一次循环 fn(arr[i],i,arr); //fn参数为：当前元素，当前元素下标，当前元素的数组对象 &#125; &#125; // 桥接模式forEach(arr,function(item,index,a)&#123; //调用forEach函数 console.log(item,index,a); //打印每个参数值&#125;) */ map 功能： 1map同样不会遍历空数组，map与forEach不同的是：forEach不能返回任何内容，map会将回到函数中return的结果返回到新数组中 使用方法： 12345var a=arr.map(function(item,index,a)&#123; console.log(item,index,a); return item; &#125;);console.log(a); 重构map 12345678910111213function map(arr,fn)&#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr[i]===undefined) continue; //当前元素为空时直接进行下一次循环 a[i]=fn(arr[i],i,arr); //将函数fn存放在数组中 &#125; return a; //返回数组a,元素为每个函数 &#125; var a=map(arr,function(item,index,a)&#123; return item; &#125;); console.log(a); some 功能： 遍历数组，查找是否有满足条件（返回的结果如果是true）就直接跳出遍历，返回true 使用方法: 12345678910var arr=[1,2,3,4,5,6]; if(arr.some(function(item)&#123;item&gt;3&#125;))&#123; //遍历arr,查询元素是否有大于3的，有的话返回true &#125; var bool=arr.some(function(item,index,a)&#123; return item&gt;4; //遍历arr,查询元素是否有大于4的，有的话返回ture &#125;) console.log(bool); //打印结果为ture some重构 123456789101112function some(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(arr[i]===undefined) continue; //如果数组的元素为空，直接执行下一次的循环 if(fn(arr[i],i,arr)) return true; //如果fn函数的返回值为ture 返回ture &#125; return false; //当第二个if语句条件不成立时，返回flase &#125; var bool=some(arr,function(item)&#123; //执行some函数，返回值储存在bool中 return item&gt;10; //判断表达式的值并返回 &#125;) console.log(bool); every 功能： *判断每一个是否都满足条件，如果有一个返回的结果是false，直接返回false 使用方法： 1234var bool=arr.every(function(item)&#123; return item&gt;4; &#125;); console.log(bool); every重构 1234567891011function every(arr,fn)&#123; for(var i=0;i&lt;arr.length;i++)&#123; if(!fn(arr[i],i,arr)) return false; //当条件不满足时返回false &#125; return true; &#125; var bool=every(arr,function(item)&#123; return item&gt;4; //返回boolean值类型 &#125;); console.log(bool); fill 功能： *用于将一个固定数值替换数组的元素 使用方法： 123456789101112131415array.fill(value, start, end)参数 描述value 必需。填充的值。start 可选。开始填充位置。end 可选。停止填充位置 (默认为 array.length)填充 \"Runoob\" 到数组的最后两个元素：var fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.fill(\"Runoob\", 2, 4);输出结果：Banana,Orange,Runoob,Runoob fill重构 12 filter 功能： *创建一个新的数组，新数组中的元素时通过检查置顶数组中符合条件的所有元素 注意： filter() 不会对空数组进行检测。 注意： filter() 不会改变原始数组。 使用方法： 123456789101112var arr1=arr.filter(function(item,index,a)&#123; // console.log(item,index,a); return item&gt;4; //当条件成立时返回 &#125;); console.log(arr1); array.filter(function(currentValue,index,arr), thisValue);参数 描述currentValue 必须。当前元素的值index 可选。当前元素的索引值arr 可选。当前元素属于的数组对象 filter 重构 123456789101112function filter(arr,fn)&#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; //循环数组的长度 if(fn(arr[i],i,arr)) a[a.length]=arr[i]; //将在arr数组中满足条件的元素储存到a数组中 &#125; return a; &#125; var arr1=filter(arr,function(item)&#123; return item&gt;4 //符合表达式的进行返回 &#125;); console.log(arr1); reduce 功能： 归并 arr.reduce(function(上次归并值，本次遍历的元素，索引值，数组),初始化值)； 如果没有设置初始化值，上次归并值初始值为数组的第0项，本次遍历将从下标1开始 如果设置了初始化值，上次归并值初始值就是初始化值，本次遍历将从下标0开始* 使用方法： 1234567//arr.reduce(function(上次归并值，本次遍历的元素，索引值，数组),初始化值)； var arr=[1,2,3,4,5]; var sum= arr.reduce(function(value,item,index,a)&#123; //上次归并值，本次遍历的元素，下标，数组 console.log(value,item); return value+item; //返回归并值 &#125;,100); //初始化值为100 console.log(sum); */ reduce 重构 12345678910111213141516171819202122function reduce(arr,fn,initValue)&#123; //参数为 数组 初始化值 var start=0; if(initValue===undefined)&#123; //如果初始化值未定义 initValue=arr[0]; //将数组的第一个元素设为初始化值 start++; &#125; for(var i=start;i&lt;arr.length;i++)&#123; //当初始化值为第一个元素时，从第二个开始归并 initValue=fn(initValue,arr[i],i,arr) //桥接模式 &#125; return initValue; //返回初始值也就是归并值 &#125; var arr=[1,2,3,4]; var sum=reduce(arr,function(value,item)&#123; return value+item; //返回归并值 &#125;,100); console.log(sum); var sum=arr.reduce(function(value,item)&#123; //调用归并函数 console.log(value); &#125;,null) reverse 功能： * 倒序，不排序，原数组改变，返回原数组 使用方法 123var arr=[1,4,6,2,3,8,7,6,5,3,9];arr.reverse();console.log(arr); reverse 重构 1234567891011121314function reverse(arr)&#123; var len=parseInt(arr.length/2); //长度为数组长度的1/2 for(var i=0;i&lt;len;i++)&#123; //循环一数组1/2的长度 // arr[arr.length-1-i]=arr[i]; var temp=arr[arr.length-1-i]; //将最后一位赋值给临时变量 arr[arr.length-1-i]=arr[i]; //将第一位赋值给最后一位 arr[i]=temp; //将临时变量的值赋给第一位 &#125; return arr; //返回这个数组 &#125; reverse(arr); console.log(arr); sort 功能： *用于对数组的元素进行排序 使用方法： 123456789arrayObject.sort(sortby);参数 描述sortby 可选。规定排序顺序。必须是函数。arr.sort(); //按照ASCII码值进行排序 arr.sort(function(a,b)&#123; return a-b; //从大到小排列 &#125;) console.log(arr); sort重构 冒泡排序： 123456789101112131415161718192021222324252627282930var arr=[]; for(var i=0;i&lt;100;i++)&#123; arr.push(i); //创建一个1-100的数组 &#125; arr.sort(function()&#123; return Math.random()-0.5; //将数组的元素设为随机数 &#125;);// 冒泡排序// 1、从后向前循环// 2、内部从前向后循环到外层变量// 3、判断前值是否大于后值，交换 function sort1(arr)&#123; var len=arr.length; //循环数组的长度 while(len&gt;0)&#123; //当len小于0时停止循环 for(var i=0;i&lt;len;i++)&#123; //循环的长度不断减小 if(arr[i]&gt;arr[i+1])&#123; //当第一位比第二位大时 var temp=arr[i]; //当前元素存放到临时变量中 arr[i]=arr[i+1]; //将下一位元素赋值给当前元素 arr[i+1]=temp; //将临时变量赋给 &#125; &#125; len--; &#125; &#125; sort1(arr); console.log(arr); 选择排序 1234567891011121314151617181920212223242526272829var arr=[]; for(var i=0;i&lt;100;i++)&#123; arr.push(i); //创建一个1-100的数组 &#125; arr.sort(function()&#123; return Math.random()-0.5; //将数组的元素设为随机数 &#125;); // 选择排序// 先找出最小或者最大的索引值，然后用当前的下标的元素与这个最小的元素交换// 1、遍历数组// 2、设置最小的索引值为当前的索引值// 3、从当前的下一项开始遍历到数组的尾部// 4、判断所有遍历的值中最小的值得索引值 // 5、交换当前值和最小索引值的元素 function sort2(arr)&#123; var minIndex; //设置一个最小数的变量 for(var i=0;i&lt;arr.length;i++)&#123; //从第一个数开始循环 minIndex=i; //将第一个数预设为最小数 for(var j=i+1;j&lt;arr.length;j++)&#123; //从第二个数开始循环 minIndex=arr[minIndex]&lt;arr[j] ? minIndex : j; //比较前一位与后一位的值 将小的值存放到minIndex中 &#125; var temp=arr[i]; //将两个值进行交换 将最小的值存放在a[minIndex]中 arr[i]=arr[minIndex]; arr[minIndex]=temp; &#125; &#125; sort2(arr); console.log(arr); 快速排序 123456789101112131415 var arr=[1,4,2,2,3,10]; arr=sort3(arr); function sort3(arr)&#123; if(arr.length&lt;=1) return arr; var left=[]; var right=[]; var item=arr.splice(parseInt(arr.length/2),1)[0]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;item) left.push(arr[i]); else right.push(arr[i]); &#125; var arr1=sort3(left).concat(item,sort3(right)); return arr1; &#125;","categories":[],"tags":[]},{"title":"pure主题使用方法","slug":"pure主题使用方法","date":"2020-01-19T07:07:33.135Z","updated":"2020-01-19T09:10:55.345Z","comments":true,"path":"2020/01/19/pure主题使用方法/","link":"","permalink":"http://yoursite.com/2020/01/19/pure%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}